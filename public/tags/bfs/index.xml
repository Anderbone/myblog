<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Bfs on Jiyu</title>
    <link>http://localhost:1313/tags/bfs/</link>
    <description>Recent content in Bfs on Jiyu</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Fri, 15 Jul 2022 08:47:57 +0100</lastBuildDate>
    <atom:link href="http://localhost:1313/tags/bfs/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>139. word break</title>
      <link>http://localhost:1313/leetcode/139/</link>
      <pubDate>Sat, 22 Oct 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/139/</guid>
      <description>Word Break - LeetCode&#xA;Given a string s and a dictionary of strings wordDict, return true if s can be segmented into a space-separated sequence of one or more dictionary words. Note that the same word in the dictionary may be reused multiple times in the segmentation.&#xA;Example 1: Input: s = &amp;ldquo;leetcode&amp;rdquo;, wordDict = [&amp;ldquo;leet&amp;rdquo;,&amp;ldquo;code&amp;rdquo;] Output: true Explanation: Return true because &amp;ldquo;leetcode&amp;rdquo; can be segmented as &amp;ldquo;leet code&amp;rdquo;.&#xA;code bfs with string class Solution: def wordBreak(self, s: str, wordDict: List[str]) -&amp;gt; bool: q = deque(wordDict) seen = set(wordDict) while q: cur = q.</description>
    </item>
    <item>
      <title>695. Max Area of Island</title>
      <link>http://localhost:1313/leetcode/695/</link>
      <pubDate>Fri, 15 Jul 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/695/</guid>
      <description>https://leetcode.com/problems/max-area-of-island/&#xA;You are given an m x n binary matrix grid. An island is a group of 1&amp;rsquo;s (representing land) connected 4-directionally (horizontal or vertical.) You may assume all four edges of the grid are surrounded by water. The area of an island is the number of cells with a value 1 in the island. Return __the maximum area of an island in __grid. If there is no island, return 0.</description>
    </item>
    <item>
      <title>199. Binary Tree Right Side View</title>
      <link>http://localhost:1313/leetcode/199/</link>
      <pubDate>Mon, 11 Jul 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/199/</guid>
      <description>https://leetcode.com/problems/binary-tree-right-side-view/&#xA;Given the root of a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom.&#xA;Example 1: Input: root = [1,2,3,null,5,null,4] Output: [1,3,4] Example 2: Input: root = [1,null,3] Output: [1,3] Example 3: Input: root = [] Output: []&#xA;Constraints:&#xA;The number of nodes in the tree is in the range [0, 100]. -100 &amp;lt;= Node.</description>
    </item>
    <item>
      <title>127. word ladder</title>
      <link>http://localhost:1313/leetcode/127/</link>
      <pubDate>Tue, 22 Mar 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/127/</guid>
      <description>https://leetcode.com/problems/word-ladder/&#xA;A transformation sequence from word beginWord to word endWord using a dictionary wordList is a sequence of words beginWord -&amp;gt; s1 -&amp;gt; s2 -&amp;gt; &amp;hellip; -&amp;gt; sk such that:&#xA;Every adjacent pair of words differs by a single letter. Every si for 1 &amp;lt;= i &amp;lt;= k is in wordList. Note that beginWord does not need to be in wordList. sk == endWordGiven two words, beginWord and endWord, and a dictionary wordList, return __the **number of words** in the **shortest transformation sequence** from__ beginWord __to__ endWord__, or __0__ if no such sequence exists.</description>
    </item>
    <item>
      <title>247. Strobogrammatic Number II</title>
      <link>http://localhost:1313/leetcode/247/</link>
      <pubDate>Wed, 09 Mar 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/247/</guid>
      <description>https://leetcode.com/problems/strobogrammatic-number-ii/&#xA;Given an integer n, return all the strobogrammatic numbers that are of length n. You may return the answer in any order. A strobogrammatic number is a number that looks the same when rotated 180 degrees (looked at upside down).&#xA;Example 1: Input: n = 2 Output: [&amp;ldquo;11&amp;rdquo;,&amp;ldquo;69&amp;rdquo;,&amp;ldquo;88&amp;rdquo;,&amp;ldquo;96&amp;rdquo;] Example 2: Input: n = 1 Output: [&amp;ldquo;0&amp;rdquo;,&amp;ldquo;1&amp;rdquo;,&amp;ldquo;8&amp;rdquo;]&#xA;Constraints:&#xA;1 &amp;lt;= n &amp;lt;= 14&#xA;code class Solution: def findStrobogrammatic(self, n: int) -&amp;gt; List[str]: if n == 1: return [&amp;#39;0&amp;#39;,&amp;#39;1&amp;#39;,&amp;#39;8&amp;#39;] res = [] dic = {&amp;#39;6&amp;#39;:&amp;#39;9&amp;#39;,&amp;#39;9&amp;#39;:&amp;#39;6&amp;#39;,&amp;#39;0&amp;#39;:&amp;#39;0&amp;#39;,&amp;#39;1&amp;#39;:&amp;#39;1&amp;#39;,&amp;#39;8&amp;#39;:&amp;#39;8&amp;#39;} def backtracking(left, path): if left &amp;lt; 0: return if left == 0: res.</description>
    </item>
    <item>
      <title>1490. Clone N-ary Tree</title>
      <link>http://localhost:1313/leetcode/1490/</link>
      <pubDate>Thu, 03 Mar 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/1490/</guid>
      <description>Clone N-ary Tree - LeetCode&#xA;Given a root of an N-ary tree, return a deep copy (clone) of the tree. Each node in the n-ary tree contains a val (int) and a list (List[Node]) of its children. class Node { public int val; public List children; } Nary-Tree input serialization is represented in their level order traversal, each group of children is separated by the null value (See examples).&#xA;Example 1: Input: root = [1,null,3,2,4,null,5,6] Output: [1,null,3,2,4,null,5,6] Example 2: Input: root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14] Output: [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]</description>
    </item>
    <item>
      <title>662. Maximum Width of Binary Tree</title>
      <link>http://localhost:1313/leetcode/662/</link>
      <pubDate>Sun, 27 Feb 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/662/</guid>
      <description>Maximum Width of Binary Tree - LeetCode&#xA;Given the root of a binary tree, return the maximum width of the given tree. The maximum width of a tree is the maximum width among all levels. The width of one level is defined as the length between the end-nodes (the leftmost and rightmost non-null nodes), where the null nodes between the end-nodes are also counted into the length calculation. It is guaranteed that the answer will in the range of 32-bit signed integer.</description>
    </item>
    <item>
      <title>847. Shortest Path Visiting All Nodes</title>
      <link>http://localhost:1313/leetcode/847/</link>
      <pubDate>Sat, 26 Feb 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/847/</guid>
      <description>Shortest Path Visiting All Nodes - LeetCode&#xA;You have an undirected, connected graph of n nodes labeled from 0 to n - 1. You are given an array graph where graph[i] is a list of all the nodes connected with node i by an edge. Return the length of the shortest path that visits every node. You may start and stop at any node, you may revisit nodes multiple times, and you may reuse edges.</description>
    </item>
    <item>
      <title>39. Combination sum</title>
      <link>http://localhost:1313/leetcode/39/</link>
      <pubDate>Thu, 17 Feb 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/39/</guid>
      <description>Combination Sum - LeetCode&#xA;Given an array of distinct integers candidates and a target integer target, return a list of all unique combinations of candidates where the chosen numbers sum to target. You may return the combinations in any order. The same number may be chosen from candidates an unlimited number of times. Two combinations are unique if the frequency of at least one of the chosen numbers is different. It is guaranteed that the number of unique combinations that sum up to target is less than 150 combinations for the given input.</description>
    </item>
    <item>
      <title>322.  Coin Change</title>
      <link>http://localhost:1313/leetcode/322/</link>
      <pubDate>Fri, 28 Jan 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/322/</guid>
      <description>Coin Change - LeetCode&#xA;You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money. Return the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1. You may assume that you have an infinite number of each kind of coin.</description>
    </item>
    <item>
      <title>1345. Jump Game IV</title>
      <link>http://localhost:1313/leetcode/1345/</link>
      <pubDate>Sat, 15 Jan 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/1345/</guid>
      <description>Jump Game IV - LeetCode&#xA;Given an array of integers arr, you are initially positioned at the first index of the array. In one step you can jump from index i to index:&#xA;i + 1 where: i + 1 &amp;lt; arr.length. i - 1 where: i - 1 &amp;gt;= 0. j where: arr[i] == arr[j] and i != j.Return the minimum number of steps to reach the last index of the array.</description>
    </item>
    <item>
      <title>934. Shortest Bridge</title>
      <link>http://localhost:1313/leetcode/934/</link>
      <pubDate>Fri, 14 Jan 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/934/</guid>
      <description>Shortest Bridge - LeetCode&#xA;You are given an n x n binary matrix grid where 1 represents land and 0 represents water. An island is a 4-directionally connected group of 1&amp;rsquo;s not connected to any other 1&amp;rsquo;s. There are exactly two islands in grid. You may change 0&amp;rsquo;s to 1&amp;rsquo;s to connect the two islands to form one island. Return the smallest number of 0&amp;rsquo;s you must flip to connect the two islands.</description>
    </item>
    <item>
      <title>1136. Parallel Courses </title>
      <link>http://localhost:1313/leetcode/1136/</link>
      <pubDate>Sun, 26 Dec 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/1136/</guid>
      <description>Parallel Courses - LeetCode&#xA;You are given an integer n, which indicates that there are n courses labeled from 1 to n. You are also given an array relations where relations[i] = [prevCoursei, nextCoursei], representing a prerequisite relationship between course prevCoursei and course nextCoursei: course prevCoursei has to be taken before course nextCoursei. In one semester, you can take any number of courses as long as you have taken all the prerequisites in the previous semester for the courses you are taking.</description>
    </item>
    <item>
      <title>994. Rotting Oranges </title>
      <link>http://localhost:1313/leetcode/994/</link>
      <pubDate>Sun, 26 Dec 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/994/</guid>
      <description>Rotting Oranges - LeetCode&#xA;You are given an m x n grid where each cell can have one of three values:&#xA;0 representing an empty cell, 1 representing a fresh orange, or 2 representing a rotten orange.Every minute, any fresh orange that is 4-directionally adjacent to a rotten orange becomes rotten. Return the minimum number of minutes that must elapse until no cell has a fresh orange. If this is impossible, return -1.</description>
    </item>
    <item>
      <title>1091. Shortest Path in Binary Matrix </title>
      <link>http://localhost:1313/leetcode/1091/</link>
      <pubDate>Tue, 21 Dec 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/1091/</guid>
      <description>Shortest Path in Binary Matrix - LeetCode&#xA;Given an n x n binary matrix grid, return the length of the shortest clear path in the matrix. If there is no clear path, return -1. A clear path in a binary matrix is a path from the top-left cell (i.e., (0, 0)) to the bottom-right cell (i.e., (n - 1, n - 1)) such that:&#xA;All the visited cells of the path are 0.</description>
    </item>
    <item>
      <title>1306. Jump Game III</title>
      <link>http://localhost:1313/leetcode/1306/</link>
      <pubDate>Thu, 09 Dec 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/1306/</guid>
      <description>Given an array of non-negative integers arr, you are initially positioned at start index of the array. When you are at index i, you can jump to i + arr[i] or i - arr[i], check if you can reach to any index with value 0. Notice that you can not jump outside of the array at any time.&#xA;Example 1: Input: arr = [4,2,3,0,3,1,2], start = 5 Output: true Explanation: All possible ways to reach at index 3 with value 0 are: index 5 -&amp;gt; index 4 -&amp;gt; index 1 -&amp;gt; index 3 index 5 -&amp;gt; index 6 -&amp;gt; index 4 -&amp;gt; index 1 -&amp;gt; index 3</description>
    </item>
    <item>
      <title>286. Walls and Gates</title>
      <link>http://localhost:1313/leetcode/286/</link>
      <pubDate>Mon, 29 Nov 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/286/</guid>
      <description>You are given an m x n grid rooms initialized with these three possible values.&#xA;-1 A wall or an obstacle. 0 A gate. INF Infinity means an empty room. We use the value 231 - 1 = 2147483647 to represent INF as you may assume that the distance to a gate is less than 2147483647.Fill each empty room with the distance to __its nearest gate__. If it is impossible to reach a gate, it should be filled with INF.</description>
    </item>
    <item>
      <title>140. word break II</title>
      <link>http://localhost:1313/leetcode/140/</link>
      <pubDate>Sat, 23 Oct 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/140/</guid>
      <description>Given a string s and a dictionary of strings wordDict, add spaces in s to construct a sentence where each word is a valid dictionary word. Return all such possible sentences in any order.&#xA;Note that the same word in the dictionary may be reused multiple times in the segmentation.&#xA;Example 1: Input: s = &amp;ldquo;catsanddog&amp;rdquo;, wordDict = [&amp;ldquo;cat&amp;rdquo;,&amp;ldquo;cats&amp;rdquo;,&amp;ldquo;and&amp;rdquo;,&amp;ldquo;sand&amp;rdquo;,&amp;ldquo;dog&amp;rdquo;] Output: [&amp;ldquo;cats and dog&amp;rdquo;,&amp;ldquo;cat sand dog&amp;rdquo;]&#xA;code dp tabluation class Solution: def wordBreak(self, s: str, wordDict: List[str]) -&amp;gt; List[str]: ansList = [[[None]]] * (len(s) + 1) # [[[None]], [[None]], [[None]].</description>
    </item>
    <item>
      <title>leetcode questions: BFS</title>
      <link>http://localhost:1313/dev/lee-bfs/</link>
      <pubDate>Mon, 11 Oct 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/dev/lee-bfs/</guid>
      <description>BFS Template /** * Return the length of the shortest path between root and target node. */ int BFS(Node root, Node target) { Queue&amp;lt;Node&amp;gt; queue; // store all nodes which are waiting to be processed Set&amp;lt;Node&amp;gt; visited; // store all the nodes that we&amp;#39;ve visited int step = 0; // number of steps neeeded from root to current node // initialize add root to queue; add root to visited; // BFS while (queue is not empty) { step = step + 1; // iterate the nodes which are already in the queue int size = queue.</description>
    </item>
    <item>
      <title>542. 01-matrix</title>
      <link>http://localhost:1313/leetcode/542/</link>
      <pubDate>Mon, 07 Jun 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/542/</guid>
      <description>Given an m x n binary matrix mat, return the distance of the nearest 0 for each cell. The distance between two adjacent cells is 1.&#xA;Example 1:&#xA;Input: mat = [[0,0,0],[0,1,0],[0,0,0]] Output: [[0,0,0],[0,1,0],[0,0,0]]&#xA;code class Solution: def updateMatrix(self, matrix): m, n = len(matrix), len(matrix and matrix[0]) for i in range(m): for j in range(n): if matrix[i][j] != 0: matrix[i][j] = float(&amp;#34;inf&amp;#34;) if i &amp;gt; 0 and matrix[i - 1][j] + 1 &amp;lt; matrix[i][j]: matrix[i][j] = matrix[i - 1][j] + 1 if j &amp;gt; 0 and matrix[i][j - 1] + 1 &amp;lt; matrix[i][j]: matrix[i][j] = matrix[i][j - 1] + 1 for i in range(m - 1, -1, -1): for j in range(n - 1, -1, -1): if matrix[i][j] !</description>
    </item>
    <item>
      <title>733. Flood fill</title>
      <link>http://localhost:1313/leetcode/733/</link>
      <pubDate>Fri, 04 Jun 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/733/</guid>
      <description>CompaniesAn image is represented by an m x n integer grid image where image[i][j] represents the pixel value of the image. You are also given three integers sr, sc, and newColor. You should perform a flood fill on the image starting from the pixel image[sr][sc]. To perform a flood fill, consider the starting pixel, plus any pixels connected 4-directionally to the starting pixel of the same color as the starting pixel, plus any pixels connected 4-directionally to those pixels (also with the same color), and so on.</description>
    </item>
    <item>
      <title>133. Clone graph</title>
      <link>http://localhost:1313/leetcode/133/</link>
      <pubDate>Tue, 01 Jun 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/133/</guid>
      <description>Clone Graph - LeetCode&#xA;Given a reference of a node in a connected undirected graph. Return a deep copy (clone) of the graph. Each node in the graph contains a value (int) and a list (List[Node]) of its neighbors. class Node { public int val; public List neighbors; }&#xA;Test case format: For simplicity, each node&amp;rsquo;s value is the same as the node&amp;rsquo;s index (1-indexed). For example, the first node with val == 1, the second node with val == 2, and so on.</description>
    </item>
    <item>
      <title>279. Perfect squares</title>
      <link>http://localhost:1313/leetcode/279/</link>
      <pubDate>Fri, 28 May 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/279/</guid>
      <description>Given an integer n, return the least number of perfect square numbers that sum to n. A perfect square is an integer that is the square of an integer; in other words, it is the product of some integer with itself. For example, 1, 4, 9, and 16 are perfect squares while 3 and 11 are not.&#xA;Example 1: Input: n = 12 Output: 3 Explanation: 12 = 4 + 4 + 4.</description>
    </item>
    <item>
      <title>752. open the lock</title>
      <link>http://localhost:1313/leetcode/752/</link>
      <pubDate>Thu, 27 May 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/752/</guid>
      <description>You have a lock in front of you with 4 circular wheels. Each wheel has 10 slots: &amp;lsquo;0&amp;rsquo;, &amp;lsquo;1&amp;rsquo;, &amp;lsquo;2&amp;rsquo;, &amp;lsquo;3&amp;rsquo;, &amp;lsquo;4&amp;rsquo;, &amp;lsquo;5&amp;rsquo;, &amp;lsquo;6&amp;rsquo;, &amp;lsquo;7&amp;rsquo;, &amp;lsquo;8&amp;rsquo;, &amp;lsquo;9&amp;rsquo;. The wheels can rotate freely and wrap around: for example we can turn &amp;lsquo;9&amp;rsquo; to be &amp;lsquo;0&amp;rsquo;, or &amp;lsquo;0&amp;rsquo; to be &amp;lsquo;9&amp;rsquo;. Each move consists of turning one wheel one slot. The lock initially starts at &amp;lsquo;0000&amp;rsquo;, a string representing the state of the 4 wheels.</description>
    </item>
  </channel>
</rss>
