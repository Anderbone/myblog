<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Stack on Jiyu</title>
    <link>http://localhost:1313/tags/stack/</link>
    <description>Recent content in Stack on Jiyu</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Mon, 23 May 2022 21:58:57 +0100</lastBuildDate>
    <atom:link href="http://localhost:1313/tags/stack/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>456. 132 Pattern</title>
      <link>http://localhost:1313/leetcode/456/</link>
      <pubDate>Mon, 23 May 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/456/</guid>
      <description>https://leetcode.com/problems/132-pattern/&#xA;Given an array of n integers nums, a 132 pattern is a subsequence of three integers nums[i], nums[j] and nums[k] such that i &amp;lt; j &amp;lt; k and nums[i] &amp;lt; nums[k] &amp;lt; nums[j]. Return true__ if there is a 132 pattern in nums, otherwise, return false.__&#xA;Example 1: Input: nums = [1,2,3,4] Output: false Explanation: There is no 132 pattern in the sequence. Example 2: Input: nums = [3,1,4,2] Output: true Explanation: There is a 132 pattern in the sequence: [1, 4, 2].</description>
    </item>
    <item>
      <title>484. Find Permutation</title>
      <link>http://localhost:1313/leetcode/484/</link>
      <pubDate>Sun, 01 May 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/484/</guid>
      <description>Find Permutation - LeetCode&#xA;A permutation perm of n integers of all the integers in the range [1, n] can be represented as a string s of length n - 1 where:&#xA;s[i] == &#39;I&#39; if perm[i] &amp;lt; perm[i + 1], and s[i] == &#39;D&#39; if perm[i] &amp;gt; perm[i + 1].Given a string s, reconstruct the lexicographically smallest permutation perm and return it. Example 1: Input: s = &amp;ldquo;I&amp;rdquo; Output: [1,2] Explanation: [1,2] is the only legal permutation that can represented by s, where the number 1 and 2 construct an increasing relationship.</description>
    </item>
    <item>
      <title>844. Backspace String Compare</title>
      <link>http://localhost:1313/leetcode/844/</link>
      <pubDate>Sun, 01 May 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/844/</guid>
      <description>Backspace String Compare - LeetCode&#xA;Given two strings s and t, return true if they are equal when both are typed into empty text editors. &amp;lsquo;#&amp;rsquo; means a backspace character. Note that after backspacing an empty text, the text will continue empty.&#xA;Example 1: Input: s = &amp;ldquo;ab#c&amp;rdquo;, t = &amp;ldquo;ad#c&amp;rdquo; Output: true Explanation: Both s and t become &amp;ldquo;ac&amp;rdquo;. Example 2: Input: s = &amp;ldquo;ab##&amp;rdquo;, t = &amp;ldquo;c#d#&amp;rdquo; Output: true Explanation: Both s and t become &amp;ldquo;&amp;rdquo;.</description>
    </item>
    <item>
      <title>682. Baseball Game</title>
      <link>http://localhost:1313/leetcode/682/</link>
      <pubDate>Sun, 10 Apr 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/682/</guid>
      <description>Baseball Game - LeetCode&#xA;You are keeping score for a baseball game with strange rules. The game consists of several rounds, where the scores of past rounds may affect future rounds&amp;rsquo; scores. At the beginning of the game, you start with an empty record. You are given a list of strings ops, where ops[i] is the ith operation you must apply to the record and is one of the following:</description>
    </item>
    <item>
      <title>1996. The Number of Weak Characters in the Game</title>
      <link>http://localhost:1313/leetcode/1996/</link>
      <pubDate>Tue, 29 Mar 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/1996/</guid>
      <description>The Number of Weak Characters in the Game - LeetCode&#xA;You are playing a game that contains multiple characters, and each of the characters has two main properties: attack and defense. You are given a 2D integer array properties where properties[i] = [attacki, defensei] represents the properties of the ith character in the game. A character is said to be weak if any other character has both attack and defense levels strictly greater than this character&amp;rsquo;s attack and defense levels.</description>
    </item>
    <item>
      <title>895. Maximum Frequency Stack</title>
      <link>http://localhost:1313/leetcode/895/</link>
      <pubDate>Sat, 19 Mar 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/895/</guid>
      <description>Maximum Frequency Stack - LeetCode&#xA;Design a stack-like data structure to push elements to the stack and pop the most frequent element from the stack. Implement the FreqStack class:&#xA;FreqStack() constructs an empty frequency stack. void push(int val) pushes an integer val onto the top of the stack. int pop() removes and returns the most frequent element in the stack. If there is a tie for the most frequent element, the element closest to the stack&#39;s top is removed and returned.</description>
    </item>
    <item>
      <title>316. Remove Duplicate Letters</title>
      <link>http://localhost:1313/leetcode/316/</link>
      <pubDate>Fri, 18 Mar 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/316/</guid>
      <description>Remove Duplicate Letters - LeetCode&#xA;Given a string s, remove duplicate letters so that every letter appears once and only once. You must make sure your result is the smallest in lexicographical order among all possible results.&#xA;Example 1: Input: s = &amp;ldquo;bcabc&amp;rdquo; Output: &amp;ldquo;abc&amp;rdquo; Example 2: Input: s = &amp;ldquo;cbacdcbc&amp;rdquo; Output: &amp;ldquo;acdb&amp;rdquo;&#xA;Constraints:&#xA;1 &amp;lt;= s.length &amp;lt;= 104 s consists of lowercase English letters. code class Solution: def removeDuplicateLetters(self, s: str) -&amp;gt; str: stack = [] seen = set() last_index = {c: i for i, c in enumerate(s)} for i, c in enumerate(s): if c not in seen: while stack and c &amp;lt; stack[-1] and i &amp;lt; last_index[stack[-1]]: seen.</description>
    </item>
    <item>
      <title>946. Validate Stack Sequences</title>
      <link>http://localhost:1313/leetcode/946/</link>
      <pubDate>Wed, 16 Mar 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/946/</guid>
      <description>Validate Stack Sequences - LeetCode&#xA;Given two integer arrays pushed and popped each with distinct values, return true__ if this could have been the result of a sequence of push and pop operations on an initially empty stack, or false otherwise.__&#xA;Example 1: Input: pushed = [1,2,3,4,5], popped = [4,5,3,2,1] Output: true Explanation: We might do the following sequence: push(1), push(2), push(3), push(4), pop() -&amp;gt; 4, push(5), pop() -&amp;gt; 5, pop() -&amp;gt; 3, pop() -&amp;gt; 2, pop() -&amp;gt; 1 Example 2: Input: pushed = [1,2,3,4,5], popped = [4,3,5,1,2] Output: false Explanation: 1 cannot be popped before 2.</description>
    </item>
    <item>
      <title>1249. Minimum Remove to Make Valid Parentheses</title>
      <link>http://localhost:1313/leetcode/1249/</link>
      <pubDate>Tue, 15 Mar 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/1249/</guid>
      <description>Minimum Remove to Make Valid Parentheses - LeetCode&#xA;Given a string s of &amp;lsquo;(&amp;rsquo; , &amp;lsquo;)&amp;rsquo; and lowercase English characters. Your task is to remove the minimum number of parentheses ( &amp;lsquo;(&amp;rsquo; or &amp;lsquo;)&amp;rsquo;, in any positions ) so that the resulting parentheses string is valid and return any valid string. Formally, a parentheses string is valid if and only if:&#xA;It is the empty string, contains only lowercase characters, or It can be written as AB (A concatenated with B), where A and B are valid strings, or It can be written as (A), where A is a valid string.</description>
    </item>
    <item>
      <title>71. Simplify Path</title>
      <link>http://localhost:1313/leetcode/71/</link>
      <pubDate>Tue, 15 Mar 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/71/</guid>
      <description>Simplify Path - LeetCode&#xA;Given a string path, which is an absolute path (starting with a slash &amp;lsquo;/&amp;rsquo;) to a file or directory in a Unix-style file system, convert it to the simplified canonical path. In a Unix-style file system, a period &amp;lsquo;.&amp;rsquo; refers to the current directory, a double period &amp;lsquo;..&amp;rsquo; refers to the directory up a level, and any multiple consecutive slashes (i.e. &amp;lsquo;//&amp;rsquo;) are treated as a single slash &amp;lsquo;/&amp;rsquo;.</description>
    </item>
    <item>
      <title>20. Valid Parentheses</title>
      <link>http://localhost:1313/leetcode/20-valid-parentheses/</link>
      <pubDate>Sun, 13 Mar 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/20-valid-parentheses/</guid>
      <description>Valid Parentheses - LeetCode&#xA;Given a string s containing just the characters &amp;lsquo;(&amp;rsquo;, &amp;lsquo;)&amp;rsquo;, &amp;lsquo;{&amp;rsquo;, &amp;lsquo;}&amp;rsquo;, &amp;lsquo;[&amp;rsquo; and &amp;lsquo;]&amp;rsquo;, determine if the input string is valid. An input string is valid if:&#xA;Open brackets must be closed by the same type of brackets. Open brackets must be closed in the correct order. Example 1: Input: s = &amp;ldquo;()&amp;rdquo; Output: true Example 2: Input: s = &amp;ldquo;()[]{}&amp;rdquo; Output: true Example 3: Input: s = &amp;ldquo;(]&amp;rdquo; Output: false</description>
    </item>
    <item>
      <title>856. Score of Parentheses</title>
      <link>http://localhost:1313/leetcode/856/</link>
      <pubDate>Sat, 26 Feb 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/856/</guid>
      <description>Score of Parentheses - LeetCode&#xA;Given a balanced parentheses string s, return the score of the string. The score of a balanced parentheses string is based on the following rule:&#xA;&amp;quot;()&amp;quot; has score 1. AB has score A + B, where A and B are balanced parentheses strings. (A) has score 2 * A, where A is a balanced parentheses string. Example 1: Input: s = &amp;ldquo;()&amp;rdquo; Output: 1 Example 2: Input: s = &amp;ldquo;(())&amp;rdquo; Output: 2 Example 3: Input: s = &amp;ldquo;()()&amp;rdquo; Output: 2</description>
    </item>
    <item>
      <title>402. Remove K Digits</title>
      <link>http://localhost:1313/leetcode/402/</link>
      <pubDate>Fri, 18 Feb 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/402/</guid>
      <description>Remove K Digits - LeetCode&#xA;Given string num representing a non-negative integer num, and an integer k, return the smallest possible integer after removing k digits from num.&#xA;Example 1: Input: num = &amp;ldquo;1432219&amp;rdquo;, k = 3 Output: &amp;ldquo;1219&amp;rdquo; Explanation: Remove the three digits 4, 3, and 2 to form the new number 1219 which is the smallest. Example 2: Input: num = &amp;ldquo;10200&amp;rdquo;, k = 1 Output: &amp;ldquo;200&amp;rdquo; Explanation: Remove the leading 1 and the number is 200.</description>
    </item>
    <item>
      <title>739. Daily temperatures</title>
      <link>http://localhost:1313/leetcode/739/</link>
      <pubDate>Fri, 18 Feb 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/739/</guid>
      <description>Daily Temperatures - LeetCode&#xA;Given a list of daily temperatures temperatures, return a list such that, for each day in the input, tells you how many days you would have to wait until a warmer temperature. If there is no future day for which this is possible, put 0 instead. For example, given the list of temperatures temperatures = [73, 74, 75, 71, 69, 72, 76, 73], your output should be [1, 1, 4, 2, 1, 1, 0, 0].</description>
    </item>
    <item>
      <title>225. Implement Stack using Queues</title>
      <link>http://localhost:1313/leetcode/225/</link>
      <pubDate>Tue, 15 Feb 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/225/</guid>
      <description>Implement Stack using Queues - LeetCode&#xA;Implement a last in first out (LIFO) stack using only two queues. The implemented stack should support all the functions of a normal queue (push, top, pop, and empty). Implement the MyStack class:&#xA;void push(int x) Pushes element x to the top of the stack. int pop() Removes the element on the top of the stack and returns it. int top() Returns the element on the top of the stack.</description>
    </item>
    <item>
      <title>232. Implement queue using stacks</title>
      <link>http://localhost:1313/leetcode/232/</link>
      <pubDate>Tue, 15 Feb 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/232/</guid>
      <description>Implement Queue using Stacks - LeetCode&#xA;Implement a first in first out (FIFO) queue using only two stacks. The implemented queue should support all the functions of a normal queue (push, peek, pop, and empty). Implement the MyQueue class:&#xA;void push(int x) Pushes element x to the back of the queue. int pop() Removes the element from the front of the queue and returns it. int peek() Returns the element at the front of the queue.</description>
    </item>
    <item>
      <title>84. Largest Rectangle in Histogram</title>
      <link>http://localhost:1313/leetcode/84/</link>
      <pubDate>Sat, 29 Jan 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/84/</guid>
      <description>Largest Rectangle in Histogram - LeetCode&#xA;Given an array of integers heights representing the histogram&amp;rsquo;s bar height where the width of each bar is 1, return the area of the largest rectangle in the histogram.&#xA;Example 1: Input: heights = [2,1,5,6,2,3] Output: 10 Explanation: The above is a histogram where width of each bar is 1. The largest rectangle is shown in the red area, which has an area = 10 units.</description>
    </item>
    <item>
      <title>227. Basic Calculator II</title>
      <link>http://localhost:1313/leetcode/227/</link>
      <pubDate>Sat, 25 Dec 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/227/</guid>
      <description>Basic Calculator II - LeetCode&#xA;Given a string s which represents an expression, evaluate this expression and return its value. The integer division should truncate toward zero. You may assume that the given expression is always valid. All intermediate results will be in the range of [-231, 231 - 1]. Note: You are not allowed to use any built-in function which evaluates strings as mathematical expressions, such as eval().&#xA;Example 1: Input: s = &amp;ldquo;3+2*2&amp;rdquo; Output: 7 Example 2: Input: s = &amp;quot; 3/2 &amp;quot; Output: 1 Example 3: Input: s = &amp;quot; 3+5 / 2 &amp;quot; Output: 5</description>
    </item>
    <item>
      <title>496. Next Greater Element I</title>
      <link>http://localhost:1313/leetcode/496/</link>
      <pubDate>Sun, 05 Dec 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/496/</guid>
      <description>The next greater element of some element x in an array is the first greater element that is to the right of x in the same array. You are given two distinct 0-indexed integer arrays nums1 and nums2, where nums1 is a subset of nums2. For each 0 &amp;lt;= i &amp;lt; nums1.length, find the index j such that nums1[i] == nums2[j] and determine the next greater element of nums2[j] in nums2.</description>
    </item>
    <item>
      <title>85.  Maximal Rectangle</title>
      <link>http://localhost:1313/leetcode/85/</link>
      <pubDate>Tue, 30 Nov 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/85/</guid>
      <description>Given a rows x cols binary matrix filled with 0&amp;rsquo;s and 1&amp;rsquo;s, find the largest rectangle containing only 1&amp;rsquo;s and return its area.&#xA;Example 1:&#xA;Input: matrix = [[&amp;ldquo;1&amp;rdquo;,&amp;ldquo;0&amp;rdquo;,&amp;ldquo;1&amp;rdquo;,&amp;ldquo;0&amp;rdquo;,&amp;ldquo;0&amp;rdquo;],[&amp;ldquo;1&amp;rdquo;,&amp;ldquo;0&amp;rdquo;,&amp;ldquo;1&amp;rdquo;,&amp;ldquo;1&amp;rdquo;,&amp;ldquo;1&amp;rdquo;],[&amp;ldquo;1&amp;rdquo;,&amp;ldquo;1&amp;rdquo;,&amp;ldquo;1&amp;rdquo;,&amp;ldquo;1&amp;rdquo;,&amp;ldquo;1&amp;rdquo;],[&amp;ldquo;1&amp;rdquo;,&amp;ldquo;0&amp;rdquo;,&amp;ldquo;0&amp;rdquo;,&amp;ldquo;1&amp;rdquo;,&amp;ldquo;0&amp;rdquo;]] Output: 6 Explanation: The maximal rectangle is shown in the above picture.&#xA;code class Solution: def maximalRectangle(self, matrix: List[List[str]]) -&amp;gt; int: if not matrix: return 0 def calRecHistogram(height): stack = [-1] maxArea = 0 for i in range(len(height)): while stack[-1] != -1 and height[i] &amp;lt;= height[stack[-1]]: curHeight = height[stack.</description>
    </item>
    <item>
      <title>841. Keys and rooms</title>
      <link>http://localhost:1313/leetcode/841/</link>
      <pubDate>Tue, 08 Jun 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/841/</guid>
      <description>There are N rooms and you start in room 0. Each room has a distinct number in 0, 1, 2, &amp;hellip;, N-1, and each room may have some keys to access the next room. Formally, each room i has a list of keys rooms[i], and each key rooms[i][j] is an integer in [0, 1, &amp;hellip;, N-1] where N = rooms.length. A key rooms[i][j] = v opens the room with number v.</description>
    </item>
    <item>
      <title>394. Decode string</title>
      <link>http://localhost:1313/leetcode/394/</link>
      <pubDate>Thu, 03 Jun 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/394/</guid>
      <description>Decode String - LeetCode Given an encoded string, return its decoded string. The encoding rule is: k[encoded_string], where the encoded_string inside the square brackets is being repeated exactly k times. Note that k is guaranteed to be a positive integer. You may assume that the input string is always valid; No extra white spaces, square brackets are well-formed, etc. Furthermore, you may assume that the original data does not contain any digits and that digits are only for those repeat numbers, k.</description>
    </item>
    <item>
      <title>150. Evaluate reverse polish notation</title>
      <link>http://localhost:1313/leetcode/150-evaluate-reverse/</link>
      <pubDate>Tue, 06 Apr 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/150-evaluate-reverse/</guid>
      <description>Evaluate the value of an arithmetic expression in Reverse Polish Notation. Valid operators are +, -, *, /. Each operand may be an integer or another expression. Note:&#xA;Division between two integers should truncate toward zero. The given RPN expression is always valid. That means the expression would always evaluate to a result and there won&amp;rsquo;t be any divide by zero operation.Example 1: Input: [&amp;ldquo;2&amp;rdquo;, &amp;ldquo;1&amp;rdquo;, &amp;ldquo;+&amp;rdquo;, &amp;ldquo;3&amp;rdquo;, &amp;ldquo;*&amp;rdquo;] Output: 9 Explanation: ((2 + 1) * 3) = 9</description>
    </item>
  </channel>
</rss>
