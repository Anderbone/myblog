<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Binarysearch on Jiyu</title>
    <link>http://localhost:1313/tags/binarysearch/</link>
    <description>Recent content in Binarysearch on Jiyu</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Tue, 28 Nov 2023 19:34:15 +0000</lastBuildDate>
    <atom:link href="http://localhost:1313/tags/binarysearch/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>274. H-Index</title>
      <link>http://localhost:1313/leetcode/274/</link>
      <pubDate>Tue, 28 Nov 2023 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/274/</guid>
      <description>https://leetcode.com/problems/h-index/description/&#xA;Given an array of integers citations where citations[i] is the number of citations a researcher received for their ith paper, return the researcher&amp;rsquo;s h-index. According to the definition of h-index on Wikipedia: The h-index is defined as the maximum value of h such that the given researcher has published at least h papers that have each been cited at least h times.&#xA;Example 1: Input: citations = [3,0,6,1,5] Output: 3 Explanation: [3,0,6,1,5] means the researcher has 5 papers in total and each of them had received 3, 0, 6, 1, 5 citations respectively.</description>
    </item>
    <item>
      <title>34. Find First and Last Position of Element in Sorted Array</title>
      <link>http://localhost:1313/leetcode/34/</link>
      <pubDate>Mon, 25 Jul 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/34/</guid>
      <description>https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/&#xA;Given an array of integers nums sorted in ascending order, find the starting and ending position of a given target value. Your algorithm&amp;rsquo;s runtime complexity must be in the order of O(log n). If the target is not found in the array, return [-1, -1]. Example 1: Input: nums = [5,7,7,8,8,10], target = 8 Output: [3,4]&#xA;code class Solution { public int[] searchRange(int[] nums, int target) { // find left int start = 0; int end = nums.</description>
    </item>
    <item>
      <title>leetcode questions: Binary Search</title>
      <link>http://localhost:1313/dev/lee-binary-search/</link>
      <pubDate>Sun, 10 Jul 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/dev/lee-binary-search/</guid>
      <description>bisect.bisect_left(a, x) https://dynalist.io/d/RWIGNj7DLlzkBed-3ZqhuBg_#z=cbr2Mkrig9KhE6Lxfwhm31IS O(logn) greater than or equal to the targeted value. If all elements are less than x, return len(a) l&amp;lt;=r or l &amp;lt; r ans1 if you discard mid for the next iteration (i.e. l = mid+1 or r = mid-1) then use while (l &amp;lt;= r). if you keep mid for the next iteration (i.e. l = mid or r = mid) then use while (l &amp;lt; r) ans2 if you are returning from inside the loop, use left &amp;lt;= right if you are reducing the search space, use left &amp;lt; right and finally return a[left] template 1 can be determined by accessing a single index in the array.</description>
    </item>
    <item>
      <title>354. Russian Doll Envelopes</title>
      <link>http://localhost:1313/leetcode/354/</link>
      <pubDate>Wed, 25 May 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/354/</guid>
      <description>https://leetcode.com/problems/russian-doll-envelopes/&#xA;You are given a 2D array of integers envelopes where envelopes[i] = [wi, hi] represents the width and the height of an envelope. One envelope can fit into another if and only if both the width and height of one envelope are greater than the other envelope&amp;rsquo;s width and height. Return the maximum number of envelopes you can Russian doll (i.e., put one inside the other). Note: You cannot rotate an envelope.</description>
    </item>
    <item>
      <title>1102. Path With Maximum Minimum Value</title>
      <link>http://localhost:1313/leetcode/1102/</link>
      <pubDate>Tue, 29 Mar 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/1102/</guid>
      <description>Path With Maximum Minimum Value - LeetCode&#xA;Given an m x n integer matrix grid, return __the maximum score of a path starting at (0, 0) and ending at __(m - 1, n - 1) moving in the 4 cardinal directions. The score of a path is the minimum value in that path.&#xA;For example, the score of the path 8 → 4 → 5 → 9 is 4. Example 1: Input: grid = [[5,4,5],[1,2,6],[7,4,6]] Output: 4 Explanation: The path with the maximum score is highlighted in yellow.</description>
    </item>
    <item>
      <title>153. Find minimum in rotated sorted array</title>
      <link>http://localhost:1313/leetcode/153/</link>
      <pubDate>Mon, 28 Mar 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/153/</guid>
      <description>Find Minimum in Rotated Sorted Array - LeetCode&#xA;Suppose an array of length n sorted in ascending order is rotated between 1 and n times. For example, the array nums = [0,1,2,4,5,6,7] might become:&#xA;[4,5,6,7,0,1,2] if it was rotated 4 times. [0,1,2,4,5,6,7] if it was rotated 7 times.Notice that **rotating** an array [a[0], a[1], a[2], ..., a[n-1]] 1 time results in the array [a[n-1], a[0], a[1], a[2], ..., a[n-2]]. Given the sorted rotated array nums of unique elements, return the minimum element of this array.</description>
    </item>
    <item>
      <title>33. Search in Rotated Sorted Array</title>
      <link>http://localhost:1313/leetcode/33-search-rotated-array/</link>
      <pubDate>Wed, 23 Mar 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/33-search-rotated-array/</guid>
      <description>Search in Rotated Sorted Array - LeetCode&#xA;Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand. (i.e., [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2]). You are given a target value to search. If found in the array return its index, otherwise return -1. You may assume no duplicate exists in the array. Your algorithm&amp;rsquo;s runtime complexity must be in the order of O(log n). Example 1: Input: nums = [4,5,6,7,0,1,2], target = 0 Output: 4</description>
    </item>
    <item>
      <title>410. Split Array Largest Sum</title>
      <link>http://localhost:1313/leetcode/410/</link>
      <pubDate>Tue, 22 Mar 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/410/</guid>
      <description>Split Array Largest Sum - LeetCode&#xA;Given an array nums which consists of non-negative integers and an integer m, you can split the array into m non-empty continuous subarrays. Write an algorithm to minimize the largest sum among these m subarrays.&#xA;Example 1: Input: nums = [7,2,5,10,8], m = 2 Output: 18 Explanation: There are four ways to split nums into two subarrays. The best way is to split it into [7,2,5] and [10,8], where the largest sum among the two subarrays is only 18.</description>
    </item>
    <item>
      <title>1064. Fixed Point </title>
      <link>http://localhost:1313/leetcode/1064/</link>
      <pubDate>Fri, 18 Feb 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/1064/</guid>
      <description>Fixed Point - LeetCode&#xA;Given an array of distinct integers arr, where arr is sorted in ascending order, return the smallest index i that satisfies arr[i] == i. If there is no such index, return -1.&#xA;Example 1: Input: arr = [-10,-5,0,3,7] Output: 3 Explanation: For the given array, arr[0] = -10, arr[1] = -5, arr[2] = 0, arr[3] = 3, thus the output is 3. Example 2: Input: arr = [0,2,5,8,17] Output: 0 Explanation: arr[0] = 0, thus the output is 0.</description>
    </item>
    <item>
      <title>875. Koko Eating Bananas </title>
      <link>http://localhost:1313/leetcode/875/</link>
      <pubDate>Thu, 20 Jan 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/875/</guid>
      <description>Koko Eating Bananas - LeetCode&#xA;Koko loves to eat bananas. There are n piles of bananas, the ith pile has piles[i] bananas. The guards have gone and will come back in h hours. Koko can decide her bananas-per-hour eating speed of k. Each hour, she chooses some pile of bananas and eats k bananas from that pile. If the pile has less than k bananas, she eats all of them instead and will not eat any more bananas during this hour.</description>
    </item>
    <item>
      <title>81. Search in Rotated Sorted Array II</title>
      <link>http://localhost:1313/leetcode/81/</link>
      <pubDate>Wed, 12 Jan 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/81/</guid>
      <description>Search in Rotated Sorted Array II - LeetCode&#xA;There is an integer array nums sorted in non-decreasing order (not necessarily with distinct values). Before being passed to your function, nums is rotated at an unknown pivot index k (0 &amp;lt;= k &amp;lt; nums.length) such that the resulting array is [nums[k], nums[k+1], &amp;hellip;, nums[n-1], nums[0], nums[1], &amp;hellip;, nums[k-1]] (0-indexed). For example, [0,1,2,4,4,4,5,6,6,7] might be rotated at pivot index 5 and become [4,5,6,6,7,0,1,2,4,4].</description>
    </item>
    <item>
      <title>1337. The K Weakest Rows in a Matrix</title>
      <link>http://localhost:1313/leetcode/1337/</link>
      <pubDate>Tue, 04 Jan 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/1337/</guid>
      <description>The K Weakest Rows in a Matrix - LeetCode&#xA;You are given an m x n binary matrix mat of 1&amp;rsquo;s (representing soldiers) and 0&amp;rsquo;s (representing civilians). The soldiers are positioned in front of the civilians. That is, all the 1&amp;rsquo;s will appear to the left of all the 0&amp;rsquo;s in each row. A row i is weaker than a row j if one of the following is true:&#xA;The number of soldiers in row i is less than the number of soldiers in row j.</description>
    </item>
    <item>
      <title>300. Longest Increasing Subsequence</title>
      <link>http://localhost:1313/leetcode/300/</link>
      <pubDate>Sun, 02 Jan 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/300/</guid>
      <description>Given an unsorted array of integers, find the length of longest increasing subsequence. A subsequence is a sequence that can be derived from an array by deleting some or no elements without changing the order of the remaining elements. For example, [3,6,2,7] is a subsequence of the array [0,3,1,6,2,2,7].&#xA;Example: Input: [10,9,2,5,3,7,101,18] Output: 4 Explanation: The longest increasing subsequence is [2,3,7,101], therefore the length is 4.&#xA;code dp class Solution: def lengthOfLIS(self, nums: List[int]) -&amp;gt; int: dp = [1] * len(nums) for i in range(1, len(nums)): for j in range(i): if nums[i] &amp;gt; nums[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp) code class Solution: def lengthOfLIS(self, nums: List[int]) -&amp;gt; int: sq = [nums[0]] for i in range(1, len(nums)): if nums[i] &amp;gt; sq[-1]: sq.</description>
    </item>
    <item>
      <title>1631. Path With Minimum Effort</title>
      <link>http://localhost:1313/leetcode/1631/</link>
      <pubDate>Thu, 30 Dec 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/1631/</guid>
      <description>Path With Minimum Effort - LeetCode&#xA;You are a hiker preparing for an upcoming hike. You are given heights, a 2D array of size rows x columns, where heights[row][col] represents the height of cell (row, col). You are situated in the top-left cell, (0, 0), and you hope to travel to the bottom-right cell, (rows-1, columns-1) (i.e., 0-indexed). You can move up, down, left, or right, and you wish to find a route that requires the minimum effort.</description>
    </item>
    <item>
      <title>973. K Closest Points to Origin </title>
      <link>http://localhost:1313/leetcode/973/</link>
      <pubDate>Sun, 26 Dec 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/973/</guid>
      <description>K Closest Points to Origin - LeetCode&#xA;Given an array of points where points[i] = [xi, yi] represents a point on the X-Y plane and an integer k, return the k closest points to the origin (0, 0). The distance between two points on the X-Y plane is the Euclidean distance (i.e., √(x1 - x2)2 + (y1 - y2)2). You may return the answer in any order. The answer is guaranteed to be unique (except for the order that it is in).</description>
    </item>
    <item>
      <title>878. Nth Magical Number</title>
      <link>http://localhost:1313/leetcode/878/</link>
      <pubDate>Sat, 11 Dec 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/878/</guid>
      <description>Nth Magical Number - LeetCode&#xA;A positive integer is magical if it is divisible by either a or b. Given the three integers n, a, and b, return the nth magical number. Since the answer may be very large, return it modulo 109 + 7.&#xA;Example 1: Input: n = 1, a = 2, b = 3 Output: 2 Example 2: Input: n = 4, a = 2, b = 3 Output: 6 Example 3: Input: n = 5, a = 2, b = 4 Output: 10 code class Solution: def nthMagicalNumber(self, n: int, a: int, b: int) -&amp;gt; int: L = a * b // gcd(a, b) # how many mag nums &amp;lt; x def magnums_belowx(x): return x // a + x // b - x // L l, r = 1, n * min(a, b) while l &amp;lt; r: mid = l + (r - l) // 2 if magnums_belowx(mid) &amp;lt; n: l = mid + 1 else: r = mid return l % (10 ** 9 + 7) code TLE class Solution: def nthMagicalNumber(self, n: int, a: int, b: int) -&amp;gt; int: if a &amp;gt; b: # let a be the small one a, b = b, a # 2, 3, 2+2, 2+2+2(3+3), 2+2+2+2, 3+3+3 # 1, 2, 3, 4, 5, 6 c = 10 ** 9 + 7 ans = lasta = a lasta = lasta + a lastb = b if a == b: lastb = lastb + b for i in range(2, n+1): if lasta &amp;lt; lastb: ans = lasta lasta = (lasta + a) % c elif lasta &amp;gt; lastb: ans = lastb lastb = (lastb + b) % c else: ans = lasta lasta = (lasta + a) % c lastb = (lastb + b) % c return ans </description>
    </item>
    <item>
      <title>719. Find K-th Smallest Pair Distance</title>
      <link>http://localhost:1313/leetcode/719/</link>
      <pubDate>Thu, 09 Dec 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/719/</guid>
      <description>The distance of a pair of integers a and b is defined as the absolute difference between a and b. Given an integer array nums and an integer k, return the kth smallest distance among all the pairs nums[i] and nums[j] where 0 &amp;lt;= i &amp;lt; j &amp;lt; nums.length.&#xA;Example 1: Input: nums = [1,3,1], k = 1 Output: 0 Explanation: Here are all the pairs: (1,3) -&amp;gt; 2 (1,1) -&amp;gt; 0 (3,1) -&amp;gt; 2 Then the 1st smallest distance pair is (1,1), and its distance is 0.</description>
    </item>
    <item>
      <title>367. Valid Perfect Square</title>
      <link>http://localhost:1313/leetcode/367/</link>
      <pubDate>Wed, 08 Dec 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/367/</guid>
      <description>Given a positive integer num, write a function which returns True if num is a perfect square else False. Follow up: Do not use any built-in library function such as sqrt.&#xA;Example 1: Input: num = 16 Output: true&#xA;code class Solution: def isPerfectSquare(self, num: int) -&amp;gt; bool: l, r = 1, num while l &amp;lt;= r: mid = l + (r-l) // 2 if mid * mid &amp;lt; num: l = mid + 1 elif mid * mid &amp;gt; num: r = mid - 1 else: return True return False </description>
    </item>
    <item>
      <title>744. Find Smallest Letter Greater Than Target</title>
      <link>http://localhost:1313/leetcode/744/</link>
      <pubDate>Wed, 08 Dec 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/744/</guid>
      <description>Given a characters array letters that is sorted in non-decreasing order and a character target, return __the smallest character in the array that is larger than __target. Note that the letters wrap around.&#xA;For example, if target == &#39;z&#39; and letters == [&#39;a&#39;, &#39;b&#39;], the answer is &#39;a&#39;. Example 1: Input: letters = [&amp;ldquo;c&amp;rdquo;,&amp;ldquo;f&amp;rdquo;,&amp;ldquo;j&amp;rdquo;], target = &amp;ldquo;a&amp;rdquo; Output: &amp;ldquo;c&amp;rdquo; Example 2: Input: letters = [&amp;ldquo;c&amp;rdquo;,&amp;ldquo;f&amp;rdquo;,&amp;ldquo;j&amp;rdquo;], target = &amp;ldquo;c&amp;rdquo; Output: &amp;ldquo;f&amp;rdquo;</description>
    </item>
    <item>
      <title>702. Search in a Sorted Array of Unknown Size</title>
      <link>http://localhost:1313/leetcode/702/</link>
      <pubDate>Tue, 07 Dec 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/702/</guid>
      <description>This is an interactive problem. You have a sorted array of unique elements and an unknown size. You do not have an access to the array but you can use the ArrayReader interface to access it. You can call ArrayReader.get(i) that:&#xA;returns the value at the ith index (0-indexed) of the secret array (i.e., secret[i]), or returns 231 - 1 if the i is out of the boundary of the array.</description>
    </item>
    <item>
      <title>154. Find Minimum in Rotated Sorted Array II</title>
      <link>http://localhost:1313/leetcode/154/</link>
      <pubDate>Mon, 06 Dec 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/154/</guid>
      <description>Suppose an array of length n sorted in ascending order is rotated between 1 and n times. For example, the array nums = [0,1,4,4,5,6,7] might become:&#xA;[4,5,6,7,0,1,4] if it was rotated 4 times. [0,1,4,4,5,6,7] if it was rotated 7 times.Notice that rotating an array [a[0], a[1], a[2], &amp;hellip;, a[n-1]] 1 time results in the array [a[n-1], a[0], a[1], a[2], &amp;hellip;, a[n-2]]. Given the sorted rotated array nums that may contain duplicates, return the minimum element of this array.</description>
    </item>
    <item>
      <title>4. Median of Two Sorted Arrays</title>
      <link>http://localhost:1313/leetcode/4/</link>
      <pubDate>Mon, 06 Dec 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/4/</guid>
      <description>Median of Two Sorted Arrays - LeetCode Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).&#xA;Example 1: Input: nums1 = [1,3], nums2 = [2] Output: 2.00000 Explanation: merged array = [1,2,3] and median is 2. Example 2: Input: nums1 = [1,2], nums2 = [3,4] Output: 2.50000 Explanation: merged array = [1,2,3,4] and median is (2 + 3) / 2 = 2.</description>
    </item>
    <item>
      <title>540. Single Element in a Sorted Array</title>
      <link>http://localhost:1313/leetcode/540/</link>
      <pubDate>Mon, 06 Dec 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/540/</guid>
      <description>Single Element in a Sorted Array - LeetCode You are given a sorted array consisting of only integers where every element appears exactly twice, except for one element which appears exactly once. Return the single element that appears only once. Your solution must run in O(log n) time and O(1) space.&#xA;Example 1: Input: nums = [1,1,2,3,3,4,4,8,8] Output: 2 Example 2: Input: nums = [3,3,7,7,10,11,11] Output: 10&#xA;code class Solution { public int singleNonDuplicate(int[] nums) { int begin = 0, end = nums.</description>
    </item>
    <item>
      <title>658. Find k closest elements</title>
      <link>http://localhost:1313/leetcode/658/</link>
      <pubDate>Mon, 30 Aug 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/658/</guid>
      <description>Given a sorted integer array arr, two integers k and x, return the k closest integers to x in the array. The result should also be sorted in ascending order. An integer a is closer to x than an integer b if:&#xA;|a - x| &amp;lt; |b - x|, or |a - x| == |b - x| and a &amp;lt; b Example 1: Input: arr = [1,2,3,4,5], k = 4, x = 3 Output: [1,2,3,4]</description>
    </item>
    <item>
      <title>374. Guess number higher or lower</title>
      <link>http://localhost:1313/leetcode/374/</link>
      <pubDate>Wed, 25 Aug 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/374/</guid>
      <description>We are playing the Guess Game. The game is as follows: I pick a number from 1 to n. You have to guess which number I picked. Every time you guess wrong, I will tell you whether the number I picked is higher or lower than your guess. You call a pre-defined API int guess(int num), which returns 3 possible results:&#xA;-1: The number I picked is lower than your guess (i.</description>
    </item>
    <item>
      <title>704. binary search</title>
      <link>http://localhost:1313/leetcode/704/</link>
      <pubDate>Tue, 24 Aug 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/704/</guid>
      <description>Given an array of integers nums which is sorted in ascending order, and an integer target, write a function to search target in nums. If target exists, then return its index. Otherwise, return -1. You must write an algorithm with O(log n) runtime complexity.&#xA;Example 1: Input: nums = [-1,0,3,5,9,12], target = 9 Output: 4 Explanation: 9 exists in nums and its index is 4&#xA;code class Solution: def search(self, nums: List[int], target: int) -&amp;gt; int: left, right = 0, len(nums)-1 while left &amp;lt;= right: mid = left + (right-left)//2 if nums[mid] == target: return mid elif target &amp;gt; nums[mid]: left = mid + 1 else: right = mid - 1 return -1 code class Solution: def search(self, nums: List[int], target: int) -&amp;gt; int: def binary_search(start, end): if start &amp;gt; end: return -1 mid = start + (end-start) // 2 if nums[mid] == target: return mid elif nums[mid] &amp;lt; target: return binary_search(mid+1, end) elif nums[mid] &amp;gt; target: return binary_search(start, mid-1) return binary_search(0, len(nums)-1) </description>
    </item>
    <item>
      <title>162. Find peak element</title>
      <link>http://localhost:1313/leetcode/162-find-peak-element/</link>
      <pubDate>Mon, 22 Mar 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/162-find-peak-element/</guid>
      <description>A peak element is an element that is greater than its neighbors. Given an input array nums, where nums[i] ≠ nums[i+1], find a peak element and return its index. The array may contain multiple peaks, in that case return the index to any one of the peaks is fine. You may imagine that nums[-1] = nums[n] = -∞. Example 1: Input: nums = [1,2,3,1]Output: 2 Explanation: 3 is a peak element and your function should return the index number 2.</description>
    </item>
  </channel>
</rss>
