<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Binarytree on Jiyu</title>
    <link>http://localhost:1313/tags/binarytree/</link>
    <description>Recent content in Binarytree on Jiyu</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Fri, 08 Dec 2023 19:44:47 +0000</lastBuildDate>
    <atom:link href="http://localhost:1313/tags/binarytree/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>606. Construct String from Binary Tree</title>
      <link>http://localhost:1313/leetcode/606/</link>
      <pubDate>Fri, 08 Dec 2023 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/606/</guid>
      <description>https://leetcode.com/problems/construct-string-from-binary-tree/description/&#xA;Given the root of a binary tree, construct a string consisting of parenthesis and integers from a binary tree with the preorder traversal way, and return it. Omit all the empty parenthesis pairs that do not affect the one-to-one mapping relationship between the string and the original binary tree.&#xA;Example 1: Input: root = [1,2,3,4] Output: &amp;ldquo;1(2(4))(3)&amp;rdquo; Explanation: Originally, it needs to be &amp;ldquo;1(2(4)())(3()())&amp;rdquo;, but you need to omit all the unnecessary empty parenthesis pairs.</description>
    </item>
    <item>
      <title>108. Convert Sorted Array to Binary Search Tree</title>
      <link>http://localhost:1313/leetcode/108/</link>
      <pubDate>Wed, 10 Aug 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/108/</guid>
      <description>https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/&#xA;Given an integer array nums where the elements are sorted in ascending order, convert it to a height-balanced binary search tree. A height-balanced binary tree is a binary tree in which the depth of the two subtrees of every node never differs by more than one.&#xA;Example 1: Input: nums = [-10,-3,0,5,9] Output: [0,-3,9,-10,null,5] Explanation: [0,-10,5,null,-3,null,9] is also accepted: Example 2: Input: nums = [1,3] Output: [3,1] Explanation: [1,null,3] and [3,1] are both height-balanced BSTs.</description>
    </item>
    <item>
      <title>1448. Count Good Nodes in Binary Tree</title>
      <link>http://localhost:1313/leetcode/1448/</link>
      <pubDate>Wed, 03 Aug 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/1448/</guid>
      <description>https://leetcode.com/problems/count-good-nodes-in-binary-tree/&#xA;Given a binary tree root, a node X in the tree is named good if in the path from root to X there are no nodes with a value greater than X. Return the number of good nodes in the binary tree.&#xA;Example 1: Input: root = [3,1,4,3,null,1,5] Output: 4 Explanation: Nodes in blue are good. Root Node (3) is always a good node. Node 4 -&amp;gt; (3,4) is the maximum value in the path starting from the root.</description>
    </item>
    <item>
      <title>114. Flatten Binary Tree to Linked List</title>
      <link>http://localhost:1313/leetcode/114/</link>
      <pubDate>Wed, 27 Jul 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/114/</guid>
      <description>https://leetcode.com/problems/flatten-binary-tree-to-linked-list/&#xA;Given the root of a binary tree, flatten the tree into a &amp;ldquo;linked list&amp;rdquo;:&#xA;The &amp;quot;linked list&amp;quot; should use the same TreeNode class where the right child pointer points to the next node in the list and the left child pointer is always null. The &amp;quot;linked list&amp;quot; should be in the same order as a [pre-order traversal](https://en.wikipedia.org/wiki/Tree_traversal#Pre-order,_NLR) of the binary tree. Example 1: Input: root = [1,2,5,3,4,null,6] Output: [1,null,2,null,3,null,4,null,5,null,6] Example 2: Input: root = [] Output: [] Example 3: Input: root = [0] Output: [0]</description>
    </item>
    <item>
      <title>236. lowest common ancestor of a binary tree</title>
      <link>http://localhost:1313/leetcode/236/</link>
      <pubDate>Tue, 26 Jul 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/236/</guid>
      <description>https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/&#xA;Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree. According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).”&#xA;Example 1: Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1 Output: 3 Explanation: The LCA of nodes 5 and 1 is 3.</description>
    </item>
    <item>
      <title>105. Construct Binary Tree from Preorder and Inorder Traversal</title>
      <link>http://localhost:1313/leetcode/105/</link>
      <pubDate>Thu, 14 Jul 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/105/</guid>
      <description>https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/&#xA;Given preorder and inorder traversal of a tree, construct the binary tree. Note: You may assume that duplicates do not exist in the tree. For example, given preorder = [3,9,20,15,7] inorder = [9,3,15,20,7] Return the following binary tree: 3 / 9 20 / 15 7&#xA;code class Solution { public TreeNode buildTree(int[] preorder, int[] inorder) { if (inorder.length == 0) return null; int rootVal = preorder[0]; TreeNode root = new TreeNode(rootVal); int rootIndexInInorder = 0; for (int i = 0; i &amp;lt; inorder.</description>
    </item>
    <item>
      <title>102. Binary tree level order traversal</title>
      <link>http://localhost:1313/leetcode/102/</link>
      <pubDate>Wed, 13 Jul 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/102/</guid>
      <description>https://leetcode.com/problems/binary-tree-level-order-traversal/&#xA;Given a binary tree, return the level order traversal of its nodes&amp;rsquo; values. (ie, from left to right, level by level). For example: Given binary tree [3,9,20,null,null,15,7],&#xA;3 / 9 20 / 15 7&#xA;return its level order traversal as:&#xA;[ [3], [9,20], [15,7] ]&#xA;code class Solution { public List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; levelOrder(TreeNode root) { List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; res = new ArrayList&amp;lt;&amp;gt;(); LinkedList&amp;lt;TreeNode&amp;gt; level = new LinkedList&amp;lt;&amp;gt;(); if (root != null) level.offer(root); while (!</description>
    </item>
    <item>
      <title>199. Binary Tree Right Side View</title>
      <link>http://localhost:1313/leetcode/199/</link>
      <pubDate>Mon, 11 Jul 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/199/</guid>
      <description>https://leetcode.com/problems/binary-tree-right-side-view/&#xA;Given the root of a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom.&#xA;Example 1: Input: root = [1,2,3,null,5,null,4] Output: [1,3,4] Example 2: Input: root = [1,null,3] Output: [1,3] Example 3: Input: root = [] Output: []&#xA;Constraints:&#xA;The number of nodes in the tree is in the range [0, 100]. -100 &amp;lt;= Node.</description>
    </item>
    <item>
      <title>968. Binary Tree Cameras</title>
      <link>http://localhost:1313/leetcode/968/</link>
      <pubDate>Fri, 17 Jun 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/968/</guid>
      <description>https://leetcode.com/problems/binary-tree-cameras/&#xA;You are given the root of a binary tree. We install cameras on the tree nodes where each camera at a node can monitor its parent, itself, and its immediate children. Return the minimum number of cameras needed to monitor all nodes of the tree.&#xA;Example 1: Input: root = [0,0,null,0,0] Output: 1 Explanation: One camera is enough to monitor all nodes if placed as shown. Example 2: Input: root = [0,0,null,0,null,0,null,null,0] Output: 2 Explanation: At least two cameras are needed to monitor all nodes of the tree.</description>
    </item>
    <item>
      <title>1379. Find a Corresponding Node of a Binary Tree in a Clone of That Tree</title>
      <link>http://localhost:1313/leetcode/1379/</link>
      <pubDate>Mon, 23 May 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/1379/</guid>
      <description>https://leetcode.com/problems/find-a-corresponding-node-of-a-binary-tree-in-a-clone-of-that-tree/&#xA;Given two binary trees original and cloned and given a reference to a node target in the original tree. The cloned tree is a copy of the original tree. Return a reference to the same node in the cloned tree. Note that you are not allowed to change any of the two trees or the target node and the answer must be a reference to a node in the cloned tree.</description>
    </item>
    <item>
      <title>1302. Deepest Leaves Sum</title>
      <link>http://localhost:1313/leetcode/1302/</link>
      <pubDate>Sun, 15 May 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/1302/</guid>
      <description>https://leetcode.com/problems/deepest-leaves-sum/&#xA;Given the root of a binary tree, return the sum of values of its deepest leaves. Example 1: Input: root = [1,2,3,4,5,null,6,7,null,null,null,null,8] Output: 15 Example 2: Input: root = [6,7,8,2,7,1,3,9,null,1,4,null,null,null,5] Output: 19&#xA;Constraints:&#xA;The number of nodes in the tree is in the range [1, 104]. 1 &amp;lt;= Node.val &amp;lt;= 100 code class Solution: def deepestLeavesSum(self, root: Optional[TreeNode]) -&amp;gt; int: level = [root] while level: nex = [i for node in level for i in (node.</description>
    </item>
    <item>
      <title>543. Diameter of Binary Tree</title>
      <link>http://localhost:1313/leetcode/543/</link>
      <pubDate>Wed, 16 Mar 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/543/</guid>
      <description>Diameter of Binary Tree - LeetCode&#xA;Given the root of a binary tree, return the length of the diameter of the tree. The diameter of a binary tree is the length of the longest path between any two nodes in a tree. This path may or may not pass through the root. The length of a path between two nodes is represented by the number of edges between them.&#xA;Example 1: Input: root = [1,2,3,4,5] Output: 3 Explanation: 3 is the length of the path [4,2,1,3] or [5,2,1,3].</description>
    </item>
    <item>
      <title>662. Maximum Width of Binary Tree</title>
      <link>http://localhost:1313/leetcode/662/</link>
      <pubDate>Sun, 27 Feb 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/662/</guid>
      <description>Maximum Width of Binary Tree - LeetCode&#xA;Given the root of a binary tree, return the maximum width of the given tree. The maximum width of a tree is the maximum width among all levels. The width of one level is defined as the length between the end-nodes (the leftmost and rightmost non-null nodes), where the null nodes between the end-nodes are also counted into the length calculation. It is guaranteed that the answer will in the range of 32-bit signed integer.</description>
    </item>
    <item>
      <title>104. Maximum Depth of Binary Tree</title>
      <link>http://localhost:1313/leetcode/104-maximum-depth-of-binary-tree/</link>
      <pubDate>Mon, 14 Feb 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/104-maximum-depth-of-binary-tree/</guid>
      <description>Maximum Depth of Binary Tree - LeetCode&#xA;Given the root of a binary tree, return its maximum depth. A binary tree&amp;rsquo;s maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.&#xA;Example 1: Input: root = [3,9,20,null,null,15,7] Output: 3 Example 2: Input: root = [1,null,2] Output: 2&#xA;Constraints:&#xA;The number of nodes in the tree is in the range [0, 104].</description>
    </item>
    <item>
      <title>1602. Find Nearest Right Node in Binary Tree</title>
      <link>http://localhost:1313/leetcode/1602/</link>
      <pubDate>Sat, 22 Jan 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/1602/</guid>
      <description>Find Nearest Right Node in Binary Tree - LeetCode&#xA;Given the root of a binary tree and a node u in the tree, return the nearest node on the same level that is to the right of u__, or return__ null __if __u is the rightmost node in its level.&#xA;Example 1: Input: root = [1,2,3,null,4,5,6], u = 4 Output: 5 Explanation: The nearest node on the same level to the right of node 4 is node 5.</description>
    </item>
    <item>
      <title>257. Binary Tree Paths</title>
      <link>http://localhost:1313/leetcode/257/</link>
      <pubDate>Thu, 13 Jan 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/257/</guid>
      <description>Binary Tree Paths - LeetCode&#xA;Given the root of a binary tree, return all root-to-leaf paths in any order. A leaf is a node with no children.&#xA;Example 1: Input: root = [1,2,3,null,5] Output: [&amp;ldquo;1-&amp;gt;2-&amp;gt;5&amp;rdquo;,&amp;ldquo;1-&amp;gt;3&amp;rdquo;]&#xA;Example 2: Input: root = [1] Output: [&amp;ldquo;1&amp;rdquo;]&#xA;Constraints:&#xA;The number of nodes in the tree is in the range [1, 100]. -100 &amp;lt;= Node.val &amp;lt;= 100 code class Solution: def binaryTreePaths(self, root: Optional[TreeNode]) -&amp;gt; List[str]: def dfs(node, path): if node: if not node.</description>
    </item>
    <item>
      <title>1022. Sum of Root To Leaf Binary Numbers </title>
      <link>http://localhost:1313/leetcode/1022/</link>
      <pubDate>Mon, 10 Jan 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/1022/</guid>
      <description>Sum of Root To Leaf Binary Numbers - LeetCode&#xA;You are given the root of a binary tree where each node has a value 0 or 1. Each root-to-leaf path represents a binary number starting with the most significant bit.&#xA;For example, if the path is 0 -&amp;gt; 1 -&amp;gt; 1 -&amp;gt; 0 -&amp;gt; 1, then this could represent 01101 in binary, which is 13.For all leaves in the tree, consider the numbers represented by the path from the root to that leaf.</description>
    </item>
    <item>
      <title>1026. Maximum Difference Between Node and Ancestor </title>
      <link>http://localhost:1313/leetcode/1026/</link>
      <pubDate>Fri, 31 Dec 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/1026/</guid>
      <description>Maximum Difference Between Node and Ancestor - LeetCode&#xA;Given the root of a binary tree, find the maximum value v for which there exist different nodes a and b where v = |a.val - b.val| and a is an ancestor of b. A node a is an ancestor of b if either: any child of a is equal to b or any child of a is an ancestor of b.</description>
    </item>
    <item>
      <title>116. Populating Next Right Pointers in Each Node</title>
      <link>http://localhost:1313/leetcode/116-populating-next-right-pointers/</link>
      <pubDate>Wed, 29 Dec 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/116-populating-next-right-pointers/</guid>
      <description>Populating Next Right Pointers in Each Node - LeetCode&#xA;You are given a perfect binary tree where all leaves are on the same level, and every parent has two children. The binary tree has the following definition: struct Node { int val; Node *left; Node *right; Node *next; } Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL.</description>
    </item>
    <item>
      <title>563. Binary Tree Tilt</title>
      <link>http://localhost:1313/leetcode/563/</link>
      <pubDate>Wed, 08 Dec 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/563/</guid>
      <description>Given the root of a binary tree, return the sum of every tree node&amp;rsquo;s tilt. The tilt of a tree node is the absolute difference between the sum of all left subtree node values and all right subtree nsode values. If a node does not have a left child, then the sum of the left subtree node values is treated as 0. The rule is similar if there the node does not have a right child.</description>
    </item>
    <item>
      <title>337. House Robber III</title>
      <link>http://localhost:1313/leetcode/337/</link>
      <pubDate>Sun, 05 Dec 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/337/</guid>
      <description>The thief has found himself a new place for his thievery again. There is only one entrance to this area, called root. Besides the root, each house has one and only one parent house. After a tour, the smart thief realized that all houses in this place form a binary tree. It will automatically contact the police if two directly-linked houses were broken into on the same night. Given the root of the binary tree, return the maximum amount of money the thief can rob without alerting the police.</description>
    </item>
    <item>
      <title>250. Count Univalue Subtrees</title>
      <link>http://localhost:1313/leetcode/250/</link>
      <pubDate>Thu, 25 Nov 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/250/</guid>
      <description>Given the root of a binary tree, return the number of uni-value subtrees. A uni-value subtree means all nodes of the subtree have the same value.&#xA;Example 1:&#xA;Input: root = [5,1,5,5,5,null,5] Output: 4 Example 2: Input: root = [] Output: 0&#xA;code class Solution: def countUnivalSubtrees(self, root): if root is None: return 0 self.count = 0 self.is_uni(root) return self.count def is_uni(self, node): # base case - if the node has no children this is a univalue subtree if node.</description>
    </item>
    <item>
      <title>637. Average of levels in binary tree</title>
      <link>http://localhost:1313/leetcode/637/</link>
      <pubDate>Fri, 08 Oct 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/637/</guid>
      <description>Given the root of a binary tree, return the average value of the nodes on each level in the form of an array. Answers within 10-5 of the actual answer will be accepted.&#xA;Example 1:&#xA;Input: root = [3,9,20,null,null,15,7] Output: [3.00000,14.50000,11.00000] Explanation: The average value of nodes on level 0 is 3, on level 1 is 14.5, and on level 2 is 11. Hence return [3, 14.5, 11].&#xA;code class Solution: def averageOfLevels(self, root: Optional[TreeNode]) -&amp;gt; List[float]: res = [] level = [root] while level: res.</description>
    </item>
    <item>
      <title>110. Balanced binary tree</title>
      <link>http://localhost:1313/leetcode/110/</link>
      <pubDate>Wed, 22 Sep 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/110/</guid>
      <description>Given a binary tree, determine if it is height-balanced. For this problem, a height-balanced binary tree is defined as: a binary tree in which the left and right subtrees of every node differ in height by no more than 1.&#xA;Example 1:&#xA;Input: root = [3,9,20,null,null,15,7]&#xA;code class Solution: def isBalanced(self, root: Optional[TreeNode]) -&amp;gt; bool: def helper(root, isBalanced = True): if not root: return (-1, True) # height, isBalanced left_height, left_balance = helper(root.</description>
    </item>
    <item>
      <title>652. Find duplicate subtrees</title>
      <link>http://localhost:1313/leetcode/652/</link>
      <pubDate>Fri, 10 Sep 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/652/</guid>
      <description>Given the root of a binary tree, return all duplicate subtrees. For each kind of duplicate subtrees, you only need to return the root node of any one of them. Two trees are duplicate if they have the same structure with the same node values.&#xA;Example 1:&#xA;Input: root = [1,2,3,4,null,2,4,null,null,4] Output: [[2,4],[4]]&#xA;code class Solution: # key the sub tree, value, value is count of this sub tree def findDuplicateSubtrees(self, root: TreeNode) -&amp;gt; List[TreeNode]: if root is None: return [] self.</description>
    </item>
  </channel>
</rss>
