<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Queue on Jiyu</title>
    <link>http://localhost:1313/tags/queue/</link>
    <description>Recent content in Queue on Jiyu</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Tue, 15 Feb 2022 21:49:32 +0000</lastBuildDate>
    <atom:link href="http://localhost:1313/tags/queue/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>225. Implement Stack using Queues</title>
      <link>http://localhost:1313/leetcode/225/</link>
      <pubDate>Tue, 15 Feb 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/225/</guid>
      <description>Implement Stack using Queues - LeetCode&#xA;Implement a last in first out (LIFO) stack using only two queues. The implemented stack should support all the functions of a normal queue (push, top, pop, and empty). Implement the MyStack class:&#xA;void push(int x) Pushes element x to the top of the stack. int pop() Removes the element on the top of the stack and returns it. int top() Returns the element on the top of the stack.</description>
    </item>
    <item>
      <title>232. Implement queue using stacks</title>
      <link>http://localhost:1313/leetcode/232/</link>
      <pubDate>Tue, 15 Feb 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/232/</guid>
      <description>Implement Queue using Stacks - LeetCode&#xA;Implement a first in first out (FIFO) queue using only two stacks. The implemented queue should support all the functions of a normal queue (push, peek, pop, and empty). Implement the MyQueue class:&#xA;void push(int x) Pushes element x to the back of the queue. int pop() Removes the element from the front of the queue and returns it. int peek() Returns the element at the front of the queue.</description>
    </item>
    <item>
      <title>346. Moving Average from Data Stream</title>
      <link>http://localhost:1313/leetcode/346/</link>
      <pubDate>Mon, 29 Nov 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/346/</guid>
      <description>Given a stream of integers and a window size, calculate the moving average of all integers in the sliding window. Implement the MovingAverage class:&#xA;MovingAverage(int size) Initializes the object with the size of the window size. double next(int val) Returns the moving average of the last size values of the stream.&#xA;Example 1: Input [&amp;ldquo;MovingAverage&amp;rdquo;, &amp;ldquo;next&amp;rdquo;, &amp;ldquo;next&amp;rdquo;, &amp;ldquo;next&amp;rdquo;, &amp;ldquo;next&amp;rdquo;] [[3], [1], [10], [3], [5]] Output [null, 1.0, 5.5, 4.66667, 6.0]</description>
    </item>
    <item>
      <title>542. 01-matrix</title>
      <link>http://localhost:1313/leetcode/542/</link>
      <pubDate>Mon, 07 Jun 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/542/</guid>
      <description>Given an m x n binary matrix mat, return the distance of the nearest 0 for each cell. The distance between two adjacent cells is 1.&#xA;Example 1:&#xA;Input: mat = [[0,0,0],[0,1,0],[0,0,0]] Output: [[0,0,0],[0,1,0],[0,0,0]]&#xA;code class Solution: def updateMatrix(self, matrix): m, n = len(matrix), len(matrix and matrix[0]) for i in range(m): for j in range(n): if matrix[i][j] != 0: matrix[i][j] = float(&amp;#34;inf&amp;#34;) if i &amp;gt; 0 and matrix[i - 1][j] + 1 &amp;lt; matrix[i][j]: matrix[i][j] = matrix[i - 1][j] + 1 if j &amp;gt; 0 and matrix[i][j - 1] + 1 &amp;lt; matrix[i][j]: matrix[i][j] = matrix[i][j - 1] + 1 for i in range(m - 1, -1, -1): for j in range(n - 1, -1, -1): if matrix[i][j] !</description>
    </item>
    <item>
      <title>733. Flood fill</title>
      <link>http://localhost:1313/leetcode/733/</link>
      <pubDate>Fri, 04 Jun 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/733/</guid>
      <description>CompaniesAn image is represented by an m x n integer grid image where image[i][j] represents the pixel value of the image. You are also given three integers sr, sc, and newColor. You should perform a flood fill on the image starting from the pixel image[sr][sc]. To perform a flood fill, consider the starting pixel, plus any pixels connected 4-directionally to the starting pixel of the same color as the starting pixel, plus any pixels connected 4-directionally to those pixels (also with the same color), and so on.</description>
    </item>
    <item>
      <title>752. open the lock</title>
      <link>http://localhost:1313/leetcode/752/</link>
      <pubDate>Thu, 27 May 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/752/</guid>
      <description>You have a lock in front of you with 4 circular wheels. Each wheel has 10 slots: &amp;lsquo;0&amp;rsquo;, &amp;lsquo;1&amp;rsquo;, &amp;lsquo;2&amp;rsquo;, &amp;lsquo;3&amp;rsquo;, &amp;lsquo;4&amp;rsquo;, &amp;lsquo;5&amp;rsquo;, &amp;lsquo;6&amp;rsquo;, &amp;lsquo;7&amp;rsquo;, &amp;lsquo;8&amp;rsquo;, &amp;lsquo;9&amp;rsquo;. The wheels can rotate freely and wrap around: for example we can turn &amp;lsquo;9&amp;rsquo; to be &amp;lsquo;0&amp;rsquo;, or &amp;lsquo;0&amp;rsquo; to be &amp;lsquo;9&amp;rsquo;. Each move consists of turning one wheel one slot. The lock initially starts at &amp;lsquo;0000&amp;rsquo;, a string representing the state of the 4 wheels.</description>
    </item>
    <item>
      <title>622. Design circular queue</title>
      <link>http://localhost:1313/leetcode/622/</link>
      <pubDate>Tue, 18 May 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/622/</guid>
      <description>Design your implementation of the circular queue. The circular queue is a linear data structure in which the operations are performed based on FIFO (First In First Out) principle and the last position is connected back to the first position to make a circle. It is also called &amp;ldquo;Ring Buffer&amp;rdquo;. One of the benefits of the circular queue is that we can make use of the spaces in front of the queue.</description>
    </item>
  </channel>
</rss>
