<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Jiyu</title>
    <link>http://localhost:1313/</link>
    <description>Recent content on Jiyu</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Fri, 08 Mar 2024 18:37:28 +0000</lastBuildDate>
    <atom:link href="http://localhost:1313/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>242. Vaild anagram</title>
      <link>http://localhost:1313/leetcode/242/</link>
      <pubDate>Fri, 08 Mar 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/242/</guid>
      <description>https://leetcode.com/problems/valid-anagram/&#xA;Given two strings s and t, return true if t is an anagram of s__, and__ false otherwise. An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.&#xA;Example 1: Input: s = &amp;ldquo;anagram&amp;rdquo;, t = &amp;ldquo;nagaram&amp;rdquo; Output: true Example 2: Input: s = &amp;ldquo;rat&amp;rdquo;, t = &amp;ldquo;car&amp;rdquo; Output: false&#xA;Constraints:&#xA;1 &amp;lt;= s.</description>
    </item>
    <item>
      <title>290. Word Pattern</title>
      <link>http://localhost:1313/leetcode/290/</link>
      <pubDate>Thu, 07 Mar 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/290/</guid>
      <description>Word Pattern - LeetCode&#xA;Given a pattern and a string s, find if s follows the same pattern. Here follow means a full match, such that there is a bijection between a letter in pattern and a non-empty word in s.&#xA;Example 1: Input: pattern = &amp;ldquo;abba&amp;rdquo;, s = &amp;ldquo;dog cat cat dog&amp;rdquo; Output: true&#xA;Example 2: Input: pattern = &amp;ldquo;abba&amp;rdquo;, s = &amp;ldquo;dog cat cat fish&amp;rdquo; Output: false&#xA;Example 3: Input: pattern = &amp;ldquo;aaaa&amp;rdquo;, s = &amp;ldquo;dog cat cat dog&amp;rdquo; Output: false</description>
    </item>
    <item>
      <title>205. Isomorphic strings</title>
      <link>http://localhost:1313/leetcode/205/</link>
      <pubDate>Wed, 06 Mar 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/205/</guid>
      <description>https://leetcode.com/problems/isomorphic-strings/&#xA;Given two strings s and t, determine if they are isomorphic. Two strings s and t are isomorphic if the characters in s can be replaced to get t. All occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character, but a character may map to itself.&#xA;Example 1: Input: s = &amp;ldquo;egg&amp;rdquo;, t = &amp;ldquo;add&amp;rdquo; Output: true Example 2: Input: s = &amp;ldquo;foo&amp;rdquo;, t = &amp;ldquo;bar&amp;rdquo; Output: false Example 3: Input: s = &amp;ldquo;paper&amp;rdquo;, t = &amp;ldquo;title&amp;rdquo; Output: true</description>
    </item>
    <item>
      <title>289. Game of Life</title>
      <link>http://localhost:1313/leetcode/289/</link>
      <pubDate>Mon, 04 Mar 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/289/</guid>
      <description>Game of Life - LeetCode&#xA;According to Wikipedia&amp;rsquo;s article: &amp;ldquo;The Game of Life, also known simply as Life, is a cellular automaton devised by the British mathematician John Horton Conway in 1970.&amp;rdquo; The board is made up of an m x n grid of cells, where each cell has an initial state: live (represented by a 1) or dead (represented by a 0). Each cell interacts with its eight neighbors (horizontal, vertical, diagonal) using the following four rules (taken from the above Wikipedia article):</description>
    </item>
    <item>
      <title>73. Set matrix zeroes</title>
      <link>http://localhost:1313/leetcode/73/</link>
      <pubDate>Fri, 01 Mar 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/73/</guid>
      <description>https://leetcode.com/problems/set-matrix-zeroes/&#xA;Given an m x n integer matrix matrix, if an element is 0, set its entire row and column to 0&amp;rsquo;s. You must do it in place.&#xA;Example 1: Input: matrix = [[1,1,1],[1,0,1],[1,1,1]] Output: [[1,0,1],[0,0,0],[1,0,1]] Example 2: Input: matrix = [[0,1,2,0],[3,4,5,2],[1,3,1,5]] Output: [[0,0,0,0],[0,4,5,0],[0,3,1,0]]&#xA;Constraints:&#xA;m == matrix.length n == matrix[0].length 1 &amp;lt;= m, n &amp;lt;= 200 -231 &amp;lt;= matrix[i][j] &amp;lt;= 231 - 1 Follow up:&#xA;A straightforward solution using O(mn) space is probably a bad idea.</description>
    </item>
    <item>
      <title>48. Rotate image</title>
      <link>http://localhost:1313/leetcode/48/</link>
      <pubDate>Wed, 28 Feb 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/48/</guid>
      <description>https://leetcode.com/problems/rotate-image/&#xA;You are given an n x n 2D matrix representing an image, rotate the image by 90 degrees (clockwise). You have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation.&#xA;Example 1: Input: matrix = [[1,2,3],[4,5,6],[7,8,9]] Output: [[7,4,1],[8,5,2],[9,6,3]] Example 2: Input: matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]] Output: [[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]&#xA;Constraints:&#xA;n == matrix.length == matrix[i].length 1 &amp;lt;= n &amp;lt;= 20 -1000 &amp;lt;= matrix[i][j] &amp;lt;= 1000 code class Solution { public void rotate(int[][] matrix) { int n = matrix.</description>
    </item>
    <item>
      <title>54. Spiral matrix</title>
      <link>http://localhost:1313/leetcode/54/</link>
      <pubDate>Tue, 27 Feb 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/54/</guid>
      <description>https://leetcode.com/problems/spiral-matrix/&#xA;Given an m x n matrix, return all elements of the matrix in spiral order.&#xA;Example 1: Input: matrix = [[1,2,3],[4,5,6],[7,8,9]] Output: [1,2,3,6,9,8,7,4,5] Example 2: Input: matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]] Output: [1,2,3,4,8,12,11,10,9,5,6,7]&#xA;Constraints:&#xA;m == matrix.length n == matrix[i].length 1 &amp;lt;= m, n &amp;lt;= 10 -100 &amp;lt;= matrix[i][j] &amp;lt;= 100 code //[[1,2,3],[4,5,6],[7,8,9]] // 0,1 -&amp;gt; 1,0 -&amp;gt; 0,-1 -&amp;gt; -1,0 // right (x, y+1) down (x+1, y) left (x, y-1) up(x-1, y) class Solution { public List&amp;lt;Integer&amp;gt; spiralOrder(int[][] matrix) { List&amp;lt;Integer&amp;gt; res = new ArrayList&amp;lt;&amp;gt;(); int x = 0, y = 0; int width = matrix[0].</description>
    </item>
    <item>
      <title>36. Valid Sudoku</title>
      <link>http://localhost:1313/leetcode/36/</link>
      <pubDate>Thu, 08 Feb 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/36/</guid>
      <description>Determine if a 9 x 9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules:&#xA;Each row must contain the digits 1-9 without repetition. Each column must contain the digits 1-9 without repetition. Each of the nine 3 x 3 sub-boxes of the grid must contain the digits 1-9 without repetition.**Note:** A Sudoku board (partially filled) could be valid but is not necessarily solvable.</description>
    </item>
    <item>
      <title>76. Minimum Window Substring</title>
      <link>http://localhost:1313/leetcode/76/</link>
      <pubDate>Tue, 06 Feb 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/76/</guid>
      <description>Given two strings s and t of lengths m and n respectively, return the minimum window substring&#xA;__ of s such that every character in t (including duplicates) is included in the window__. If there is no such substring, return __the empty string __&amp;quot;&amp;quot;. The testcases will be generated such that the answer is unique.&#xA;Example 1: Input: s = &amp;ldquo;ADOBECODEBANC&amp;rdquo;, t = &amp;ldquo;ABC&amp;rdquo; Output: &amp;ldquo;BANC&amp;rdquo; Explanation: The minimum window substring &amp;ldquo;BANC&amp;rdquo; includes &amp;lsquo;A&amp;rsquo;, &amp;lsquo;B&amp;rsquo;, and &amp;lsquo;C&amp;rsquo; from string t.</description>
    </item>
    <item>
      <title>30. Substring with Concatenation of All Words</title>
      <link>http://localhost:1313/leetcode/30/</link>
      <pubDate>Mon, 29 Jan 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/30/</guid>
      <description>You are given a string s and an array of strings words. All the strings of words are of the same length. A concatenated substring in s is a substring that contains all the strings of any permutation of words concatenated.&#xA;For example, if words = [&amp;quot;ab&amp;quot;,&amp;quot;cd&amp;quot;,&amp;quot;ef&amp;quot;], then &amp;quot;abcdef&amp;quot;, &amp;quot;abefcd&amp;quot;, &amp;quot;cdabef&amp;quot;, &amp;quot;cdefab&amp;quot;, &amp;quot;efabcd&amp;quot;, and &amp;quot;efcdab&amp;quot; are all concatenated strings. &amp;quot;acdbef&amp;quot; is not a concatenated substring because it is not the concatenation of any permutation of words.</description>
    </item>
    <item>
      <title>3. Longest Substring Without Repeating Characters</title>
      <link>http://localhost:1313/leetcode/3/</link>
      <pubDate>Fri, 26 Jan 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/3/</guid>
      <description>Longest Substring Without Repeating Characters - LeetCode&#xA;Given a string s, find the length of the longest substring without repeating characters.&#xA;Example 1: Input: s = &amp;ldquo;abcabcbb&amp;rdquo; Output: 3 Explanation: The answer is &amp;ldquo;abc&amp;rdquo;, with the length of 3.&#xA;Example 2: Input: s = &amp;ldquo;bbbbb&amp;rdquo; Output: 1 Explanation: The answer is &amp;ldquo;b&amp;rdquo;, with the length of 1.&#xA;Example 3: Input: s = &amp;ldquo;pwwkew&amp;rdquo; Output: 3 Explanation: The answer is &amp;ldquo;wke&amp;rdquo;, with the length of 3.</description>
    </item>
    <item>
      <title>209. Minimum Size Subarray Sum</title>
      <link>http://localhost:1313/leetcode/209/</link>
      <pubDate>Thu, 25 Jan 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/209/</guid>
      <description>https://leetcode.com/problems/minimum-size-subarray-sum/description/&#xA;Given an array of positive integers nums and a positive integer target, return __the minimal length of a __ subarray&#xA;__ whose sum is greater than or equal to__ target. If there is no such subarray, return 0 instead.&#xA;Example 1: Input: target = 7, nums = [2,3,1,2,4,3] Output: 2 Explanation: The subarray [4,3] has the minimal length under the problem constraint. Example 2: Input: target = 4, nums = [1,4,4] Output: 1 Example 3: Input: target = 11, nums = [1,1,1,1,1,1,1,1] Output: 0</description>
    </item>
    <item>
      <title>15. 3Sum</title>
      <link>http://localhost:1313/leetcode/15/</link>
      <pubDate>Wed, 24 Jan 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/15/</guid>
      <description>https://leetcode.com/problems/3sum&#xA;Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0. Notice that the solution set must not contain duplicate triplets.&#xA;Example 1: Input: nums = [-1,0,1,2,-1,-4] Output: [[-1,-1,2],[-1,0,1]] Explanation: nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0. nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0.</description>
    </item>
    <item>
      <title>11. Container With Most Water</title>
      <link>http://localhost:1313/leetcode/11/</link>
      <pubDate>Tue, 23 Jan 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/11/</guid>
      <description>Container With Most Water - LeetCode&#xA;You are given an integer array height of length n. There are n vertical lines drawn such that the two endpoints of the ith line are (i, 0) and (i, height[i]). Find two lines that together with the x-axis form a container, such that the container contains the most water. Return the maximum amount of water a container can store. Notice that you may not slant the container.</description>
    </item>
    <item>
      <title>167. Two sum II</title>
      <link>http://localhost:1313/leetcode/167/</link>
      <pubDate>Mon, 22 Jan 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/167/</guid>
      <description>Given a 1-indexed array of integers numbers that is already sorted in non-decreasing order, find two numbers such that they add up to a specific target number. Let these two numbers be numbers[index1] and numbers[index2] where 1 &amp;lt;= index1 &amp;lt; index2 &amp;lt;= numbers.length. Return__ the indices of the two numbers, index1 and index2, added by one as an integer array [index1, index2] of length 2.__ The tests are generated such that there is exactly one solution.</description>
    </item>
    <item>
      <title>392. Is Subsequence</title>
      <link>http://localhost:1313/leetcode/392/</link>
      <pubDate>Fri, 19 Jan 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/392/</guid>
      <description>Is Subsequence - LeetCode&#xA;Given two strings s and t, return true__ if s is a subsequence of t, or false otherwise__. A subsequence of a string is a new string that is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (i.e., &amp;ldquo;ace&amp;rdquo; is a subsequence of &amp;ldquo;abcde&amp;rdquo; while &amp;ldquo;aec&amp;rdquo; is not).&#xA;Example 1: Input: s = &amp;ldquo;abc&amp;rdquo;, t = &amp;ldquo;ahbgdc&amp;rdquo; Output: true Example 2: Input: s = &amp;ldquo;axc&amp;rdquo;, t = &amp;ldquo;ahbgdc&amp;rdquo; Output: false</description>
    </item>
    <item>
      <title>125. Valid Palindrome</title>
      <link>http://localhost:1313/leetcode/125/</link>
      <pubDate>Thu, 18 Jan 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/125/</guid>
      <description>https://leetcode.com/problems/valid-palindrome/description/&#xA;A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. Alphanumeric characters include letters and numbers. Given a string s, return true__ if it is a palindrome, or false otherwise__.&#xA;Example 1: Input: s = &amp;ldquo;A man, a plan, a canal: Panama&amp;rdquo; Output: true Explanation: &amp;ldquo;amanaplanacanalpanama&amp;rdquo; is a palindrome. Example 2: Input: s = &amp;ldquo;race a car&amp;rdquo; Output: false Explanation: &amp;ldquo;raceacar&amp;rdquo; is not a palindrome.</description>
    </item>
    <item>
      <title>28. Find the Index of the First Occurrence in a String</title>
      <link>http://localhost:1313/leetcode/28/</link>
      <pubDate>Wed, 17 Jan 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/28/</guid>
      <description>https://leetcode.com/problems/find-the-index-of-the-first-occurrence-in-a-string/description&#xA;Given two strings needle and haystack, return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.&#xA;Example 1: Input: haystack = &amp;ldquo;sadbutsad&amp;rdquo;, needle = &amp;ldquo;sad&amp;rdquo; Output: 0 Explanation: &amp;ldquo;sad&amp;rdquo; occurs at index 0 and 6. The first occurrence is at index 0, so we return 0. Example 2: Input: haystack = &amp;ldquo;leetcode&amp;rdquo;, needle = &amp;ldquo;leeto&amp;rdquo; Output: -1 Explanation: &amp;ldquo;leeto&amp;rdquo; did not occur in &amp;ldquo;leetcode&amp;rdquo;, so we return -1.</description>
    </item>
    <item>
      <title>68. Text Justification</title>
      <link>http://localhost:1313/leetcode/68/</link>
      <pubDate>Wed, 17 Jan 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/68/</guid>
      <description>https://leetcode.com/problems/text-justification/description/&#xA;Given an array of strings words and a width maxWidth, format the text such that each line has exactly maxWidth characters and is fully (left and right) justified. You should pack your words in a greedy approach; that is, pack as many words as you can in each line. Pad extra spaces &amp;rsquo; &amp;rsquo; when necessary so that each line has exactly maxWidth characters. Extra spaces between words should be distributed as evenly as possible.</description>
    </item>
    <item>
      <title>6. Zigzag</title>
      <link>http://localhost:1313/leetcode/6/</link>
      <pubDate>Tue, 16 Jan 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/6/</guid>
      <description>The string &amp;ldquo;PAYPALISHIRING&amp;rdquo; is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility) P A H N A P L S I I G Y I R And then read line by line: &amp;ldquo;PAHNAPLSIIGYIR&amp;rdquo; Write the code that will take a string and make this conversion given a number of rows: string convert(string s, int numRows);</description>
    </item>
    <item>
      <title>14. Longest common prefix</title>
      <link>http://localhost:1313/leetcode/14/</link>
      <pubDate>Sat, 13 Jan 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/14/</guid>
      <description>https://leetcode.com/problems/longest-common-prefix/description/&#xA;Write a function to find the longest common prefix string amongst an array of strings. If there is no common prefix, return an empty string &amp;ldquo;&amp;rdquo;.&#xA;Example 1: Input: strs = [&amp;ldquo;flower&amp;rdquo;,&amp;ldquo;flow&amp;rdquo;,&amp;ldquo;flight&amp;rdquo;] Output: &amp;ldquo;fl&amp;rdquo; Example 2: Input: strs = [&amp;ldquo;dog&amp;rdquo;,&amp;ldquo;racecar&amp;rdquo;,&amp;ldquo;car&amp;rdquo;] Output: &amp;quot;&amp;quot; Explanation: There is no common prefix among the input strings.&#xA;Constraints:&#xA;1 &amp;lt;= strs.length &amp;lt;= 200 0 &amp;lt;= strs[i].length &amp;lt;= 200 strs[i] consists of only lowercase English letters code class Solution { public String longestCommonPrefix(String[] strs) { int prefixLen = strs[0].</description>
    </item>
    <item>
      <title>58. Length of last word</title>
      <link>http://localhost:1313/leetcode/58/</link>
      <pubDate>Sat, 13 Jan 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/58/</guid>
      <description>https://leetcode.com/problems/length-of-last-word/description/&#xA;Given a string s consisting of words and spaces, return the length of the last word in the string. A word is a maximal substring&#xA;consisting of non-space characters only.&#xA;Example 1: Input: s = &amp;ldquo;Hello World&amp;rdquo; Output: 5 Explanation: The last word is &amp;ldquo;World&amp;rdquo; with length 5. Example 2: Input: s = &amp;quot; fly me to the moon &amp;quot; Output: 4 Explanation: The last word is &amp;ldquo;moon&amp;rdquo; with length 4.</description>
    </item>
    <item>
      <title>12. Integer to Roman</title>
      <link>http://localhost:1313/leetcode/12/</link>
      <pubDate>Fri, 12 Jan 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/12/</guid>
      <description>https://leetcode.com/problems/integer-to-roman/&#xA;Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M. Symbol Value I 1 V 5 X 10 L 50 C 100 D 500 M 1000 For example, 2 is written as II in Roman numeral, just two one&amp;rsquo;s added together. 12 is written as XII, which is simply X + II. The number 27 is written as XXVII, which is XX + V + II.</description>
    </item>
    <item>
      <title>Spring Start here 11 - DB connection</title>
      <link>http://localhost:1313/dev/spring-jdbc/</link>
      <pubDate>Fri, 12 Jan 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/dev/spring-jdbc/</guid>
      <description>Here we show the 3 ways mentioned in chapter 11 of the book Spring Start Here. H2 in memory database, mysql database and mysql database with self defined data source.&#xA;H2 in memory connection pom.xml&#xA;&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;com.h2database&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;h2&amp;lt;/artifactId&amp;gt; &amp;lt;scope&amp;gt;runtime&amp;lt;/scope&amp;gt; &amp;lt;/dependency&amp;gt; Controller PurchaseController.java&#xA;package com.example.controllers; import com.example.model.Purchase; import com.example.repositories.PurchaseRepository; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.PostMapping; import org.springframework.web.bind.annotation.RequestBody; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; import java.util.List; @RestController @RequestMapping(&amp;#34;/purchase&amp;#34;) public class PurchaseController { private final PurchaseRepository purchaseRepository; public PurchaseController(PurchaseRepository purchaseRepository) { this.</description>
    </item>
    <item>
      <title>Use Pocket(read it later) on Koreader</title>
      <link>http://localhost:1313/dev/tool-koreader-pocket/</link>
      <pubDate>Fri, 12 Jan 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/dev/tool-koreader-pocket/</guid>
      <description>Recently I found a brilliant tool that can help people to use Pocket on Koreader.&#xA;forum page link&#xA;github link&#xA;I run it on my Synology NAS.&#xA;Then add link https://pingu:443/odps as the ODPS catalog URL on your koreader, change the link accordingly to follow your web portals, enjoy!</description>
    </item>
    <item>
      <title>13. Roman to integer</title>
      <link>http://localhost:1313/leetcode/13/</link>
      <pubDate>Thu, 11 Jan 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/13/</guid>
      <description>Roman to Integer - LeetCode&#xA;Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M. Symbol Value I 1 V 5 X 10 L 50 C 100 D 500 M 1000 For example, two is written as II in Roman numeral, just two one&amp;rsquo;s added together. Twelve is written as, XII, which is simply X + II. The number twenty seven is written as XXVII, which is XX + V + II.</description>
    </item>
    <item>
      <title>Spring Start here 11 - 3 ways to consume RestAPI</title>
      <link>http://localhost:1313/dev/spring-consume-rest/</link>
      <pubDate>Thu, 11 Jan 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/dev/spring-consume-rest/</guid>
      <description>We use 3 differnt ways to consume the payments service.&#xA;Payments service to be consumed by 3 different clients PaymentsController.java&#xA;package com.example.controllers; import com.example.model.Payment; import org.springframework.http.HttpStatus; import org.springframework.http.ResponseEntity; import org.springframework.web.bind.annotation.PostMapping; import org.springframework.web.bind.annotation.RequestBody; import org.springframework.web.bind.annotation.RequestHeader; import org.springframework.web.bind.annotation.RestController; import java.util.UUID; import java.util.logging.Logger; @RestController public class PaymentsController { private static Logger logger = Logger.getLogger(PaymentsController.class.getName()); @PostMapping(&amp;#34;/payment&amp;#34;) public ResponseEntity&amp;lt;Payment&amp;gt; createPayment( @RequestHeader String requestId, @RequestBody Payment payment ) { logger.info(&amp;#34;Received request with ID &amp;#34; + requestId + &amp;#34; ;Payment Amount: &amp;#34; + payment.</description>
    </item>
    <item>
      <title>42. Trapping Rain Water</title>
      <link>http://localhost:1313/leetcode/42/</link>
      <pubDate>Wed, 10 Jan 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/42/</guid>
      <description>Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining.&#xA;Example 1: Input: height = [0,1,0,2,1,0,1,3,2,1,2,1] Output: 6 Explanation: The above elevation map (black section) is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped. Example 2: Input: height = [4,2,0,3,2,5] Output: 9&#xA;Constraints:&#xA;n == height.length 1 &amp;lt;= n &amp;lt;= 2 * 104 0 &amp;lt;= height[i] &amp;lt;= 105 code class Solution { public int trap(int[] height) { int left = 0, right = height.</description>
    </item>
    <item>
      <title>135. Candy</title>
      <link>http://localhost:1313/leetcode/135/</link>
      <pubDate>Mon, 18 Dec 2023 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/135/</guid>
      <description>https://leetcode.com/problems/candy/&#xA;There are n children standing in a line. Each child is assigned a rating value given in the integer array ratings. You are giving candies to these children subjected to the following requirements:&#xA;Each child must have at least one candy. Children with a higher rating get more candies than their neighbors.Return __the minimum number of candies you need to have to distribute the candies to the children__. Example 1: Input: ratings = [1,0,2] Output: 5 Explanation: You can allocate to the first, second and third child with 2, 1, 2 candies respectively.</description>
    </item>
    <item>
      <title>134. Gas station</title>
      <link>http://localhost:1313/leetcode/134/</link>
      <pubDate>Thu, 14 Dec 2023 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/134/</guid>
      <description>Gas Station - LeetCode&#xA;There are n gas stations along a circular route, where the amount of gas at the ith station is gas[i]. You have a car with an unlimited gas tank and it costs cost[i] of gas to travel from the ith station to its next (i + 1)th station. You begin the journey with an empty tank at one of the gas stations. Given two integer arrays gas and cost, return the starting gas station&amp;rsquo;s index if you can travel around the circuit once in the clockwise direction, otherwise return -1.</description>
    </item>
    <item>
      <title>606. Construct String from Binary Tree</title>
      <link>http://localhost:1313/leetcode/606/</link>
      <pubDate>Fri, 08 Dec 2023 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/606/</guid>
      <description>https://leetcode.com/problems/construct-string-from-binary-tree/description/&#xA;Given the root of a binary tree, construct a string consisting of parenthesis and integers from a binary tree with the preorder traversal way, and return it. Omit all the empty parenthesis pairs that do not affect the one-to-one mapping relationship between the string and the original binary tree.&#xA;Example 1: Input: root = [1,2,3,4] Output: &amp;ldquo;1(2(4))(3)&amp;rdquo; Explanation: Originally, it needs to be &amp;ldquo;1(2(4)())(3()())&amp;rdquo;, but you need to omit all the unnecessary empty parenthesis pairs.</description>
    </item>
    <item>
      <title>1903. Largest Odd Number in String</title>
      <link>http://localhost:1313/leetcode/1903/</link>
      <pubDate>Thu, 07 Dec 2023 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/1903/</guid>
      <description>https://leetcode.com/problems/largest-odd-number-in-string/description/&#xA;You are given a string num, representing a large integer. Return the largest-valued odd integer (as a string) that is a non-empty substring of num, or an empty string &amp;quot;&amp;quot; if no odd integer exists. A substring is a contiguous sequence of characters within a string.&#xA;Example 1: Input: num = &amp;ldquo;52&amp;rdquo; Output: &amp;ldquo;5&amp;rdquo; Explanation: The only non-empty substrings are &amp;ldquo;5&amp;rdquo;, &amp;ldquo;2&amp;rdquo;, and &amp;ldquo;52&amp;rdquo;. &amp;ldquo;5&amp;rdquo; is the only odd number.</description>
    </item>
    <item>
      <title>1716. Calculate Money in Leetcode Bank</title>
      <link>http://localhost:1313/leetcode/1716/</link>
      <pubDate>Wed, 06 Dec 2023 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/1716/</guid>
      <description>https://leetcode.com/problems/calculate-money-in-leetcode-bank/description/&#xA;Hercy wants to save money for his first car. He puts money in the Leetcode bank every day. He starts by putting in $1 on Monday, the first day. Every day from Tuesday to Sunday, he will put in $1 more than the day before. On every subsequent Monday, he will put in $1 more than the previous Monday. Given n, return the total amount of money he will have in the Leetcode bank at the end of the nth day.</description>
    </item>
    <item>
      <title>238. Product of array except self</title>
      <link>http://localhost:1313/leetcode/238/</link>
      <pubDate>Fri, 01 Dec 2023 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/238/</guid>
      <description>https://leetcode.com/problems/product-of-array-except-self&#xA;Given an integer array nums, return an array answer such that answer[i] is equal to the product of all the elements of nums except nums[i]. The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer. You must write an algorithm that runs in O(n) time and without using the division operation.&#xA;Example 1: Input: nums = [1,2,3,4] Output: [24,12,8,6] Example 2: Input: nums = [-1,1,0,-3,3] Output: [0,0,9,0,0]</description>
    </item>
    <item>
      <title>380. Insert delete getRandom</title>
      <link>http://localhost:1313/leetcode/380/</link>
      <pubDate>Thu, 30 Nov 2023 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/380/</guid>
      <description>https://leetcode.com/problems/insert-delete-getrandom-o1/description/&#xA;Implement the RandomizedSet class:&#xA;RandomizedSet() Initializes the RandomizedSet object. bool insert(int val) Inserts an item val into the set if not present. Returns true if the item was not present, false otherwise. bool remove(int val) Removes an item val from the set if present. Returns true if the item was present, false otherwise. int getRandom() Returns a random element from the current set of elements (it&#39;s guaranteed that at least one element exists when this method is called).</description>
    </item>
    <item>
      <title>274. H-Index</title>
      <link>http://localhost:1313/leetcode/274/</link>
      <pubDate>Tue, 28 Nov 2023 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/274/</guid>
      <description>https://leetcode.com/problems/h-index/description/&#xA;Given an array of integers citations where citations[i] is the number of citations a researcher received for their ith paper, return the researcher&amp;rsquo;s h-index. According to the definition of h-index on Wikipedia: The h-index is defined as the maximum value of h such that the given researcher has published at least h papers that have each been cited at least h times.&#xA;Example 1: Input: citations = [3,0,6,1,5] Output: 3 Explanation: [3,0,6,1,5] means the researcher has 5 papers in total and each of them had received 3, 0, 6, 1, 5 citations respectively.</description>
    </item>
    <item>
      <title>45 Jump Game II</title>
      <link>http://localhost:1313/leetcode/45/</link>
      <pubDate>Fri, 24 Nov 2023 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/45/</guid>
      <description>https://leetcode.com/problems/jump-game-ii/description/&#xA;You are given a 0-indexed array of integers nums of length n. You are initially positioned at nums[0]. Each element nums[i] represents the maximum length of a forward jump from index i. In other words, if you are at nums[i], you can jump to any nums[i + j] where:&#xA;0 &amp;lt;= j &amp;lt;= nums[i] and i + j &amp;lt; nReturn __the minimum number of jumps to reach __nums[n - 1].</description>
    </item>
    <item>
      <title>55. Jump game</title>
      <link>http://localhost:1313/leetcode/55/</link>
      <pubDate>Wed, 22 Nov 2023 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/55/</guid>
      <description>https://leetcode.com/problems/jump-game/&#xA;Given an array of non-negative integers, you are initially positioned at the first index of the array. Each element in the array represents your maximum jump length at that position. Determine if you are able to reach the last index. Example 1: Input: [2,3,1,1,4] Output: true Explanation: Jump 1 step from index 0 to 1, then 3 steps to the last index. Example 2: Input: [3,2,1,0,4] Output: false Explanation: You will always arrive at index 3 no matter what.</description>
    </item>
    <item>
      <title>122. Best time to buy and sell stock II</title>
      <link>http://localhost:1313/leetcode/122/</link>
      <pubDate>Mon, 20 Nov 2023 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/122/</guid>
      <description>https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/description/&#xA;You are given an integer array prices where prices[i] is the price of a given stock on the ith day. On each day, you may decide to buy and/or sell the stock. You can only hold at most one share of the stock at any time. However, you can buy it then immediately sell it on the same day. Find and return the maximum profit you can achieve.&#xA;Example 1: Input: prices = [7,1,5,3,6,4] Output: 7 Explanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.</description>
    </item>
    <item>
      <title>121. Best time to buy and sell stock</title>
      <link>http://localhost:1313/leetcode/121/</link>
      <pubDate>Thu, 16 Nov 2023 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/121/</guid>
      <description>https://leetcode.com/problems/best-time-to-buy-and-sell-stock/&#xA;You are given an array prices where prices[i] is the price of a given stock on the ith day. You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock. Return the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0.&#xA;Example 1: Input: [7,1,5,3,6,4] Output: 5 Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.</description>
    </item>
    <item>
      <title>Most common design patterns in Java</title>
      <link>http://localhost:1313/dev/java-design-pattern/</link>
      <pubDate>Tue, 14 Nov 2023 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/dev/java-design-pattern/</guid>
      <description>Stragety The Strategy Pattern defines a family of algorithms, encapsulates each one, and makes them interchangeable. Strategy lets the algorithm vary independently from clients that use it.&#xA;Strategy is a behavioral design pattern that turns a set of behaviors into objects and makes them interchangeable inside original context object.&#xA;Has-A can be better than Is-A.&#xA;Java 8 brought the support of lambda functions, which can serve as simpler alternatives to the Strategy pattern.</description>
    </item>
    <item>
      <title>189. Rotate Array</title>
      <link>http://localhost:1313/leetcode/189/</link>
      <pubDate>Mon, 13 Nov 2023 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/189/</guid>
      <description>Given an array, rotate the array to the right by k steps, where k is non-negative.&#xA;Example 1:&#xA;Input: [1,2,3,4,5,6,7] and k = 3 Output: [5,6,7,1,2,3,4] Explanation: rotate 1 steps to the right: [7,1,2,3,4,5,6] rotate 2 steps to the right: [6,7,1,2,3,4,5] rotate 3 steps to the right: [5,6,7,1,2,3,4]&#xA;code class Solution { public void rotate(int[] nums, int k) { k %= nums.length; reverse(nums, 0, nums.length - 1); reverse(nums, 0, k - 1); reverse(nums, k, nums.</description>
    </item>
    <item>
      <title>169 Majority Element</title>
      <link>http://localhost:1313/leetcode/169/</link>
      <pubDate>Sat, 11 Nov 2023 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/169/</guid>
      <description>Majority Element - LeetCode&#xA;Given an array of size n, find the majority element. The majority element is the element that appears more than ⌊ n/2 ⌋ times. You may assume that the array is non-empty and the majority element always exist in the array. Example 1: Input: [3,2,3] Output: 3 code class Solution { public int majorityElement(int[] nums) { Map&amp;lt;Integer, Integer&amp;gt; m = new HashMap&amp;lt;&amp;gt;(); for (int n: nums){ m.</description>
    </item>
    <item>
      <title>80. Remove Duplicates from Sorted Array II</title>
      <link>http://localhost:1313/leetcode/80/</link>
      <pubDate>Thu, 09 Nov 2023 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/80/</guid>
      <description>Remove Duplicates from Sorted Array II - LeetCode&#xA;Given a sorted array nums, remove the duplicates in-place such that duplicates appeared at most twice and return the new length.&#xA;Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.&#xA;Example 1: Given nums = [1,1,1,2,2,3],&#xA;Your function should return length = 5, with the first five elements of nums being 1, 1, 2, 2 and 3 respectively.</description>
    </item>
    <item>
      <title>26. Remove duplicate from sorted array</title>
      <link>http://localhost:1313/leetcode/26/</link>
      <pubDate>Fri, 03 Nov 2023 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/26/</guid>
      <description>https://leetcode.com/problems/remove-duplicates-from-sorted-array/&#xA;Given a sorted array nums, remove the duplicates in-place such that each element appear only once and return the new length. Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.&#xA;Example 1: Given nums = [1,1,2], Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively. It doesn&amp;rsquo;t matter what you leave beyond the returned length.</description>
    </item>
    <item>
      <title>27. Remove elements</title>
      <link>http://localhost:1313/leetcode/27/</link>
      <pubDate>Thu, 02 Nov 2023 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/27/</guid>
      <description>Given an integer array nums and an integer val, remove all occurrences of val in nums in-place. The order of the elements may be changed. Then return __the number of elements in nums which are not equal to __val. Consider the number of elements in nums which are not equal to val be k, to get accepted, you need to do the following things:&#xA;Change the array nums such that the first k elements of nums contain the elements which are not equal to val.</description>
    </item>
    <item>
      <title>88. Merge Sorted Array</title>
      <link>http://localhost:1313/leetcode/88/</link>
      <pubDate>Tue, 31 Oct 2023 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/88/</guid>
      <description>https://leetcode.com/problems/merge-sorted-array/description/&#xA;You are given two integer arrays nums1 and nums2, sorted in non-decreasing order, and two integers m and n, representing the number of elements in nums1 and nums2 respectively. Merge nums1 and nums2 into a single array sorted in non-decreasing order. The final sorted array should not be returned by the function, but instead be __stored inside the array __nums1. To accommodate this, nums1 has a length of m + n, where the first m elements denote the elements that should be merged, and the last n elements are set to 0 and should be ignored.</description>
    </item>
    <item>
      <title>643. Maximum Average Subarray I</title>
      <link>http://localhost:1313/leetcode/643/</link>
      <pubDate>Thu, 07 Sep 2023 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/643/</guid>
      <description>You are given an integer array nums consisting of n elements, and an integer k.&#xA;Find a contiguous subarray whose length is equal to k that has the maximum average value and return this value. Any answer with a calculation error less than 10-5 will be accepted.&#xA;Example 1:&#xA;Input: nums = [1,12,-5,-6,50,3], k = 4 Output: 12.75000 Explanation: Maximum average is (12 - 5 - 6 + 50) / 4 = 51 / 4 = 12.</description>
    </item>
    <item>
      <title>The Chat with a Driver in Ras Al Khaimah</title>
      <link>http://localhost:1313/posts/share-uak/</link>
      <pubDate>Thu, 27 Jul 2023 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/share-uak/</guid>
      <description>A week of work in the United Arab Emirates (Uae) was a week of chatting with Soho, a Pakistani driver. RAK (Ras Al Khaimah) where I live is different from Dubai, it is just a remote coastal town. Once independent in history, it decided to join the UAE in 1972.&#xA;The street is a 40-degree heat wave and dusty, broken cars and luxury cars side by side, Many shops are open at night but there are few pedestrians.</description>
    </item>
    <item>
      <title>The deserts and stars in Ras Al Khaimah</title>
      <link>http://localhost:1313/posts/share-rak-desert/</link>
      <pubDate>Thu, 27 Jul 2023 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/share-rak-desert/</guid>
      <description>A boy and a girl who have never met Will get married next month in Pakistan I met that man in Ras Al Khaimah&#xA;When I replaced by we Even illness becomes wellness I heard it from a man in RAK&#xA;There are deserts everywhere in RAK There are some camels in RAK There are few birds in RAK&#xA;I was trying to find stars at night in the heat Alone with the sounds from a mosque on the streets I can&amp;rsquo;t see the stars But I know they are there Just like I knew you were here</description>
    </item>
    <item>
      <title>151. Reverse words in a string</title>
      <link>http://localhost:1313/leetcode/151/</link>
      <pubDate>Sun, 15 Jan 2023 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/151/</guid>
      <description>https://leetcode.com/problems/reverse-words-in-a-string&#xA;Given an input string s, reverse the order of the words. A word is defined as a sequence of non-space characters. The words in s will be separated by at least one space. Return a string of the words in reverse order concatenated by a single space. Note that s may contain leading or trailing spaces or multiple spaces between two words. The returned string should only have a single space separating the words.</description>
    </item>
    <item>
      <title>About Vegan, pain, guilt and life</title>
      <link>http://localhost:1313/posts/opinion-vegan/</link>
      <pubDate>Mon, 02 Jan 2023 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/opinion-vegan/</guid>
      <description>The whole modern conception of the world is founded on the illusion that the so-called laws of nature are the explanations of natural phenomena. Thus people today stop at the laws of nature, treating them as something inviolable, just as God and Fate were treated in past ages. And in fact both were right and both wrong; though the view of the ancients is clearer insofar as they have an acknowledged terminus, while the modern system tries to make it look as if everything were explained.</description>
    </item>
    <item>
      <title>Can you face leaving the world tomorrow</title>
      <link>http://localhost:1313/posts/abbie-face-tomorrow/</link>
      <pubDate>Mon, 02 Jan 2023 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/abbie-face-tomorrow/</guid>
      <description>Someone once asked me&#xA;Can you face leaving the world tomorrow&#xA;I say if God wants it&#xA;I know how to die&#xA;I will hug and praise it with all of my memories&#xA;Like a warrior who believes he must die&#xA;But the tears I thought could only be wiped away in heaven&#xA;The loneliness that I thought could only be comforted in heaven&#xA;been healed by a kiss from a girl</description>
    </item>
    <item>
      <title>The story of a Shenzhen worker in 2000</title>
      <link>http://localhost:1313/posts/share-made-in-shenzhen/</link>
      <pubDate>Fri, 18 Nov 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/share-made-in-shenzhen/</guid>
      <description>It&amp;rsquo;s from a Chinese podcast Story FM 故事FM, Episode 664, they invite people to tell their own real-life stories. I have been given permission for translation and publication here.&#xA;Shenzhen is one of the largest cities in China, and most made-in-China electronics come from Shenzhen.&#xA;Original page (WeChat) contains many pictures at that time, this is a translated version.&#xA;In 1998, I graduated from junior high school and wanted to go out to work, but my mother wouldn&amp;rsquo;t let me.</description>
    </item>
    <item>
      <title>139. word break</title>
      <link>http://localhost:1313/leetcode/139/</link>
      <pubDate>Sat, 22 Oct 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/139/</guid>
      <description>Word Break - LeetCode&#xA;Given a string s and a dictionary of strings wordDict, return true if s can be segmented into a space-separated sequence of one or more dictionary words. Note that the same word in the dictionary may be reused multiple times in the segmentation.&#xA;Example 1: Input: s = &amp;ldquo;leetcode&amp;rdquo;, wordDict = [&amp;ldquo;leet&amp;rdquo;,&amp;ldquo;code&amp;rdquo;] Output: true Explanation: Return true because &amp;ldquo;leetcode&amp;rdquo; can be segmented as &amp;ldquo;leet code&amp;rdquo;.&#xA;code bfs with string class Solution: def wordBreak(self, s: str, wordDict: List[str]) -&amp;gt; bool: q = deque(wordDict) seen = set(wordDict) while q: cur = q.</description>
    </item>
    <item>
      <title>Personality types don&#39;t exist,  life is not a matching game</title>
      <link>http://localhost:1313/posts/opinion-personality/</link>
      <pubDate>Tue, 20 Sep 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/opinion-personality/</guid>
      <description>God did not create people with a predetermined type of introversion, extroversion or ABCD, unlike someone who is born with a sweet tooth and someone who likes salty, people have the freedom to choose understanding-based behaviour. The so-called most introverted person also desires friends, and the so-called most extroverted person enjoys solitude at some point. Personality types do not exist or do not exist outside of language. Even though people may exhibit personalities and characteristics, it needs to be interpreted in the concrete real world, not determined by internal mechanisms hypothesized by artificial concepts.</description>
    </item>
    <item>
      <title>967. Numbers With Same Consecutive Differences</title>
      <link>http://localhost:1313/leetcode/967/</link>
      <pubDate>Sat, 03 Sep 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/967/</guid>
      <description>https://leetcode.com/problems/numbers-with-same-consecutive-differences/&#xA;Return all non-negative integers of length n such that the absolute difference between every two consecutive digits is k. Note that every number in the answer must not have leading zeros. For example, 01 has one leading zero and is invalid. You may return the answer in any order.&#xA;Example 1: Input: n = 3, k = 7 Output: [181,292,707,818,929] Explanation: Note that 070 is not a valid number, because it has leading zeroes.</description>
    </item>
    <item>
      <title>869. Reordered Power of 2</title>
      <link>http://localhost:1313/leetcode/869/</link>
      <pubDate>Fri, 26 Aug 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/869/</guid>
      <description>https://leetcode.com/problems/reordered-power-of-2/&#xA;You are given an integer n. We reorder the digits in any order (including the original order) such that the leading digit is not zero. Return true if and only if we can do this so that the resulting number is a power of two.&#xA;Example 1: Input: n = 1 Output: true Example 2: Input: n = 10 Output: false&#xA;Constraints:&#xA;1 &amp;lt;= n &amp;lt;= 109 code class Solution: def reorderedPowerOf2(self, n: int) -&amp;gt; bool: for i in itertools.</description>
    </item>
    <item>
      <title>383. ransom note</title>
      <link>http://localhost:1313/leetcode/383/</link>
      <pubDate>Thu, 25 Aug 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/383/</guid>
      <description>https://leetcode.com/problems/ransom-note/&#xA;Given an arbitrary ransom note string and another string containing letters from all the magazines, write a function that will return true if the ransom note can be constructed from the magazines ; otherwise, it will return false. Each letter in the magazine string can only be used once in your ransom note. Note: You may assume that both strings contain only lowercase letters. canConstruct(&amp;ldquo;a&amp;rdquo;, &amp;ldquo;b&amp;rdquo;) -&amp;gt; false canConstruct(&amp;ldquo;aa&amp;rdquo;, &amp;ldquo;ab&amp;rdquo;) -&amp;gt; false canConstruct(&amp;ldquo;aa&amp;rdquo;, &amp;ldquo;aab&amp;rdquo;) -&amp;gt; true</description>
    </item>
    <item>
      <title>Microservices with Spring Boot and Spring Cloud chap04 Docker</title>
      <link>http://localhost:1313/dev/spring-microservices-docker/</link>
      <pubDate>Thu, 25 Aug 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/dev/spring-microservices-docker/</guid>
      <description>Page 105 when running docker build, there&amp;rsquo;s an error: Docker: failed to export image: failed to create image: failed to get layer.&#xA;cd microservices/product-service docker build -t product-service . After adding &amp;lsquo;RUN true&amp;rsquo; between each COPY, problem solved.&#xA;FROM adoptopenjdk:16_36-jre-hotspot as builder WORKDIR extracted ADD ./build/libs/*.jar app.jar RUN java -Djarmode=layertools -jar app.jar extract FROM adoptopenjdk:16_36-jre-hotspot WORKDIR application COPY --from=builder extracted/dependencies/ ./ RUN true COPY --from=builder extracted/spring-boot-loader/ ./ RUN true COPY --from=builder extracted/snapshot-dependencies/ .</description>
    </item>
    <item>
      <title>1338. Reduce Array Size to The Half</title>
      <link>http://localhost:1313/leetcode/1338/</link>
      <pubDate>Thu, 18 Aug 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/1338/</guid>
      <description>https://leetcode.com/problems/reduce-array-size-to-the-half/&#xA;You are given an integer array arr. You can choose a set of integers and remove all the occurrences of these integers in the array. Return the minimum size of the set so that at least half of the integers of the array are removed.&#xA;Example 1: Input: arr = [3,3,3,3,5,5,5,2,2,7] Output: 2 Explanation: Choosing {3,7} will make the new array [5,5,5,2,2] which has size 5 (i.e equal to half of the size of the old array).</description>
    </item>
    <item>
      <title>804. Unique Morse Code Words</title>
      <link>http://localhost:1313/leetcode/804/</link>
      <pubDate>Wed, 17 Aug 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/804/</guid>
      <description>https://leetcode.com/problems/unique-morse-code-words/&#xA;International Morse Code defines a standard encoding where each letter is mapped to a series of dots and dashes, as follows:&#xA;&#39;a&#39; maps to &amp;quot;.-&amp;quot;, &#39;b&#39; maps to &amp;quot;-...&amp;quot;, &#39;c&#39; maps to &amp;quot;-.-.&amp;quot;, and so on.For convenience, the full table for the 26 letters of the English alphabet is given below: [&amp;quot;.-&amp;quot;,&amp;quot;-&amp;hellip;&amp;quot;,&amp;quot;-.-.&amp;quot;,&amp;quot;-..&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;..-.&amp;quot;,&amp;quot;&amp;ndash;.&amp;quot;,&amp;quot;&amp;hellip;.&amp;quot;,&amp;quot;..&amp;quot;,&amp;quot;.&amp;mdash;&amp;quot;,&amp;quot;-.-&amp;quot;,&amp;quot;.-..&amp;quot;,&amp;quot;&amp;ndash;&amp;quot;,&amp;quot;-.&amp;quot;,&amp;quot;&amp;mdash;&amp;quot;,&amp;quot;.&amp;ndash;.&amp;quot;,&amp;quot;&amp;ndash;.-&amp;quot;,&amp;quot;.-.&amp;quot;,&amp;quot;&amp;hellip;&amp;quot;,&amp;quot;-&amp;quot;,&amp;quot;..-&amp;quot;,&amp;quot;&amp;hellip;-&amp;quot;,&amp;quot;.&amp;ndash;&amp;quot;,&amp;quot;-..-&amp;quot;,&amp;quot;-.&amp;ndash;&amp;quot;,&amp;quot;&amp;ndash;..&amp;quot;] Given an array of strings words where each word can be written as a concatenation of the Morse code of each letter.</description>
    </item>
    <item>
      <title>387. first unique character in a string</title>
      <link>http://localhost:1313/leetcode/387/</link>
      <pubDate>Tue, 16 Aug 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/387/</guid>
      <description>https://leetcode.com/problems/first-unique-character-in-a-string/&#xA;Given a string s, find the first non-repeating character in it and return its index. If it does not exist, return -1.&#xA;Example 1: Input: s = &amp;ldquo;leetcode&amp;rdquo; Output: 0 Example 2: Input: s = &amp;ldquo;loveleetcode&amp;rdquo; Output: 2 Example 3: Input: s = &amp;ldquo;aabb&amp;rdquo; Output: -1&#xA;Constraints:&#xA;1 &amp;lt;= s.length &amp;lt;= 105 s consists of only lowercase English letters code class Solution { public int firstUniqChar(String s) { Map&amp;lt;Character, Integer&amp;gt; counter = new LinkedHashMap&amp;lt;&amp;gt;(); for (char c: s.</description>
    </item>
    <item>
      <title>235. Lowest common ancestor of a binary search tree</title>
      <link>http://localhost:1313/leetcode/235/</link>
      <pubDate>Fri, 12 Aug 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/235/</guid>
      <description>https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/&#xA;Given a binary search tree (BST), find the lowest common ancestor (LCA) of two given nodes in the BST. According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).”&#xA;Example 1: Input: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8 Output: 6 Explanation: The LCA of nodes 2 and 8 is 6.</description>
    </item>
    <item>
      <title>98. Validate Binary Search Tree</title>
      <link>http://localhost:1313/leetcode/98/</link>
      <pubDate>Thu, 11 Aug 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/98/</guid>
      <description>Validate Binary Search Tree - LeetCode&#xA;left &amp;lt; node &amp;lt; right is a valid binary search tree Input: [2,1,3] Output: true 2 / 1 3&#xA;code class Solution { public boolean isValidBST(TreeNode root) { return check(root, null, null); } private boolean check(TreeNode node, Integer low, Integer high){ if (node == null) return true; if ((low != null &amp;amp;&amp;amp; node.val &amp;lt;= low) || (high != null &amp;amp;&amp;amp; node.val &amp;gt;= high)) return false; return check(node.</description>
    </item>
    <item>
      <title>108. Convert Sorted Array to Binary Search Tree</title>
      <link>http://localhost:1313/leetcode/108/</link>
      <pubDate>Wed, 10 Aug 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/108/</guid>
      <description>https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/&#xA;Given an integer array nums where the elements are sorted in ascending order, convert it to a height-balanced binary search tree. A height-balanced binary tree is a binary tree in which the depth of the two subtrees of every node never differs by more than one.&#xA;Example 1: Input: nums = [-10,-3,0,5,9] Output: [0,-3,9,-10,null,5] Explanation: [0,-10,5,null,-3,null,9] is also accepted: Example 2: Input: nums = [1,3] Output: [3,1] Explanation: [1,null,3] and [3,1] are both height-balanced BSTs.</description>
    </item>
    <item>
      <title>823. Binary Trees With Factors</title>
      <link>http://localhost:1313/leetcode/823/</link>
      <pubDate>Tue, 09 Aug 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/823/</guid>
      <description>https://leetcode.com/problems/binary-trees-with-factors/&#xA;Given an array of unique integers, arr, where each integer arr[i] is strictly greater than 1. We make a binary tree using these integers, and each number may be used for any number of times. Each non-leaf node&amp;rsquo;s value should be equal to the product of the values of its children. Return the number of binary trees we can make. The answer may be too large so return the answer modulo 109 + 7.</description>
    </item>
    <item>
      <title>1220. Count Vowels Permutation</title>
      <link>http://localhost:1313/leetcode/1220/</link>
      <pubDate>Sun, 07 Aug 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/1220/</guid>
      <description>https://leetcode.com/problems/count-vowels-permutation/&#xA;Given an integer n, your task is to count how many strings of length n can be formed under the following rules:&#xA;Each character is a lower case vowel (&#39;a&#39;, &#39;e&#39;, &#39;i&#39;, &#39;o&#39;, &#39;u&#39;) Each vowel &#39;a&#39; may only be followed by an &#39;e&#39;. Each vowel &#39;e&#39; may only be followed by an &#39;a&#39; or an &#39;i&#39;. Each vowel &#39;i&#39; **may not** be followed by another &#39;i&#39;. Each vowel &#39;o&#39; may only be followed by an &#39;i&#39; or a &#39;u&#39;.</description>
    </item>
    <item>
      <title>1448. Count Good Nodes in Binary Tree</title>
      <link>http://localhost:1313/leetcode/1448/</link>
      <pubDate>Wed, 03 Aug 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/1448/</guid>
      <description>https://leetcode.com/problems/count-good-nodes-in-binary-tree/&#xA;Given a binary tree root, a node X in the tree is named good if in the path from root to X there are no nodes with a value greater than X. Return the number of good nodes in the binary tree.&#xA;Example 1: Input: root = [3,1,4,3,null,1,5] Output: 4 Explanation: Nodes in blue are good. Root Node (3) is always a good node. Node 4 -&amp;gt; (3,4) is the maximum value in the path starting from the root.</description>
    </item>
    <item>
      <title>729. My Calendar I</title>
      <link>http://localhost:1313/leetcode/729/</link>
      <pubDate>Wed, 03 Aug 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/729/</guid>
      <description>https://leetcode.com/problems/my-calendar-i/&#xA;You are implementing a program to use as your calendar. We can add a new event if adding the event will not cause a double booking. A double booking happens when two events have some non-empty intersection (i.e., some moment is common to both events.). The event can be represented as a pair of integers start and end that represents a booking on the half-open interval [start, end), the range of real numbers x such that start &amp;lt;= x &amp;lt; end.</description>
    </item>
    <item>
      <title>307. Range Sum Query - Mutable</title>
      <link>http://localhost:1313/leetcode/307/</link>
      <pubDate>Sun, 31 Jul 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/307/</guid>
      <description>https://leetcode.com/problems/range-sum-query-mutable/&#xA;Given an integer array nums, handle multiple queries of the following types:&#xA;**Update** the value of an element in nums. Calculate the **sum** of the elements of nums between indices left and right **inclusive** where left &amp;lt;= right.Implement the NumArray class: NumArray(int[] nums) Initializes the object with the integer array nums. void update(int index, int val) **Updates** the value of nums[index] to be val. int sumRange(int left, int right) Returns the **sum** of the elements of nums between indices left and right **inclusive** (i.</description>
    </item>
    <item>
      <title>Spring In Action 07 - RESTful API</title>
      <link>http://localhost:1313/dev/spring07-restful/</link>
      <pubDate>Sun, 31 Jul 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/dev/spring07-restful/</guid>
      <description>Based on Spring in action 6th version github repo.&#xA;RESTful controllers return a 404 status Here we can return Optional&amp;lt;Taco&amp;gt; directly, but it will return null if id doesn&amp;rsquo;t exist with status code 200. If we want to return a 404 status code appropriately, as shown here:&#xA;@GetMapping(&amp;#34;/{id}&amp;#34;) public ResponseEntity&amp;lt;Taco&amp;gt; tacoById(@PathVariable(&amp;#34;id&amp;#34;) Long id) { return tacoRepo.findById(id).map(taco -&amp;gt; new ResponseEntity&amp;lt;&amp;gt;(taco, HttpStatus.OK)) .orElseGet(() -&amp;gt; new ResponseEntity&amp;lt;&amp;gt;(null, HttpStatus.NOT_FOUND)); } IngredientController and rest client I added IngredientById here, it&amp;rsquo;s in the rest client test but not in the codebase.</description>
    </item>
    <item>
      <title>916. Word Subsets</title>
      <link>http://localhost:1313/leetcode/916/</link>
      <pubDate>Sat, 30 Jul 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/916/</guid>
      <description>https://leetcode.com/problems/word-subsets/&#xA;You are given two string arrays words1 and words2. A string b is a subset of string a if every letter in b occurs in a including multiplicity.&#xA;For example, &amp;quot;wrr&amp;quot; is a subset of &amp;quot;warrior&amp;quot; but is not a subset of &amp;quot;world&amp;quot;.A string a from words1 is **universal** if for every string b in words2, b is a subset of a. Return an array of all the universal strings in words1.</description>
    </item>
    <item>
      <title>890. Find and Replace Pattern</title>
      <link>http://localhost:1313/leetcode/890/</link>
      <pubDate>Fri, 29 Jul 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/890/</guid>
      <description>https://leetcode.com/problems/find-and-replace-pattern/&#xA;Given a list of strings words and a string pattern, return a list of words[i] that match pattern. You may return the answer in any order. A word matches the pattern if there exists a permutation of letters p so that after replacing every letter x in the pattern with p(x), we get the desired word. Recall that a permutation of letters is a bijection from letters to letters: every letter maps to another letter, and no two letters map to the same letter.</description>
    </item>
    <item>
      <title>114. Flatten Binary Tree to Linked List</title>
      <link>http://localhost:1313/leetcode/114/</link>
      <pubDate>Wed, 27 Jul 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/114/</guid>
      <description>https://leetcode.com/problems/flatten-binary-tree-to-linked-list/&#xA;Given the root of a binary tree, flatten the tree into a &amp;ldquo;linked list&amp;rdquo;:&#xA;The &amp;quot;linked list&amp;quot; should use the same TreeNode class where the right child pointer points to the next node in the list and the left child pointer is always null. The &amp;quot;linked list&amp;quot; should be in the same order as a [pre-order traversal](https://en.wikipedia.org/wiki/Tree_traversal#Pre-order,_NLR) of the binary tree. Example 1: Input: root = [1,2,5,3,4,null,6] Output: [1,null,2,null,3,null,4,null,5,null,6] Example 2: Input: root = [] Output: [] Example 3: Input: root = [0] Output: [0]</description>
    </item>
    <item>
      <title>236. lowest common ancestor of a binary tree</title>
      <link>http://localhost:1313/leetcode/236/</link>
      <pubDate>Tue, 26 Jul 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/236/</guid>
      <description>https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/&#xA;Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree. According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).”&#xA;Example 1: Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1 Output: 3 Explanation: The LCA of nodes 5 and 1 is 3.</description>
    </item>
    <item>
      <title>34. Find First and Last Position of Element in Sorted Array</title>
      <link>http://localhost:1313/leetcode/34/</link>
      <pubDate>Mon, 25 Jul 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/34/</guid>
      <description>https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/&#xA;Given an array of integers nums sorted in ascending order, find the starting and ending position of a given target value. Your algorithm&amp;rsquo;s runtime complexity must be in the order of O(log n). If the target is not found in the array, return [-1, -1]. Example 1: Input: nums = [5,7,7,8,8,10], target = 8 Output: [3,4]&#xA;code class Solution { public int[] searchRange(int[] nums, int target) { // find left int start = 0; int end = nums.</description>
    </item>
    <item>
      <title>315. Count of Smaller Numbers After Self</title>
      <link>http://localhost:1313/leetcode/315/</link>
      <pubDate>Sat, 23 Jul 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/315/</guid>
      <description>https://leetcode.com/problems/count-of-smaller-numbers-after-self/&#xA;You are given an integer array nums and you have to return a new counts array. The counts array has the property where counts[i] is the number of smaller elements to the right of nums[i].&#xA;Example 1: Input: nums = [5,2,6,1] Output: [2,1,1,0] Explanation: To the right of 5 there are 2 smaller elements (2 and 1). To the right of 2 there is only 1 smaller element (1). To the right of 6 there is 1 smaller element (1).</description>
    </item>
    <item>
      <title>86. Partition List</title>
      <link>http://localhost:1313/leetcode/86/</link>
      <pubDate>Fri, 22 Jul 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/86/</guid>
      <description>https://leetcode.com/problems/partition-list/&#xA;Given the head of a linked list and a value x, partition it such that all nodes less than x come before nodes greater than or equal to x. You should preserve the original relative order of the nodes in each of the two partitions.&#xA;Example 1: Input: head = [1,4,3,2,5,2], x = 3 Output: [1,2,2,4,3,5] Example 2: Input: head = [2,1], x = 2 Output: [1,2]&#xA;Constraints:&#xA;The number of nodes in the list is in the range [0, 200].</description>
    </item>
    <item>
      <title>92. Reverse Linked List II</title>
      <link>http://localhost:1313/leetcode/92/</link>
      <pubDate>Thu, 21 Jul 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/92/</guid>
      <description>https://leetcode.com/problems/reverse-linked-list-ii/&#xA;Given the head of a singly linked list and two integers left and right where left &amp;lt;= right, reverse the nodes of the list from position left to position right, and return the reversed list.&#xA;Example 1: Input: head = [1,2,3,4,5], left = 2, right = 4 Output: [1,4,3,2,5] Example 2: Input: head = [5], left = 1, right = 1 Output: [5]&#xA;Constraints:&#xA;The number of nodes in the list is n.</description>
    </item>
    <item>
      <title>792. Number of Matching Subsequences</title>
      <link>http://localhost:1313/leetcode/792/</link>
      <pubDate>Wed, 20 Jul 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/792/</guid>
      <description>https://leetcode.com/problems/number-of-matching-subsequences/&#xA;Given a string s and an array of strings words, return the number of words[i] that is a subsequence of s. A subsequence of a string is a new string generated from the original string with some characters (can be none) deleted without changing the relative order of the remaining characters.&#xA;For example, &amp;quot;ace&amp;quot; is a subsequence of &amp;quot;abcde&amp;quot;. Example 1: Input: s = &amp;ldquo;abcde&amp;rdquo;, words = [&amp;ldquo;a&amp;rdquo;,&amp;ldquo;bb&amp;rdquo;,&amp;ldquo;acd&amp;rdquo;,&amp;ldquo;ace&amp;rdquo;] Output: 3 Explanation: There are three strings in words that are a subsequence of s: &amp;ldquo;a&amp;rdquo;, &amp;ldquo;acd&amp;rdquo;, &amp;ldquo;ace&amp;rdquo;.</description>
    </item>
    <item>
      <title>118. Pascal triangle</title>
      <link>http://localhost:1313/leetcode/118/</link>
      <pubDate>Tue, 19 Jul 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/118/</guid>
      <description>https://leetcode.com/problems/pascals-triangle/&#xA;Given an integer numRows, return the first numRows of Pascal&amp;rsquo;s triangle. In Pascal&amp;rsquo;s triangle, each number is the sum of the two numbers directly above it as shown: Example 1: Input: numRows = 5 Output: [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]] Example 2: Input: numRows = 1 Output: [[1]]&#xA;Constraints:&#xA;1 &amp;lt;= numRows &amp;lt;= 30 code class Solution { public List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; generate(int numRows) { List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; res = new ArrayList&amp;lt;&amp;gt;(); res.add(Arrays.asList(1)); while (numRows &amp;gt; 1){ numRows--; List&amp;lt;Integer&amp;gt; last = res.</description>
    </item>
    <item>
      <title>576. Out of Boundary Paths</title>
      <link>http://localhost:1313/leetcode/576/</link>
      <pubDate>Sat, 16 Jul 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/576/</guid>
      <description>https://leetcode.com/problems/out-of-boundary-paths/&#xA;There is an m x n grid with a ball. The ball is initially at the position [startRow, startColumn]. You are allowed to move the ball to one of the four adjacent cells in the grid (possibly out of the grid crossing the grid boundary). You can apply at most maxMove moves to the ball. Given the five integers m, n, maxMove, startRow, startColumn, return the number of paths to move the ball out of the grid boundary.</description>
    </item>
    <item>
      <title>695. Max Area of Island</title>
      <link>http://localhost:1313/leetcode/695/</link>
      <pubDate>Fri, 15 Jul 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/695/</guid>
      <description>https://leetcode.com/problems/max-area-of-island/&#xA;You are given an m x n binary matrix grid. An island is a group of 1&amp;rsquo;s (representing land) connected 4-directionally (horizontal or vertical.) You may assume all four edges of the grid are surrounded by water. The area of an island is the number of cells with a value 1 in the island. Return __the maximum area of an island in __grid. If there is no island, return 0.</description>
    </item>
    <item>
      <title>105. Construct Binary Tree from Preorder and Inorder Traversal</title>
      <link>http://localhost:1313/leetcode/105/</link>
      <pubDate>Thu, 14 Jul 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/105/</guid>
      <description>https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/&#xA;Given preorder and inorder traversal of a tree, construct the binary tree. Note: You may assume that duplicates do not exist in the tree. For example, given preorder = [3,9,20,15,7] inorder = [9,3,15,20,7] Return the following binary tree: 3 / 9 20 / 15 7&#xA;code class Solution { public TreeNode buildTree(int[] preorder, int[] inorder) { if (inorder.length == 0) return null; int rootVal = preorder[0]; TreeNode root = new TreeNode(rootVal); int rootIndexInInorder = 0; for (int i = 0; i &amp;lt; inorder.</description>
    </item>
    <item>
      <title>102. Binary tree level order traversal</title>
      <link>http://localhost:1313/leetcode/102/</link>
      <pubDate>Wed, 13 Jul 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/102/</guid>
      <description>https://leetcode.com/problems/binary-tree-level-order-traversal/&#xA;Given a binary tree, return the level order traversal of its nodes&amp;rsquo; values. (ie, from left to right, level by level). For example: Given binary tree [3,9,20,null,null,15,7],&#xA;3 / 9 20 / 15 7&#xA;return its level order traversal as:&#xA;[ [3], [9,20], [15,7] ]&#xA;code class Solution { public List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; levelOrder(TreeNode root) { List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; res = new ArrayList&amp;lt;&amp;gt;(); LinkedList&amp;lt;TreeNode&amp;gt; level = new LinkedList&amp;lt;&amp;gt;(); if (root != null) level.offer(root); while (!</description>
    </item>
    <item>
      <title>473. Matchsticks to Square</title>
      <link>http://localhost:1313/leetcode/473/</link>
      <pubDate>Tue, 12 Jul 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/473/</guid>
      <description>https://leetcode.com/problems/matchsticks-to-square/&#xA;You are given an integer array matchsticks where matchsticks[i] is the length of the ith matchstick. You want to use all the matchsticks to make one square. You should not break any stick, but you can link them up, and each matchstick must be used exactly one time. Return true if you can make this square and false otherwise.&#xA;Example 1: Input: matchsticks = [1,1,2,2,2] Output: true Explanation: You can form a square with length 2, one side of the square came two sticks with length 1.</description>
    </item>
    <item>
      <title>199. Binary Tree Right Side View</title>
      <link>http://localhost:1313/leetcode/199/</link>
      <pubDate>Mon, 11 Jul 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/199/</guid>
      <description>https://leetcode.com/problems/binary-tree-right-side-view/&#xA;Given the root of a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom.&#xA;Example 1: Input: root = [1,2,3,null,5,null,4] Output: [1,3,4] Example 2: Input: root = [1,null,3] Output: [1,3] Example 3: Input: root = [] Output: []&#xA;Constraints:&#xA;The number of nodes in the tree is in the range [0, 100]. -100 &amp;lt;= Node.</description>
    </item>
    <item>
      <title>leetcode questions: Binary Search</title>
      <link>http://localhost:1313/dev/lee-binary-search/</link>
      <pubDate>Sun, 10 Jul 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/dev/lee-binary-search/</guid>
      <description>bisect.bisect_left(a, x) https://dynalist.io/d/RWIGNj7DLlzkBed-3ZqhuBg_#z=cbr2Mkrig9KhE6Lxfwhm31IS O(logn) greater than or equal to the targeted value. If all elements are less than x, return len(a) l&amp;lt;=r or l &amp;lt; r ans1 if you discard mid for the next iteration (i.e. l = mid+1 or r = mid-1) then use while (l &amp;lt;= r). if you keep mid for the next iteration (i.e. l = mid or r = mid) then use while (l &amp;lt; r) ans2 if you are returning from inside the loop, use left &amp;lt;= right if you are reducing the search space, use left &amp;lt; right and finally return a[left] template 1 can be determined by accessing a single index in the array.</description>
    </item>
    <item>
      <title>1696. Jump Game VI</title>
      <link>http://localhost:1313/leetcode/1696/</link>
      <pubDate>Sat, 09 Jul 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/1696/</guid>
      <description>https://leetcode.com/problems/jump-game-vi/&#xA;You are given a 0-indexed integer array nums and an integer k. You are initially standing at index 0. In one move, you can jump at most k steps forward without going outside the boundaries of the array. That is, you can jump from index i to any index in the range [i + 1, min(n - 1, i + k)] inclusive. You want to reach the last index of the array (index n - 1).</description>
    </item>
    <item>
      <title>Java frequently used data structures and methods for leetcode</title>
      <link>http://localhost:1313/dev/lee-java-data-structure/</link>
      <pubDate>Sat, 09 Jul 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/dev/lee-java-data-structure/</guid>
      <description>Array declare int[] a = new int[100]; int[] b = {4,1,5}; array = new int[]{1,2,3}; two-dimensional code int a[][] = {{1,2}, {3,4}}; code int array[][] = new int[3][]; array[0] = new int[3]; array[1] = new int[2]; array[2] = new int[5]; arr.length, a field on any array, the capacity, not the number of elements no () in the end, a final variable length, length(), size() .length is a field, containing the capacity (NOT the number of elements the array contains at the moment) of arrays.</description>
    </item>
    <item>
      <title>97. Interleaving String</title>
      <link>http://localhost:1313/leetcode/97/</link>
      <pubDate>Thu, 07 Jul 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/97/</guid>
      <description>https://leetcode.com/problems/interleaving-string/&#xA;Given strings s1, s2, and s3, find whether s3 is formed by an interleaving of s1 and s2. An interleaving of two strings s and t is a configuration where they are divided into non-empty substrings such that:&#xA;s = s1 + s2 + ... + sn t = t1 + t2 + ... + tm |n - m| &amp;lt;= 1 The **interleaving** is s1 + t1 + s2 + t2 + s3 + t3 + .</description>
    </item>
    <item>
      <title>128. Longest consecutive sequence</title>
      <link>http://localhost:1313/leetcode/128/</link>
      <pubDate>Tue, 05 Jul 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/128/</guid>
      <description>https://leetcode.com/problems/longest-consecutive-sequence/&#xA;Given an unsorted array of integers nums, return the length of the longest consecutive elements sequence. You must write an algorithm that runs in O(n) time.&#xA;Example 1: Input: nums = [100,4,200,1,3,2] Output: 4 Explanation: The longest consecutive elements sequence is [1, 2, 3, 4]. Therefore its length is 4.&#xA;code class Solution { public int longestConsecutive(int[] nums) { HashSet&amp;lt;Integer&amp;gt; s = new HashSet&amp;lt;&amp;gt;(Arrays.stream(nums).boxed().collect(Collectors.toList())); int longest = 0; for (int v: nums){ if (!</description>
    </item>
    <item>
      <title>200. number of islands</title>
      <link>http://localhost:1313/leetcode/200/</link>
      <pubDate>Mon, 04 Jul 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/200/</guid>
      <description>https://leetcode.com/problems/number-of-islands/&#xA;Given a 2d grid map of &amp;lsquo;1&amp;rsquo;s (land) and &amp;lsquo;0&amp;rsquo;s (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water. Example 1: 11110&#xA;11010&#xA;11000&#xA;00000&#xA;Output: 1 code class Solution { void dfs(char[][] grid, int r, int c) { int nr = grid.</description>
    </item>
    <item>
      <title>1465. Maximum Area of a Piece of Cake After Horizontal and Vertical Cuts</title>
      <link>http://localhost:1313/leetcode/1465/</link>
      <pubDate>Sat, 02 Jul 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/1465/</guid>
      <description>https://leetcode.com/problems/maximum-area-of-a-piece-of-cake-after-horizontal-and-vertical-cuts/&#xA;You are given a rectangular cake of size h x w and two arrays of integers horizontalCuts and verticalCuts where:&#xA;horizontalCuts[i] is the distance from the top of the rectangular cake to the ith horizontal cut and similarly, and verticalCuts[j] is the distance from the left of the rectangular cake to the jth vertical cut.Return __the maximum area of a piece of cake after you cut at each horizontal and vertical position provided in the arrays__ horizontalCuts __and__ verticalCuts.</description>
    </item>
    <item>
      <title>1710. Maximum Units on a Truck</title>
      <link>http://localhost:1313/leetcode/1710/</link>
      <pubDate>Fri, 01 Jul 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/1710/</guid>
      <description>Maximum Units on a Truck - LeetCode&#xA;You are assigned to put some amount of boxes onto one truck. You are given a 2D array boxTypes, where boxTypes[i] = [numberOfBoxesi, numberOfUnitsPerBoxi]:&#xA;numberOfBoxesi is the number of boxes of type i. numberOfUnitsPerBoxi is the number of units in each box of the type i.You are also given an integer truckSize, which is the maximum number of boxes that can be put on the truck.</description>
    </item>
    <item>
      <title>462. Minimum Moves to Equal Array Elements II</title>
      <link>http://localhost:1313/leetcode/462/</link>
      <pubDate>Thu, 30 Jun 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/462/</guid>
      <description>https://leetcode.com/problems/minimum-moves-to-equal-array-elements-ii/&#xA;Given an integer array nums of size n, return the minimum number of moves required to make all array elements equal. In one move, you can increment or decrement an element of the array by 1. Test cases are designed so that the answer will fit in a 32-bit integer.&#xA;Example 1: Input: nums = [1,2,3] Output: 2 Explanation: Only two moves are needed (remember each move increments or decrements one element): [1,2,3] =&amp;gt; [2,2,3] =&amp;gt; [2,2,2] Example 2: Input: nums = [1,10,2,9] Output: 16</description>
    </item>
    <item>
      <title>1647. Minimum Deletions to Make Character Frequencies Unique</title>
      <link>http://localhost:1313/leetcode/1647/</link>
      <pubDate>Tue, 28 Jun 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/1647/</guid>
      <description>https://leetcode.com/problems/minimum-deletions-to-make-character-frequencies-unique/&#xA;A string s is called good if there are no two different characters in s that have the same frequency. Given a string s, return__ the minimum number of characters you need to delete to make s good.__ The frequency of a character in a string is the number of times it appears in the string. For example, in the string &amp;ldquo;aab&amp;rdquo;, the frequency of &amp;lsquo;a&amp;rsquo; is 2, while the frequency of &amp;lsquo;b&amp;rsquo; is 1.</description>
    </item>
    <item>
      <title>1689. Partitioning Into Minimum Number Of Deci-Binary Numbers</title>
      <link>http://localhost:1313/leetcode/1689/</link>
      <pubDate>Mon, 27 Jun 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/1689/</guid>
      <description>https://leetcode.com/problems/partitioning-into-minimum-number-of-deci-binary-numbers/&#xA;A decimal number is called deci-binary if each of its digits is either 0 or 1 without any leading zeros. For example, 101 and 1100 are deci-binary, while 112 and 3001 are not. Given a string n that represents a positive decimal integer, return the minimum number of positive deci-binary numbers needed so that they sum up to n.&#xA;Example 1: Input: n = &amp;ldquo;32&amp;rdquo; Output: 3 Explanation: 10 + 11 + 11 = 32 Example 2: Input: n = &amp;ldquo;82734&amp;rdquo; Output: 8 Example 3: Input: n = &amp;ldquo;27346209830709182346&amp;rdquo; Output: 9</description>
    </item>
    <item>
      <title>1423. Maximum Points You Can Obtain from Cards</title>
      <link>http://localhost:1313/leetcode/1423/</link>
      <pubDate>Sun, 26 Jun 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/1423/</guid>
      <description>https://leetcode.com/problems/maximum-points-you-can-obtain-from-cards/&#xA;There are several cards arranged in a row, and each card has an associated number of points. The points are given in the integer array cardPoints. In one step, you can take one card from the beginning or from the end of the row. You have to take exactly k cards. Your score is the sum of the points of the cards you have taken. Given the integer array cardPoints and the integer k, return the maximum score you can obtain.</description>
    </item>
    <item>
      <title>665. Non-decreasing Array</title>
      <link>http://localhost:1313/leetcode/665/</link>
      <pubDate>Sat, 25 Jun 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/665/</guid>
      <description>https://leetcode.com/problems/non-decreasing-array/&#xA;Given an array nums with n integers, your task is to check if it could become non-decreasing by modifying at most one element. We define an array is non-decreasing if nums[i] &amp;lt;= nums[i + 1] holds for every i (0-based) such that (0 &amp;lt;= i &amp;lt;= n - 2).&#xA;Example 1: Input: nums = [4,2,3] Output: true Explanation: You could modify the first 4 to 1 to get a non-decreasing array.</description>
    </item>
    <item>
      <title>630. Course Schedule III</title>
      <link>http://localhost:1313/leetcode/630/</link>
      <pubDate>Thu, 23 Jun 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/630/</guid>
      <description>https://leetcode.com/problems/course-schedule-iii/&#xA;There are n different online courses numbered from 1 to n. You are given an array courses where courses[i] = [durationi, lastDayi] indicate that the ith course should be taken continuously for durationi days and must be finished before or on lastDayi. You will start on the 1st day and you cannot take two or more courses simultaneously. Return the maximum number of courses that you can take.&#xA;Example 1: Input: courses = [[100,200],[200,1300],[1000,1250],[2000,3200]] Output: 3 Explanation: There are totally 4 courses, but you can take 3 courses at most: First, take the 1st course, it costs 100 days so you will finish it on the 100th day, and ready to take the next course on the 101st day.</description>
    </item>
    <item>
      <title>1642. Furthest Building You Can Reach</title>
      <link>http://localhost:1313/leetcode/1642/</link>
      <pubDate>Wed, 22 Jun 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/1642/</guid>
      <description>https://leetcode.com/problems/furthest-building-you-can-reach/&#xA;You are given an integer array heights representing the heights of buildings, some bricks, and some ladders. You start your journey from building 0 and move to the next building by possibly using bricks or ladders. While moving from building i to building i+1 (0-indexed),&#xA;If the current building&#39;s height is **greater than or equal** to the next building&#39;s height, you do **not** need a ladder or bricks. If the current building&#39;s height is **less than** the next building&#39;s height, you can either use **one ladder** or (h[i+1] - h[i]) **bricks**.</description>
    </item>
    <item>
      <title>215. Kth Largest Element in an Array</title>
      <link>http://localhost:1313/leetcode/215/</link>
      <pubDate>Wed, 22 Jun 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/215/</guid>
      <description>Kth Largest Element in an Array - LeetCode&#xA;Given an integer array nums and an integer k, return the kth largest element in the array. Note that it is the kth largest element in the sorted order, not the kth distinct element.&#xA;Input: [3,2,1,5,6,4] and k = 2 Output: 5&#xA;Constraints:&#xA;1 &amp;lt;= k &amp;lt;= nums.length &amp;lt;= 104 -104 &amp;lt;= nums[i] &amp;lt;= 104 code class Solution { public int findKthLargest(int[] nums, int k) { PriorityQueue&amp;lt;Integer&amp;gt; hp = new PriorityQueue&amp;lt;&amp;gt;(); for (int v: nums){ if (hp.</description>
    </item>
    <item>
      <title>820. Short Encoding of Words</title>
      <link>http://localhost:1313/leetcode/820/</link>
      <pubDate>Mon, 20 Jun 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/820/</guid>
      <description>https://leetcode.com/problems/short-encoding-of-words/&#xA;A valid encoding of an array of words is any reference string s and array of indices indices such that:&#xA;words.length == indices.length The reference string s ends with the &#39;#&#39; character. For each index indices[i], the **substring** of s starting from indices[i] and up to (but not including) the next &#39;#&#39; character is equal to words[i].Given an array of words, return __the **length of the shortest reference string** __s__ possible of any **valid encoding** of __words__.</description>
    </item>
    <item>
      <title>1268. Search Suggestions System</title>
      <link>http://localhost:1313/leetcode/1268/</link>
      <pubDate>Sun, 19 Jun 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/1268/</guid>
      <description>https://leetcode.com/problems/search-suggestions-system/&#xA;You are given an array of strings products and a string searchWord. Design a system that suggests at most three product names from products after each character of searchWord is typed. Suggested products should have common prefix with searchWord. If there are more than three products with a common prefix return the three lexicographically minimums products. Return a list of lists of the suggested products after each character of searchWord is typed.</description>
    </item>
    <item>
      <title>208. Implement Trie (Prefix Tree)</title>
      <link>http://localhost:1313/leetcode/208/</link>
      <pubDate>Sat, 18 Jun 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/208/</guid>
      <description>https://leetcode.com/problems/implement-trie-prefix-tree/&#xA;A trie (pronounced as &amp;ldquo;try&amp;rdquo;) or prefix tree is a tree data structure used to efficiently store and retrieve keys in a dataset of strings. There are various applications of this data structure, such as autocomplete and spellchecker. Implement the Trie class:&#xA;Trie() Initializes the trie object. void insert(String word) Inserts the string word into the trie. boolean search(String word) Returns true if the string word is in the trie (i.</description>
    </item>
    <item>
      <title>745. Prefix and Suffix Search</title>
      <link>http://localhost:1313/leetcode/745/</link>
      <pubDate>Sat, 18 Jun 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/745/</guid>
      <description>https://leetcode.com/problems/prefix-and-suffix-search/&#xA;Design a special dictionary with some words that searchs the words in it by a prefix and a suffix. Implement the WordFilter class:&#xA;WordFilter(string[] words) Initializes the object with the words in the dictionary. f(string prefix, string suffix) Returns __the index of the word in the dictionary,__ which has the prefix prefix and the suffix suffix. If there is more than one valid index, return **the largest** of them. If there is no such word in the dictionary, return -1.</description>
    </item>
    <item>
      <title>leetcode: Trie</title>
      <link>http://localhost:1313/dev/lee-trie/</link>
      <pubDate>Sat, 18 Jun 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/dev/lee-trie/</guid>
      <description>Basic A Trie is a special form of a Nary tree. Typically, a trie is used to store strings. Each Trie node represents a string (a prefix). Each node might have several children nodes while the paths to different children nodes represent different characters. And the strings the child nodes represent will be the origin string represented by the node itself plus the character on the path.&#xA;Here is an example of a trie: In the example, the value we mark in each node is the string the node represents.</description>
    </item>
    <item>
      <title>968. Binary Tree Cameras</title>
      <link>http://localhost:1313/leetcode/968/</link>
      <pubDate>Fri, 17 Jun 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/968/</guid>
      <description>https://leetcode.com/problems/binary-tree-cameras/&#xA;You are given the root of a binary tree. We install cameras on the tree nodes where each camera at a node can monitor its parent, itself, and its immediate children. Return the minimum number of cameras needed to monitor all nodes of the tree.&#xA;Example 1: Input: root = [0,0,null,0,0] Output: 1 Explanation: One camera is enough to monitor all nodes if placed as shown. Example 2: Input: root = [0,0,null,0,null,0,null,null,0] Output: 2 Explanation: At least two cameras are needed to monitor all nodes of the tree.</description>
    </item>
    <item>
      <title>1048. Longest String Chain</title>
      <link>http://localhost:1313/leetcode/1048/</link>
      <pubDate>Wed, 15 Jun 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/1048/</guid>
      <description>https://leetcode.com/problems/longest-string-chain/&#xA;You are given an array of words where each word consists of lowercase English letters. wordA is a predecessor of wordB if and only if we can insert exactly one letter anywhere in wordA without changing the order of the other characters to make it equal to wordB.&#xA;For example, &amp;quot;abc&amp;quot; is a **predecessor** of &amp;quot;abac&amp;quot;, while &amp;quot;cba&amp;quot; is not a **predecessor** of &amp;quot;bcad&amp;quot;.A **word chain**__ __is a sequence of words [word1, word2, .</description>
    </item>
    <item>
      <title>583. Delete Operation for Two Strings</title>
      <link>http://localhost:1313/leetcode/583/</link>
      <pubDate>Tue, 14 Jun 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/583/</guid>
      <description>https://leetcode.com/problems/delete-operation-for-two-strings/&#xA;Given two strings word1 and word2, return the minimum number of steps required to make word1 and word2 the same. In one step, you can delete exactly one character in either string.&#xA;Example 1: Input: word1 = &amp;ldquo;sea&amp;rdquo;, word2 = &amp;ldquo;eat&amp;rdquo; Output: 2 Explanation: You need one step to make &amp;ldquo;sea&amp;rdquo; to &amp;ldquo;ea&amp;rdquo; and another step to make &amp;ldquo;eat&amp;rdquo; to &amp;ldquo;ea&amp;rdquo;. Example 2: Input: word1 = &amp;ldquo;leetcode&amp;rdquo;, word2 = &amp;ldquo;etco&amp;rdquo; Output: 4</description>
    </item>
    <item>
      <title>120. Triangle</title>
      <link>http://localhost:1313/leetcode/120/</link>
      <pubDate>Mon, 13 Jun 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/120/</guid>
      <description>https://leetcode.com/problems/triangle/&#xA;Given a triangle array, return the minimum path sum from top to bottom. For each step, you may move to an adjacent number of the row below. More formally, if you are on index i on the current row, you may move to either index i or index i + 1 on the next row.&#xA;Example 1: Input: triangle = [[2],[3,4],[6,5,7],[4,1,8,3]] Output: 11 Explanation: The triangle looks like: 2 3 4 6 5 7 4 1 8 3 The minimum path sum from top to bottom is 2 + 3 + 5 + 1 = 11 (underlined above).</description>
    </item>
    <item>
      <title>1695. Maximum Erasure Value</title>
      <link>http://localhost:1313/leetcode/1695/</link>
      <pubDate>Sun, 12 Jun 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/1695/</guid>
      <description>https://leetcode.com/problems/maximum-erasure-value/&#xA;You are given an array of positive integers nums and want to erase a subarray containing unique elements. The score you get by erasing the subarray is equal to the sum of its elements. Return the maximum score you can get by erasing exactly one subarray. An array b is called to be a subarray of a if it forms a contiguous subsequence of a, that is, if it is equal to a[l],a[l+1],&amp;hellip;,a[r] for some (l,r).</description>
    </item>
    <item>
      <title>1658. Minimum Operations to Reduce X to Zero</title>
      <link>http://localhost:1313/leetcode/1658/</link>
      <pubDate>Sat, 11 Jun 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/1658/</guid>
      <description>https://leetcode.com/problems/minimum-operations-to-reduce-x-to-zero/&#xA;You are given an integer array nums and an integer x. In one operation, you can either remove the leftmost or the rightmost element from the array nums and subtract its value from x. Note that this modifies the array for future operations. Return __the minimum number of operations to reduce x to exactly 0 if it is possible, otherwise, return __-1.&#xA;Example 1: Input: nums = [1,1,4,2,3], x = 5 Output: 2 Explanation: The optimal solution is to remove the last two elements to reduce x to zero.</description>
    </item>
    <item>
      <title>1332. Remove Palindromic Subsequences</title>
      <link>http://localhost:1313/leetcode/1332/</link>
      <pubDate>Wed, 08 Jun 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/1332/</guid>
      <description>https://leetcode.com/problems/remove-palindromic-subsequences/&#xA;You are given a string s consisting only of letters &amp;lsquo;a&amp;rsquo; and &amp;lsquo;b&amp;rsquo;. In a single step you can remove one palindromic subsequence from s. Return the minimum number of steps to make the given string empty. A string is a subsequence of a given string if it is generated by deleting some characters of a given string without changing its order. Note that a subsequence does not necessarily need to be contiguous.</description>
    </item>
    <item>
      <title>160. Intersection of Two Linked Lists</title>
      <link>http://localhost:1313/leetcode/160-intersection-of-two-linked-lists/</link>
      <pubDate>Mon, 06 Jun 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/160-intersection-of-two-linked-lists/</guid>
      <description>Given the heads of two singly linked-lists headA and headB, return the node at which the two lists intersect. If the two linked lists have no intersection at all, return null. For example, the following two linked lists begin to intersect at node c1: The test cases are generated such that there are no cycles anywhere in the entire linked structure. Note that the linked lists must retain their original structure after the function returns.</description>
    </item>
    <item>
      <title>How to debug flask in docker with intellij on Linux</title>
      <link>http://localhost:1313/dev/flask-docker-debug/</link>
      <pubDate>Sat, 04 Jun 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/dev/flask-docker-debug/</guid>
      <description>Reference: https://blog.jetbrains.com/pycharm/2017/03/docker-compose-getting-flask-up-and-running/&#xA;Project to use in this page : https://github.com/wikimedia/analytics-quarry-web&#xA;Clone it https://gerrit.wikimedia.org/r/admin/repos/analytics/quarry/web&#xA;git clone &amp;#34;ssh://jiyu@gerrit.wikimedia.org:29418/analytics/quarry/web&amp;#34; &amp;amp;&amp;amp; scp -p -P 29418 jiyu@gerrit.wikimedia.org:hooks/commit-msg &amp;#34;web/.git/hooks/&amp;#34; Set up git-review&#xA;git review -s --verbose I use intellij but PyCharm should be more or less the same.&#xA;Make sure your docker is configured correctly: https://docs.docker.com/engine/install/linux-postinstall/&#xA;Add remote interpreter First let&amp;rsquo;s run by default to make sure it&amp;rsquo;s working. docker-compose build &amp;amp;&amp;amp; docker-compose up&#xA;Notice I changed the file name from quarry.</description>
    </item>
    <item>
      <title>1480. Running Sum of 1d Array</title>
      <link>http://localhost:1313/leetcode/1480/</link>
      <pubDate>Thu, 02 Jun 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/1480/</guid>
      <description>https://leetcode.com/problems/running-sum-of-1d-array/&#xA;Given an array nums. We define a running sum of an array as runningSum[i] = sum(nums[0]…nums[i]). Return the running sum of nums.&#xA;Example 1: Input: nums = [1,2,3,4] Output: [1,3,6,10] Explanation: Running sum is obtained as follows: [1, 1+2, 1+2+3, 1+2+3+4]. Example 2: Input: nums = [1,1,1,1,1] Output: [1,2,3,4,5] Explanation: Running sum is obtained as follows: [1, 1+1, 1+1+1, 1+1+1+1, 1+1+1+1+1]. Example 3: Input: nums = [3,1,2,10,1] Output: [3,4,6,16,17]</description>
    </item>
    <item>
      <title>304. Range Sum Query 2D - Immutable</title>
      <link>http://localhost:1313/leetcode/304/</link>
      <pubDate>Thu, 02 Jun 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/304/</guid>
      <description>https://leetcode.com/problems/range-sum-query-2d-immutable/&#xA;Given a 2D matrix matrix, handle multiple queries of the following type:&#xA;Calculate the **sum** of the elements of matrix inside the rectangle defined by its **upper left corner** (row1, col1) and **lower right corner** (row2, col2).Implement the NumMatrix class: NumMatrix(int[][] matrix) Initializes the object with the integer matrix matrix. int sumRegion(int row1, int col1, int row2, int col2) Returns the **sum** of the elements of matrix inside the rectangle defined by its **upper left corner** (row1, col1) and **lower right corner** (row2, col2).</description>
    </item>
    <item>
      <title>406. Queue Reconstruction by Height</title>
      <link>http://localhost:1313/leetcode/406/</link>
      <pubDate>Thu, 02 Jun 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/406/</guid>
      <description>https://leetcode.com/problems/queue-reconstruction-by-height/&#xA;You are given an array of people, people, which are the attributes of some people in a queue (not necessarily in order). Each people[i] = [hi, ki] represents the ith person of height hi with exactly ki other people in front who have a height greater than or equal to hi. Reconstruct and return __the queue that is represented by the input array __people. The returned queue should be formatted as an array queue, where queue[j] = [hj, kj] is the attributes of the jth person in the queue (queue[0] is the person at the front of the queue).</description>
    </item>
    <item>
      <title>867. Transpose Matrix</title>
      <link>http://localhost:1313/leetcode/867/</link>
      <pubDate>Thu, 02 Jun 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/867/</guid>
      <description>https://leetcode.com/problems/transpose-matrix/&#xA;Given a 2D integer array matrix, return the transpose of matrix. The transpose of a matrix is the matrix flipped over its main diagonal, switching the matrix&amp;rsquo;s row and column indices. Example 1: Input: matrix = [[1,2,3],[4,5,6],[7,8,9]] Output: [[1,4,7],[2,5,8],[3,6,9]] Example 2: Input: matrix = [[1,2,3],[4,5,6]] Output: [[1,4],[2,5],[3,6]]&#xA;Constraints:&#xA;m == matrix.length n == matrix[i].length 1 &amp;lt;= m, n &amp;lt;= 1000 1 &amp;lt;= m * n &amp;lt;= 105 -109 &amp;lt;= matrix[i][j] &amp;lt;= 109 code class Solution: def transpose(self, matrix: List[List[int]]) -&amp;gt; List[List[int]]: return [[row[i] for row in matrix] for i in range(len(matrix[0]))] </description>
    </item>
    <item>
      <title>How to set up a shortcut to open/track/minimise an app on Linux</title>
      <link>http://localhost:1313/dev/tool-global-shortcut/</link>
      <pubDate>Thu, 02 Jun 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/dev/tool-global-shortcut/</guid>
      <description>For e.g. with yakuake, by default the shortcut is F12, you can open it or track it anywhere, just the same window. If it&amp;rsquo;s focused, press F12 again gonna minimize it.&#xA;Now let&amp;rsquo;s learn how to set up such a shortcut for our own whatever apps on Linux.&#xA;You need to have xorg-xprop, xdotool, wmctrl, procps-ng installed.&#xA;You&amp;rsquo;d want to set the terminal variable to your app&amp;rsquo;s launch command, and set the wm_class variable based on what you see when you run xprop WM_CLASS and click on your app window.</description>
    </item>
    <item>
      <title>Manjaro new installation personal config</title>
      <link>http://localhost:1313/dev/tool-manjaro-install/</link>
      <pubDate>Tue, 31 May 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/dev/tool-manjaro-install/</guid>
      <description>Configure trackball: https://yanjiyu.com/dev/tool-deftpro/&#xA;system&#xA;sudo pacman-mirrors -f &amp;amp;&amp;amp; sudo pacman -Syyu sudo pacman -Syu base-devel --needed sudo pacman -S yay go texlive-most konversation docker docker-compose gvim nodejs npm nvm sudo systemctl enable --now fstrim.timer personal&#xA;yay -S visual-studio-code-bin yay -S dynalist yay -S dropbox yay -S stretchly yay -S todoist-appimage yay -S jetbrains-toolbox yay -S autokey-git yay -S flameshot yay -S eudic yay -S freedownloadmanager yay -S git-review pip install --user tldr git</description>
    </item>
    <item>
      <title>318. Maximum Product of Word Lengths</title>
      <link>http://localhost:1313/leetcode/318/</link>
      <pubDate>Sun, 29 May 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/318/</guid>
      <description>https://leetcode.com/problems/maximum-product-of-word-lengths/&#xA;Given a string array words, return the maximum value of length(word[i]) * length(word[j]) where the two words do not share common letters. If no such two words exist, return 0.&#xA;Example 1: Input: words = [&amp;ldquo;abcw&amp;rdquo;,&amp;ldquo;baz&amp;rdquo;,&amp;ldquo;foo&amp;rdquo;,&amp;ldquo;bar&amp;rdquo;,&amp;ldquo;xtfn&amp;rdquo;,&amp;ldquo;abcdef&amp;rdquo;] Output: 16 Explanation: The two words can be &amp;ldquo;abcw&amp;rdquo;, &amp;ldquo;xtfn&amp;rdquo;. Example 2: Input: words = [&amp;ldquo;a&amp;rdquo;,&amp;ldquo;ab&amp;rdquo;,&amp;ldquo;abc&amp;rdquo;,&amp;ldquo;d&amp;rdquo;,&amp;ldquo;cd&amp;rdquo;,&amp;ldquo;bcd&amp;rdquo;,&amp;ldquo;abcd&amp;rdquo;] Output: 4 Explanation: The two words can be &amp;ldquo;ab&amp;rdquo;, &amp;ldquo;cd&amp;rdquo;. Example 3: Input: words = [&amp;ldquo;a&amp;rdquo;,&amp;ldquo;aa&amp;rdquo;,&amp;ldquo;aaa&amp;rdquo;,&amp;ldquo;aaaa&amp;rdquo;] Output: 0 Explanation: No such pair of words.</description>
    </item>
    <item>
      <title>1342. Number of Steps to Reduce a Number to Zero</title>
      <link>http://localhost:1313/leetcode/1342/</link>
      <pubDate>Fri, 27 May 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/1342/</guid>
      <description>https://leetcode.com/problems/number-of-steps-to-reduce-a-number-to-zero/&#xA;Given an integer num, return the number of steps to reduce it to zero. In one step, if the current number is even, you have to divide it by 2, otherwise, you have to subtract 1 from it.&#xA;Example 1: Input: num = 14 Output: 6 Explanation: Step 1) 14 is even; divide by 2 and obtain 7. Step 2) 7 is odd; subtract 1 and obtain 6. Step 3) 6 is even; divide by 2 and obtain 3.</description>
    </item>
    <item>
      <title>354. Russian Doll Envelopes</title>
      <link>http://localhost:1313/leetcode/354/</link>
      <pubDate>Wed, 25 May 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/354/</guid>
      <description>https://leetcode.com/problems/russian-doll-envelopes/&#xA;You are given a 2D array of integers envelopes where envelopes[i] = [wi, hi] represents the width and the height of an envelope. One envelope can fit into another if and only if both the width and height of one envelope are greater than the other envelope&amp;rsquo;s width and height. Return the maximum number of envelopes you can Russian doll (i.e., put one inside the other). Note: You cannot rotate an envelope.</description>
    </item>
    <item>
      <title>32. Longest Valid Parentheses</title>
      <link>http://localhost:1313/leetcode/32/</link>
      <pubDate>Tue, 24 May 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/32/</guid>
      <description>https://leetcode.com/problems/longest-valid-parentheses/&#xA;Given a string containing just the characters &amp;lsquo;(&amp;rsquo; and &amp;lsquo;)&amp;rsquo;, find the length of the longest valid (well-formed) parentheses substring.&#xA;Example 1: Input: s = &amp;ldquo;(()&amp;rdquo; Output: 2 Explanation: The longest valid parentheses substring is &amp;ldquo;()&amp;rdquo;. Example 2: Input: s = &amp;ldquo;)()())&amp;rdquo; Output: 4 Explanation: The longest valid parentheses substring is &amp;ldquo;()()&amp;rdquo;. Example 3: Input: s = &amp;quot;&amp;quot; Output: 0&#xA;Constraints:&#xA;0 &amp;lt;= s.length &amp;lt;= 3 * 104 s[i] is &#39;(&#39;, or &#39;)&#39;.</description>
    </item>
    <item>
      <title>1192. Critical Connections in a Network</title>
      <link>http://localhost:1313/leetcode/1192/</link>
      <pubDate>Mon, 23 May 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/1192/</guid>
      <description>https://leetcode.com/problems/critical-connections-in-a-network/&#xA;There are n servers numbered from 0 to n - 1 connected by undirected server-to-server connections forming a network where connections[i] = [ai, bi] represents a connection between servers ai and bi. Any server can reach other servers directly or indirectly through the network. A critical connection is a connection that, if removed, will make some servers unable to reach some other server. Return all critical connections in the network in any order.</description>
    </item>
    <item>
      <title>1379. Find a Corresponding Node of a Binary Tree in a Clone of That Tree</title>
      <link>http://localhost:1313/leetcode/1379/</link>
      <pubDate>Mon, 23 May 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/1379/</guid>
      <description>https://leetcode.com/problems/find-a-corresponding-node-of-a-binary-tree-in-a-clone-of-that-tree/&#xA;Given two binary trees original and cloned and given a reference to a node target in the original tree. The cloned tree is a copy of the original tree. Return a reference to the same node in the cloned tree. Note that you are not allowed to change any of the two trees or the target node and the answer must be a reference to a node in the cloned tree.</description>
    </item>
    <item>
      <title>329. Longest Increasing Path in a Matrix</title>
      <link>http://localhost:1313/leetcode/329/</link>
      <pubDate>Mon, 23 May 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/329/</guid>
      <description>https://leetcode.com/problems/longest-increasing-path-in-a-matrix/&#xA;Given an m x n integers matrix, return __the length of the longest increasing path in __matrix. From each cell, you can either move in four directions: left, right, up, or down. You may not move diagonally or move outside the boundary (i.e., wrap-around is not allowed).&#xA;Example 1: Input: matrix = [[9,9,4],[6,6,8],[2,1,1]] Output: 4 Explanation: The longest increasing path is [1, 2, 6, 9]. Example 2: Input: matrix = [[3,4,5],[3,2,6],[2,2,1]] Output: 4 Explanation: The longest increasing path is [3, 4, 5, 6].</description>
    </item>
    <item>
      <title>456. 132 Pattern</title>
      <link>http://localhost:1313/leetcode/456/</link>
      <pubDate>Mon, 23 May 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/456/</guid>
      <description>https://leetcode.com/problems/132-pattern/&#xA;Given an array of n integers nums, a 132 pattern is a subsequence of three integers nums[i], nums[j] and nums[k] such that i &amp;lt; j &amp;lt; k and nums[i] &amp;lt; nums[k] &amp;lt; nums[j]. Return true__ if there is a 132 pattern in nums, otherwise, return false.__&#xA;Example 1: Input: nums = [1,2,3,4] Output: false Explanation: There is no 132 pattern in the sequence. Example 2: Input: nums = [3,1,4,2] Output: true Explanation: There is a 132 pattern in the sequence: [1, 4, 2].</description>
    </item>
    <item>
      <title>474. Ones and Zeroes</title>
      <link>http://localhost:1313/leetcode/474/</link>
      <pubDate>Mon, 23 May 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/474/</guid>
      <description>https://leetcode.com/problems/ones-and-zeroes/&#xA;You are given an array of binary strings strs and two integers m and n. Return the size of the largest subset of strs such that there are at most m 0&amp;rsquo;s and n 1&amp;rsquo;s in the subset. A set x is a subset of a set y if all elements of x are also elements of y.&#xA;Example 1: Input: strs = [&amp;ldquo;10&amp;rdquo;,&amp;ldquo;0001&amp;rdquo;,&amp;ldquo;111001&amp;rdquo;,&amp;ldquo;1&amp;rdquo;,&amp;ldquo;0&amp;rdquo;], m = 5, n = 3 Output: 4 Explanation: The largest subset with at most 5 0&amp;rsquo;s and 3 1&amp;rsquo;s is {&amp;ldquo;10&amp;rdquo;, &amp;ldquo;0001&amp;rdquo;, &amp;ldquo;1&amp;rdquo;, &amp;ldquo;0&amp;rdquo;}, so the answer is 4.</description>
    </item>
    <item>
      <title>63. Unique Paths II</title>
      <link>http://localhost:1313/leetcode/63/</link>
      <pubDate>Mon, 23 May 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/63/</guid>
      <description>https://leetcode.com/problems/unique-paths-ii/&#xA;You are given an m x n integer array grid. There is a robot initially located at the top-left corner (i.e., grid[0][0]). The robot tries to move to the bottom-right corner (i.e., grid[m-1][n-1]). The robot can only move either down or right at any point in time. An obstacle and space are marked as 1 or 0 respectively in grid. A path that the robot takes cannot include any square that is an obstacle.</description>
    </item>
    <item>
      <title>647. Palindromic Substrings</title>
      <link>http://localhost:1313/leetcode/647/</link>
      <pubDate>Sun, 22 May 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/647/</guid>
      <description>https://leetcode.com/problems/palindromic-substrings/&#xA;Given a string s, return the number of palindromic substrings in it. A string is a palindrome when it reads the same backward as forward. A substring is a contiguous sequence of characters within the string.&#xA;Example 1: Input: s = &amp;ldquo;abc&amp;rdquo; Output: 3 Explanation: Three palindromic strings: &amp;ldquo;a&amp;rdquo;, &amp;ldquo;b&amp;rdquo;, &amp;ldquo;c&amp;rdquo;. Example 2: Input: s = &amp;ldquo;aaa&amp;rdquo; Output: 6 Explanation: Six palindromic strings: &amp;ldquo;a&amp;rdquo;, &amp;ldquo;a&amp;rdquo;, &amp;ldquo;a&amp;rdquo;, &amp;ldquo;aa&amp;rdquo;, &amp;ldquo;aa&amp;rdquo;, &amp;ldquo;aaa&amp;rdquo;.</description>
    </item>
    <item>
      <title>1302. Deepest Leaves Sum</title>
      <link>http://localhost:1313/leetcode/1302/</link>
      <pubDate>Sun, 15 May 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/1302/</guid>
      <description>https://leetcode.com/problems/deepest-leaves-sum/&#xA;Given the root of a binary tree, return the sum of values of its deepest leaves. Example 1: Input: root = [1,2,3,4,5,null,6,7,null,null,null,null,8] Output: 15 Example 2: Input: root = [6,7,8,2,7,1,3,9,null,1,4,null,null,null,5] Output: 19&#xA;Constraints:&#xA;The number of nodes in the tree is in the range [1, 104]. 1 &amp;lt;= Node.val &amp;lt;= 100 code class Solution: def deepestLeavesSum(self, root: Optional[TreeNode]) -&amp;gt; int: level = [root] while level: nex = [i for node in level for i in (node.</description>
    </item>
    <item>
      <title>1641. Count Sorted Vowel Strings</title>
      <link>http://localhost:1313/leetcode/1641/</link>
      <pubDate>Wed, 11 May 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/1641/</guid>
      <description>https://leetcode.com/problems/count-sorted-vowel-strings/&#xA;Given an integer n, return the number of strings of length n that consist only of vowels (a, e, i, o, u) and are lexicographically sorted. A string s is lexicographically sorted if for all valid i, s[i] is the same as or comes before s[i+1] in the alphabet.&#xA;Example 1: Input: n = 1 Output: 5 Explanation: The 5 sorted strings that consist of vowels only are [&amp;ldquo;a&amp;rdquo;,&amp;ldquo;e&amp;rdquo;,&amp;ldquo;i&amp;rdquo;,&amp;ldquo;o&amp;rdquo;,&amp;ldquo;u&amp;rdquo;]. Example 2: Input: n = 2 Output: 15 Explanation: The 15 sorted strings that consist of vowels only are [&amp;ldquo;aa&amp;rdquo;,&amp;ldquo;ae&amp;rdquo;,&amp;ldquo;ai&amp;rdquo;,&amp;ldquo;ao&amp;rdquo;,&amp;ldquo;au&amp;rdquo;,&amp;ldquo;ee&amp;rdquo;,&amp;ldquo;ei&amp;rdquo;,&amp;ldquo;eo&amp;rdquo;,&amp;ldquo;eu&amp;rdquo;,&amp;ldquo;ii&amp;rdquo;,&amp;ldquo;io&amp;rdquo;,&amp;ldquo;iu&amp;rdquo;,&amp;ldquo;oo&amp;rdquo;,&amp;ldquo;ou&amp;rdquo;,&amp;ldquo;uu&amp;rdquo;].</description>
    </item>
    <item>
      <title>How to configure deft pro track ball on Linux</title>
      <link>http://localhost:1313/dev/tool-deftpro/</link>
      <pubDate>Tue, 10 May 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/dev/tool-deftpro/</guid>
      <description>I use manjaro here.&#xA;Create a conf file, put it in /usr/share/X11/xorg.conf.d/99-trackball.conf&#xA;Notice the button mapping, instead of number 10, it&amp;rsquo;s 1, which means I use Fn1 button as Left button; then 2, means at 11 Fn2 button will be used as Middle button.&#xA;Section &amp;#34;InputClass&amp;#34; # DEFT PRO Buttons: # 1: Left button # 2: Middle button (wheel click) # 3: Right button # 4: Wheel scroll up # 5: Wheel scroll down # 6: Wheel tilt left # 7: Wheel tilt right # 8: Back button # 9: Forward button # 10: Fn1 (button on the left of the ball) # 11: Fn2 (button on right most) # 12: Fn3 (button on the above of the slide switch) Identifier &amp;#34;Elecom DEFT Pro Trackball&amp;#34; MatchProduct &amp;#34;DEFT Pro TrackBall&amp;#34; Driver &amp;#34;libinput&amp;#34; Option &amp;#34;ScrollMethod&amp;#34; &amp;#34;button&amp;#34; Option &amp;#34;ScrollButton&amp;#34; &amp;#34;9&amp;#34; Option&#x9;&amp;#34;MiddleEmulation&amp;#34; &amp;#34;on&amp;#34; Option &amp;#34;ButtonMapping&amp;#34; &amp;#34;1 2 3 4 5 6 7 8 9 1 2 12&amp;#34; EndSection I also found a way to use button lock, so forward button gonna trigger whether we use the ball as a scroll button.</description>
    </item>
    <item>
      <title>341. Flatten Nested List Iterator</title>
      <link>http://localhost:1313/leetcode/341/</link>
      <pubDate>Sun, 08 May 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/341/</guid>
      <description>Flatten Nested List Iterator - LeetCode&#xA;You are given a nested list of integers nestedList. Each element is either an integer or a list whose elements may also be integers or other lists. Implement an iterator to flatten it. Implement the NestedIterator class:&#xA;NestedIterator(List&amp;lt;NestedInteger&amp;gt; nestedList) Initializes the iterator with the nested list nestedList. int next() Returns the next integer in the nested list. boolean hasNext() Returns true if there are still some integers in the nested list and false otherwise.</description>
    </item>
    <item>
      <title>1209. Remove All Adjacent Duplicates in String II</title>
      <link>http://localhost:1313/leetcode/1209/</link>
      <pubDate>Fri, 06 May 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/1209/</guid>
      <description>Remove All Adjacent Duplicates in String II - LeetCode&#xA;You are given a string s and an integer k, a k duplicate removal consists of choosing k adjacent and equal letters from s and removing them, causing the left and the right side of the deleted substring to concatenate together. We repeatedly make k duplicate removals on s until we no longer can. Return the final string after all such duplicate removals have been made.</description>
    </item>
    <item>
      <title>191. Number of 1 Bits</title>
      <link>http://localhost:1313/leetcode/191-number-of-1-bits/</link>
      <pubDate>Thu, 05 May 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/191-number-of-1-bits/</guid>
      <description>Number of 1 Bits - LeetCode&#xA;Write a function that takes an unsigned integer and return the number of &amp;lsquo;1&amp;rsquo; bits it has (also known as the Hamming weight).&#xA;Example 1: Input: 00000000000000000000000000001011 Output: 3 Explanation: The input binary string 00000000000000000000000000001011 has a total of three &amp;lsquo;1&amp;rsquo; bits.&#xA;code class Solution: def hammingWeight(self, n: int) -&amp;gt; int: return str(bin(n)).count(&amp;#34;1&amp;#34;) code class Solution: def hammingWeight(self, n: int) -&amp;gt; int: count = 0 while n: count += n &amp;amp; 1 n = n &amp;gt;&amp;gt; 1 return count code class Solution: def hammingWeight(self, n: int) -&amp;gt; int: res = 0 while n !</description>
    </item>
    <item>
      <title>leetcode questions: Bit</title>
      <link>http://localhost:1313/dev/lee-bit/</link>
      <pubDate>Thu, 05 May 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/dev/lee-bit/</guid>
      <description>common tricks x &amp;amp; (-x) to isolate/get the rightmost 1-bit This operation reverts all bits of x except the rightmost 1-bit.&#xA;Hence, x and -x have just one bit in common - the rightmost 1-bit. That means that x &amp;amp; (-x) would keep that rightmost 1-bit and set all the other bits to 0. x &amp;amp; (x - 1) is a way to set the rightmost 1-bit to zero. To subtract 1 means to change the rightmost 1-bit to 0 and to set all the lower bits to 1.</description>
    </item>
    <item>
      <title>1679. Max Number of K-Sum Pairs</title>
      <link>http://localhost:1313/leetcode/1679/</link>
      <pubDate>Wed, 04 May 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/1679/</guid>
      <description>Max Number of K-Sum Pairs - LeetCode&#xA;You are given an integer array nums and an integer k. In one operation, you can pick two numbers from the array whose sum equals k and remove them from the array. Return the maximum number of operations you can perform on the array.&#xA;Example 1: Input: nums = [1,2,3,4], k = 5 Output: 2 Explanation: Starting with nums = [1,2,3,4]: - Remove numbers 1 and 4, then nums = [2,3] - Remove numbers 2 and 3, then nums = [] There are no more pairs that sum up to 5, hence a total of 2 operations.</description>
    </item>
    <item>
      <title>581. Shortest Unsorted Continuous Subarray</title>
      <link>http://localhost:1313/leetcode/581/</link>
      <pubDate>Tue, 03 May 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/581/</guid>
      <description>Shortest Unsorted Continuous Subarray - LeetCode&#xA;Given an integer array nums, you need to find one continuous subarray that if you only sort this subarray in ascending order, then the whole array will be sorted in ascending order. Return the shortest such subarray and output its length.&#xA;Example 1: Input: nums = [2,6,4,8,10,9,15] Output: 5 Explanation: You need to sort [6, 4, 8, 10, 9] in ascending order to make the whole array sorted in ascending order.</description>
    </item>
    <item>
      <title>905. Sort array by parity</title>
      <link>http://localhost:1313/leetcode/905/</link>
      <pubDate>Mon, 02 May 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/905/</guid>
      <description>Sort Array By Parity - LeetCode&#xA;Given an integer array nums, move all the even integers at the beginning of the array followed by all the odd integers. Return any array that satisfies this condition.&#xA;Example 1: Input: nums = [3,1,2,4] Output: [2,4,3,1] Explanation: The outputs [4,2,3,1], [2,4,1,3], and [4,2,1,3] would also be accepted. Example 2: Input: nums = [0] Output: [0]&#xA;Constraints:&#xA;1 &amp;lt;= nums.length &amp;lt;= 5000 0 &amp;lt;= nums[i] &amp;lt;= 5000 code class Solution { public int[] sortArrayByParity(int[] nums) { int left = 0, right = nums.</description>
    </item>
    <item>
      <title>484. Find Permutation</title>
      <link>http://localhost:1313/leetcode/484/</link>
      <pubDate>Sun, 01 May 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/484/</guid>
      <description>Find Permutation - LeetCode&#xA;A permutation perm of n integers of all the integers in the range [1, n] can be represented as a string s of length n - 1 where:&#xA;s[i] == &#39;I&#39; if perm[i] &amp;lt; perm[i + 1], and s[i] == &#39;D&#39; if perm[i] &amp;gt; perm[i + 1].Given a string s, reconstruct the lexicographically smallest permutation perm and return it. Example 1: Input: s = &amp;ldquo;I&amp;rdquo; Output: [1,2] Explanation: [1,2] is the only legal permutation that can represented by s, where the number 1 and 2 construct an increasing relationship.</description>
    </item>
    <item>
      <title>844. Backspace String Compare</title>
      <link>http://localhost:1313/leetcode/844/</link>
      <pubDate>Sun, 01 May 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/844/</guid>
      <description>Backspace String Compare - LeetCode&#xA;Given two strings s and t, return true if they are equal when both are typed into empty text editors. &amp;lsquo;#&amp;rsquo; means a backspace character. Note that after backspacing an empty text, the text will continue empty.&#xA;Example 1: Input: s = &amp;ldquo;ab#c&amp;rdquo;, t = &amp;ldquo;ad#c&amp;rdquo; Output: true Explanation: Both s and t become &amp;ldquo;ac&amp;rdquo;. Example 2: Input: s = &amp;ldquo;ab##&amp;rdquo;, t = &amp;ldquo;c#d#&amp;rdquo; Output: true Explanation: Both s and t become &amp;ldquo;&amp;rdquo;.</description>
    </item>
    <item>
      <title>785. Is Graph Bipartite?</title>
      <link>http://localhost:1313/leetcode/785/</link>
      <pubDate>Sat, 30 Apr 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/785/</guid>
      <description>Is Graph Bipartite? - LeetCode&#xA;There is an undirected graph with n nodes, where each node is numbered between 0 and n - 1. You are given a 2D array graph, where graph[u] is an array of nodes that node u is adjacent to. More formally, for each v in graph[u], there is an undirected edge between node u and node v. The graph has the following properties:&#xA;There are no self-edges (graph[u] does not contain u).</description>
    </item>
    <item>
      <title>1050. Actors and Directors Who Cooperated At Least Three Times</title>
      <link>http://localhost:1313/leetcode/1050/</link>
      <pubDate>Thu, 28 Apr 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/1050/</guid>
      <description>Actors and Directors Who Cooperated At Least Three Times - LeetCode&#xA;Write a SQL query for a report that provides the pairs (actor_id, director_id) where the actor has cooperated with the director at least three times. Return the result table in any order. The query result format is in the following example.&#xA;code SELECT actor_id, director_id FROM ActorDirector GROUP BY actor_id, director_id HAVING COUNT(*)&amp;gt;=3 </description>
    </item>
    <item>
      <title>586. Customer Placing the Largest Number of Orders</title>
      <link>http://localhost:1313/leetcode/586/</link>
      <pubDate>Thu, 28 Apr 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/586/</guid>
      <description>Customer Placing the Largest Number of Orders - LeetCode&#xA;Write an SQL query to find the customer_number for the customer who has placed the largest number of orders. The test cases are generated so that exactly one customer will have placed more orders than any other customer. The query result format is in the following example.&#xA;code select top 1 customer_number from Orders group by customer_number order by count(*) desc </description>
    </item>
    <item>
      <title>284. Peeking Iterator</title>
      <link>http://localhost:1313/leetcode/284/</link>
      <pubDate>Mon, 25 Apr 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/284/</guid>
      <description>Peeking Iterator - LeetCode&#xA;Design an iterator that supports the peek operation on an existing iterator in addition to the hasNext and the next operations. Implement the PeekingIterator class:&#xA;PeekingIterator(Iterator&amp;lt;int&amp;gt; nums) Initializes the object with the given integer iterator iterator. int next() Returns the next element in the array and moves the pointer to the next element. boolean hasNext() Returns true if there are still elements in the array. int peek() Returns the next element in the array without moving the pointer.</description>
    </item>
    <item>
      <title>1166. Design File System</title>
      <link>http://localhost:1313/leetcode/1166/</link>
      <pubDate>Sun, 24 Apr 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/1166/</guid>
      <description>Design File System - LeetCode&#xA;You are asked to design a file system that allows you to create new paths and associate them with different values. The format of a path is one or more concatenated strings of the form: / followed by one or more lowercase English letters. For example, &amp;ldquo;/leetcode&amp;rdquo; and &amp;ldquo;/leetcode/problems&amp;rdquo; are valid paths while an empty string &amp;quot;&amp;quot; and &amp;ldquo;/&amp;rdquo; are not. Implement the FileSystem class:</description>
    </item>
    <item>
      <title>1396. Design Underground System</title>
      <link>http://localhost:1313/leetcode/1396/</link>
      <pubDate>Sun, 24 Apr 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/1396/</guid>
      <description>Design Underground System - LeetCode&#xA;An underground railway system is keeping track of customer travel times between different stations. They are using this data to calculate the average time it takes to travel from one station to another. Implement the UndergroundSystem class:&#xA;void checkIn(int id, string stationName, int t) A customer with a card ID equal to id, checks in at the station stationName at time t. A customer can only be checked into one place at a time.</description>
    </item>
    <item>
      <title>535. Encode and Decode TinyURL</title>
      <link>http://localhost:1313/leetcode/535/</link>
      <pubDate>Sat, 23 Apr 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/535/</guid>
      <description>Encode and Decode TinyURL - LeetCode&#xA;TinyURL is a URL shortening service where you enter a URL such as https://leetcode.com/problems/design-tinyurl and it returns a short URL such as http://tinyurl.com/4e9iAk. Design a class to encode a URL and decode a tiny URL. There is no restriction on how your encode/decode algorithm should work. You just need to ensure that a URL can be encoded to a tiny URL and the tiny URL can be decoded to the original URL.</description>
    </item>
    <item>
      <title>706. Design hash map</title>
      <link>http://localhost:1313/leetcode/706/</link>
      <pubDate>Fri, 22 Apr 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/706/</guid>
      <description>Design HashMap - LeetCode&#xA;Design a HashMap without using any built-in hash table libraries. Implement the MyHashMap class:&#xA;MyHashMap() initializes the object with an empty map. void put(int key, int value) inserts a (key, value) pair into the HashMap. If the key already exists in the map, update the corresponding value. int get(int key) returns the value to which the specified key is mapped, or -1 if this map contains no mapping for the key.</description>
    </item>
    <item>
      <title>173. Binary search tree iterator</title>
      <link>http://localhost:1313/leetcode/99/</link>
      <pubDate>Wed, 20 Apr 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/99/</guid>
      <description>Binary Search Tree Iterator - LeetCode&#xA;Implement the BSTIterator class that represents an iterator over the in-order traversal of a binary search tree (BST):&#xA;BSTIterator(TreeNode root) Initializes an object of the BSTIterator class. The root of the BST is given as part of the constructor. The pointer should be initialized to a non-existent number smaller than any element in the BST. boolean hasNext() Returns true if there exists a number in the traversal to the right of the pointer, otherwise returns false.</description>
    </item>
    <item>
      <title>897. Increasing Order Search Tree</title>
      <link>http://localhost:1313/leetcode/897/</link>
      <pubDate>Sun, 17 Apr 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/897/</guid>
      <description>Increasing Order Search Tree - LeetCode&#xA;Given the root of a binary search tree, rearrange the tree in in-order so that the leftmost node in the tree is now the root of the tree, and every node has no left child and only one right child.&#xA;Example 1: Input: root = [5,3,6,2,4,null,8,1,null,null,null,7,9] Output: [1,null,2,null,3,null,4,null,5,null,6,null,7,null,8,null,9] Example 2: Input: root = [5,1,7] Output: [1,null,5,null,7]&#xA;Constraints:&#xA;The number of nodes in the given tree will be in the range [1, 100].</description>
    </item>
    <item>
      <title>538. Convert BST to Greater Tree</title>
      <link>http://localhost:1313/leetcode/538/</link>
      <pubDate>Sat, 16 Apr 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/538/</guid>
      <description>Convert BST to Greater Tree - LeetCode&#xA;Given the root of a Binary Search Tree (BST), convert it to a Greater Tree such that every key of the original BST is changed to the original key plus the sum of all keys greater than the original key in BST. As a reminder, a binary search tree is a tree that satisfies these constraints:&#xA;The left subtree of a node contains only nodes with keys less than the node&#39;s key.</description>
    </item>
    <item>
      <title>1586. Binary Search Tree Iterator II</title>
      <link>http://localhost:1313/leetcode/1586/</link>
      <pubDate>Fri, 15 Apr 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/1586/</guid>
      <description>Binary Search Tree Iterator II - LeetCode&#xA;Implement the BSTIterator class that represents an iterator over the in-order traversal of a binary search tree (BST):&#xA;BSTIterator(TreeNode root) Initializes an object of the BSTIterator class. The root of the BST is given as part of the constructor. The pointer should be initialized to a non-existent number smaller than any element in the BST. boolean hasNext() Returns true if there exists a number in the traversal to the right of the pointer, otherwise returns false.</description>
    </item>
    <item>
      <title>669. Trim a Binary Search Tree</title>
      <link>http://localhost:1313/leetcode/669/</link>
      <pubDate>Fri, 15 Apr 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/669/</guid>
      <description>Trim a Binary Search Tree - LeetCode&#xA;Given the root of a binary search tree and the lowest and highest boundaries as low and high, trim the tree so that all its elements lies in [low, high]. Trimming the tree should not change the relative structure of the elements that will remain in the tree (i.e., any node&amp;rsquo;s descendant should remain a descendant). It can be proven that there is a unique answer.</description>
    </item>
    <item>
      <title>59. Spiral Matrix II</title>
      <link>http://localhost:1313/leetcode/59/</link>
      <pubDate>Wed, 13 Apr 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/59/</guid>
      <description>Spiral Matrix II - LeetCode&#xA;Given a positive integer n, generate an n x n matrix filled with elements from 1 to n2 in spiral order.&#xA;Example 1: Input: n = 3 Output: [[1,2,3],[8,9,4],[7,6,5]] Example 2: Input: n = 1 Output: [[1]]&#xA;Constraints:&#xA;1 &amp;lt;= n &amp;lt;= 20 code class Solution: def generateMatrix(self, n: int) -&amp;gt; List[List[int]]: if n == 1: return [[1]] res = [[0] * n for _ in range(n)] direction = {&amp;#39;right&amp;#39;:(0, 1), &amp;#39;left&amp;#39;:(0, -1), &amp;#39;up&amp;#39;: (-1, 0), &amp;#39;down&amp;#39;: (1, 0)} def walk(x, y, d, value): if res[x][y] !</description>
    </item>
    <item>
      <title>1260. Shift 2D Grid</title>
      <link>http://localhost:1313/leetcode/1260/</link>
      <pubDate>Mon, 11 Apr 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/1260/</guid>
      <description>Shift 2D Grid - LeetCode&#xA;Given a 2D grid of size m x n and an integer k. You need to shift the grid k times. In one shift operation:&#xA;Element at grid[i][j] moves to grid[i][j + 1]. Element at grid[i][n - 1] moves to grid[i + 1][0]. Element at grid[m - 1][n - 1] moves to grid[0][0].Return the __2D grid__ after applying shift operation k times. Example 1: Input: grid = [[1,2,3],[4,5,6],[7,8,9]], k = 1 Output: [[9,1,2],[3,4,5],[6,7,8]] Example 2: Input: grid = [[3,8,1,9],[19,7,2,5],[4,6,11,10],[12,0,21,13]], k = 4 Output: [[12,0,21,13],[3,8,1,9],[19,7,2,5],[4,6,11,10]] Example 3: Input: grid = [[1,2,3],[4,5,6],[7,8,9]], k = 9 Output: [[1,2,3],[4,5,6],[7,8,9]]</description>
    </item>
    <item>
      <title>682. Baseball Game</title>
      <link>http://localhost:1313/leetcode/682/</link>
      <pubDate>Sun, 10 Apr 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/682/</guid>
      <description>Baseball Game - LeetCode&#xA;You are keeping score for a baseball game with strange rules. The game consists of several rounds, where the scores of past rounds may affect future rounds&amp;rsquo; scores. At the beginning of the game, you start with an empty record. You are given a list of strings ops, where ops[i] is the ith operation you must apply to the record and is one of the following:</description>
    </item>
    <item>
      <title>1511. Customer Order Frequency</title>
      <link>http://localhost:1313/leetcode/1511/</link>
      <pubDate>Thu, 07 Apr 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/1511/</guid>
      <description>Customer Order Frequency - LeetCode&#xA;Write an SQL query to report the customer_id and customer_name of customers who have spent at least $100 in each month of June and July 2020.&#xA;code mysql SELECT customer_id, name FROM Customers JOIN Orders USING(customer_id) JOIN Product USING(product_id) GROUP BY customer_id HAVING SUM(IF(LEFT(order_date, 7) = &amp;#39;2020-06&amp;#39;, quantity, 0) * price) &amp;gt;= 100 AND SUM(IF(LEFT(order_date, 7) = &amp;#39;2020-07&amp;#39;, quantity, 0) * price) &amp;gt;= 100 code mssql select o.</description>
    </item>
    <item>
      <title>607. Sales Person</title>
      <link>http://localhost:1313/leetcode/607/</link>
      <pubDate>Thu, 07 Apr 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/607/</guid>
      <description>Sales Person - LeetCode1&#xA;code select name from SalesPerson where sales_id not in (select o.sales_id from Orders o join Company c on c.com_id = o.com_id where c.name = &amp;#39;RED&amp;#39; ) </description>
    </item>
    <item>
      <title>923. 3Sum With Multiplicity</title>
      <link>http://localhost:1313/leetcode/923/</link>
      <pubDate>Wed, 06 Apr 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/923/</guid>
      <description>Given an integer array arr, and an integer target, return the number of tuples i, j, k such that i &amp;lt; j &amp;lt; k and arr[i] + arr[j] + arr[k] == target. As the answer can be very large, return it modulo 109 + 7.&#xA;Example 1: Input: arr = [1,1,2,2,3,3,4,4,5,5], target = 8 Output: 20 Explanation: Enumerating by the values (arr[i], arr[j], arr[k]): (1, 2, 5) occurs 8 times; (1, 3, 4) occurs 8 times; (2, 2, 4) occurs 2 times; (2, 3, 3) occurs 2 times.</description>
    </item>
    <item>
      <title>1721. Swapping Nodes in a Linked List</title>
      <link>http://localhost:1313/leetcode/1721/</link>
      <pubDate>Mon, 04 Apr 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/1721/</guid>
      <description>Swapping Nodes in a Linked List - LeetCode&#xA;You are given the head of a linked list, and an integer k. Return __the head of the linked list after swapping the values of the __kth __node from the beginning and the __kth node from the end (the list is 1-indexed).&#xA;Example 1: Input: head = [1,2,3,4,5], k = 2 Output: [1,4,3,2,5] Example 2: Input: head = [7,9,6,6,7,8,3,0,9,5], k = 5 Output: [7,9,6,6,8,7,3,0,9,5]</description>
    </item>
    <item>
      <title>1087. Brace Expansion</title>
      <link>http://localhost:1313/leetcode/1087/</link>
      <pubDate>Fri, 01 Apr 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/1087/</guid>
      <description>Brace Expansion - LeetCode&#xA;You are given a string s representing a list of words. Each letter in the word has one or more options.&#xA;If there is one option, the letter is represented as is. If there is more than one option, then curly braces delimit the options. For example, &amp;quot;{a,b,c}&amp;quot; represents options [&amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;, &amp;quot;c&amp;quot;].For example, if s = &amp;quot;a{b,c}&amp;quot;, the first character is always &#39;a&#39;, but the second character can be &#39;b&#39; or &#39;c&#39;.</description>
    </item>
    <item>
      <title>31. Next Permutation</title>
      <link>http://localhost:1313/leetcode/31/</link>
      <pubDate>Fri, 01 Apr 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/31/</guid>
      <description>Next Permutation - LeetCode&#xA;A permutation of an array of integers is an arrangement of its members into a sequence or linear order.&#xA;For example, for arr = [1,2,3], the following are considered permutations of arr: [1,2,3], [1,3,2], [3,1,2], [2,3,1].The next permutation of an array of integers is the next lexicographically greater permutation of its integer. More formally, if all the permutations of the array are sorted in one container according to their lexicographical order, then the next permutation of that array is the permutation that follows it in the sorted container.</description>
    </item>
    <item>
      <title>344. reverse string</title>
      <link>http://localhost:1313/leetcode/344-reverse-string/</link>
      <pubDate>Fri, 01 Apr 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/344-reverse-string/</guid>
      <description>Reverse String - LeetCode&#xA;Write a function that reverses a string. The input string is given as an array of characters char[]. Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory. You may assume all the characters consist of printable ascii characters.&#xA;Example 1: Input: [&amp;ldquo;h&amp;rdquo;,&amp;ldquo;e&amp;rdquo;,&amp;ldquo;l&amp;rdquo;,&amp;ldquo;l&amp;rdquo;,&amp;ldquo;o&amp;rdquo;]Output: [&amp;ldquo;o&amp;rdquo;,&amp;ldquo;l&amp;rdquo;,&amp;ldquo;l&amp;rdquo;,&amp;ldquo;e&amp;rdquo;,&amp;ldquo;h&amp;rdquo;] code class Solution: def reverseString(self, s: List[str]) -&amp;gt; None: for i in range(len(s) // 2): s[i], s[~i] = s[~i], s[i] code class Solution: def reverseString(self, s: List[str]) -&amp;gt; None: l, r = 0, len(s)-1 while l &amp;lt; r: s[l], s[r] = s[r], s[l] l += 1 r -= 1 </description>
    </item>
    <item>
      <title>724. Find Pivot Index</title>
      <link>http://localhost:1313/leetcode/724/</link>
      <pubDate>Fri, 01 Apr 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/724/</guid>
      <description>Find Pivot Index - LeetCode&#xA;Given an array of integers nums, calculate the pivot index of this array. The pivot index is the index where the sum of all the numbers strictly to the left of the index is equal to the sum of all the numbers strictly to the index&amp;rsquo;s right. If the index is on the left edge of the array, then the left sum is 0 because there are no elements to the left.</description>
    </item>
    <item>
      <title>747. Largest Number At Least Twice of Others</title>
      <link>http://localhost:1313/leetcode/747/</link>
      <pubDate>Fri, 01 Apr 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/747/</guid>
      <description>Largest Number At Least Twice of Others - LeetCode&#xA;You are given an integer array nums where the largest integer is unique. Determine whether the largest element in the array is at least twice as much as every other number in the array. If it is, return the index of the largest element, or return -1 otherwise.&#xA;Example 1: Input: nums = [3,6,1,0] Output: 1 Explanation: 6 is the largest integer.</description>
    </item>
    <item>
      <title>1102. Path With Maximum Minimum Value</title>
      <link>http://localhost:1313/leetcode/1102/</link>
      <pubDate>Tue, 29 Mar 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/1102/</guid>
      <description>Path With Maximum Minimum Value - LeetCode&#xA;Given an m x n integer matrix grid, return __the maximum score of a path starting at (0, 0) and ending at __(m - 1, n - 1) moving in the 4 cardinal directions. The score of a path is the minimum value in that path.&#xA;For example, the score of the path 8 → 4 → 5 → 9 is 4. Example 1: Input: grid = [[5,4,5],[1,2,6],[7,4,6]] Output: 4 Explanation: The path with the maximum score is highlighted in yellow.</description>
    </item>
    <item>
      <title>1996. The Number of Weak Characters in the Game</title>
      <link>http://localhost:1313/leetcode/1996/</link>
      <pubDate>Tue, 29 Mar 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/1996/</guid>
      <description>The Number of Weak Characters in the Game - LeetCode&#xA;You are playing a game that contains multiple characters, and each of the characters has two main properties: attack and defense. You are given a 2D integer array properties where properties[i] = [attacki, defensei] represents the properties of the ith character in the game. A character is said to be weak if any other character has both attack and defense levels strictly greater than this character&amp;rsquo;s attack and defense levels.</description>
    </item>
    <item>
      <title>153. Find minimum in rotated sorted array</title>
      <link>http://localhost:1313/leetcode/153/</link>
      <pubDate>Mon, 28 Mar 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/153/</guid>
      <description>Find Minimum in Rotated Sorted Array - LeetCode&#xA;Suppose an array of length n sorted in ascending order is rotated between 1 and n times. For example, the array nums = [0,1,2,4,5,6,7] might become:&#xA;[4,5,6,7,0,1,2] if it was rotated 4 times. [0,1,2,4,5,6,7] if it was rotated 7 times.Notice that **rotating** an array [a[0], a[1], a[2], ..., a[n-1]] 1 time results in the array [a[n-1], a[0], a[1], a[2], ..., a[n-2]]. Given the sorted rotated array nums of unique elements, return the minimum element of this array.</description>
    </item>
    <item>
      <title>1029. Two City Scheduling</title>
      <link>http://localhost:1313/leetcode/1029/</link>
      <pubDate>Fri, 25 Mar 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/1029/</guid>
      <description>Two City Scheduling - LeetCode&#xA;A company is planning to interview 2n people. Given the array costs where costs[i] = [aCosti, bCosti], the cost of flying the ith person to city a is aCosti, and the cost of flying the ith person to city b is bCosti. Return the minimum cost to fly every person to a city such that exactly n people arrive in each city.&#xA;Example 1: Input: costs = [[10,20],[30,200],[400,50],[30,20]] Output: 110 Explanation: The first person goes to city A for a cost of 10.</description>
    </item>
    <item>
      <title>311. Sparse Matrix Multiplication</title>
      <link>http://localhost:1313/leetcode/311/</link>
      <pubDate>Thu, 24 Mar 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/311/</guid>
      <description>Sparse Matrix Multiplication - LeetCode&#xA;Given two sparse matrices mat1 of size m x k and mat2 of size k x n, return the result of mat1 x mat2. You may assume that multiplication is always possible.&#xA;Example 1: Input: mat1 = [[1,0,0],[-1,0,3]], mat2 = [[7,0,0],[0,0,0],[0,0,1]] Output: [[7,0,0],[-7,0,3]] Example 2: Input: mat1 = [[0]], mat2 = [[0]] Output: [[0]]&#xA;Constraints:&#xA;m == mat1.length k == mat1[i].length == mat2.length n == mat2[i].</description>
    </item>
    <item>
      <title>881. Boats to Save People</title>
      <link>http://localhost:1313/leetcode/881/</link>
      <pubDate>Thu, 24 Mar 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/881/</guid>
      <description>Boats to Save People - LeetCode&#xA;You are given an array people where people[i] is the weight of the ith person, and an infinite number of boats where each boat can carry a maximum weight of limit. Each boat carries at most two people at the same time, provided the sum of the weight of those people is at most limit. Return the minimum number of boats to carry every given person.</description>
    </item>
    <item>
      <title>1179. Reformat Department Table</title>
      <link>http://localhost:1313/leetcode/1179/</link>
      <pubDate>Wed, 23 Mar 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/1179/</guid>
      <description>Reformat Department Table - LeetCode code #groupby SELECT id, MAX(CASE WHEN month = &amp;#39;Jan&amp;#39; THEN revenue ELSE null END) AS Jan_Revenue, MAX(CASE WHEN month = &amp;#39;Feb&amp;#39; THEN revenue ELSE null END) AS Feb_Revenue, MAX(CASE WHEN month = &amp;#39;Mar&amp;#39; THEN revenue ELSE null END) AS Mar_Revenue, MAX(CASE WHEN month = &amp;#39;Apr&amp;#39; THEN revenue ELSE null END) AS Apr_Revenue, MAX(CASE WHEN month = &amp;#39;May&amp;#39; THEN revenue ELSE null END) AS May_Revenue, MAX(CASE WHEN month = &amp;#39;Jun&amp;#39; THEN revenue ELSE null END) AS Jun_Revenue, MAX(CASE WHEN month = &amp;#39;Jul&amp;#39; THEN revenue ELSE null END) AS Jul_Revenue, MAX(CASE WHEN month = &amp;#39;Aug&amp;#39; THEN revenue ELSE null END) AS Aug_Revenue, MAX(CASE WHEN month = &amp;#39;Sep&amp;#39; THEN revenue ELSE null END) AS Sep_Revenue, MAX(CASE WHEN month = &amp;#39;Oct&amp;#39; THEN revenue ELSE null END) AS Oct_Revenue, MAX(CASE WHEN month = &amp;#39;Nov&amp;#39; THEN revenue ELSE null END) AS Nov_Revenue, MAX(CASE WHEN month = &amp;#39;Dec&amp;#39; THEN revenue ELSE null END) AS Dec_Revenue FROM Department GROUP BY id </description>
    </item>
    <item>
      <title>175. Combine Two Tables</title>
      <link>http://localhost:1313/leetcode/175/</link>
      <pubDate>Wed, 23 Mar 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/175/</guid>
      <description>Combine Two Tables - LeetCode code select firstName, lastName, city, state from Person p left join Address a on p.personId = a.personId </description>
    </item>
    <item>
      <title>176. Second Highest Salary</title>
      <link>http://localhost:1313/leetcode/176/</link>
      <pubDate>Wed, 23 Mar 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/176/</guid>
      <description>Second Highest Salary - LeetCode code mssql select isnull( (select distinct salary as SecondHighestSalary from( select *, dense_rank() over(order by Salary desc) as rnum from Employee) a where rnum=2), null) as SecondHighestSalary code mssql SELECT (SELECT t.Salary FROM (SELECT DISTINCT Salary, DENSE_RANK() OVER (ORDER BY Salary DESC) AS salary_rank FROM Employee ) t WHERE t.salary_rank = 2 ) AS SecondHighestSalary code mysql SELECT (SELECT DISTINCT Salary FROM Employee ORDER BY Salary DESC LIMIT 1 OFFSET 1) AS SecondHighestSalary ; </description>
    </item>
    <item>
      <title>181. Employees Earning More Than Their Managers</title>
      <link>http://localhost:1313/leetcode/181/</link>
      <pubDate>Wed, 23 Mar 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/181/</guid>
      <description>Employees Earning More Than Their Managers - LeetCode&#xA;| id | name | salary | managerId |&#xA;Write an SQL query to find the employees who earn more than their managers.&#xA;code SELECT a.Name AS &amp;#39;Employee&amp;#39; FROM Employee AS a, Employee AS b WHERE a.ManagerId = b.Id AND a.Salary &amp;gt; b.Salary ; code select e1.name as &amp;#34;Employee&amp;#34; from Employee e1 inner join Employee e2 on e1.managerId = e2.id where e1.salary &amp;gt; e2.</description>
    </item>
    <item>
      <title>197. Rising Temperature</title>
      <link>http://localhost:1313/leetcode/197/</link>
      <pubDate>Wed, 23 Mar 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/197/</guid>
      <description>Rising Temperature - LeetCode code select w1.id as &amp;#39;Id&amp;#39; from Weather w1 join Weather w2 on DATEDIFF(dd, w2.recordDate, w1.recordDate) = 1 where w1.temperature &amp;gt; w2.temperature </description>
    </item>
    <item>
      <title>33. Search in Rotated Sorted Array</title>
      <link>http://localhost:1313/leetcode/33-search-rotated-array/</link>
      <pubDate>Wed, 23 Mar 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/33-search-rotated-array/</guid>
      <description>Search in Rotated Sorted Array - LeetCode&#xA;Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand. (i.e., [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2]). You are given a target value to search. If found in the array return its index, otherwise return -1. You may assume no duplicate exists in the array. Your algorithm&amp;rsquo;s runtime complexity must be in the order of O(log n). Example 1: Input: nums = [4,5,6,7,0,1,2], target = 0 Output: 4</description>
    </item>
    <item>
      <title>596. Classes More Than 5 Students</title>
      <link>http://localhost:1313/leetcode/596/</link>
      <pubDate>Wed, 23 Mar 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/596/</guid>
      <description>Classes More Than 5 Students - LeetCode code select class from Courses group by class having count(student) &amp;gt;= 5 code select class from Courses group by class having count(distinct student) &amp;gt;= 5 </description>
    </item>
    <item>
      <title>991. Broken Calculator</title>
      <link>http://localhost:1313/leetcode/991/</link>
      <pubDate>Wed, 23 Mar 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/991/</guid>
      <description>Broken Calculator - LeetCode&#xA;There is a broken calculator that has the integer startValue on its display initially. In one operation, you can:&#xA;multiply the number on display by 2, or subtract 1 from the number on display.Given two integers startValue and target, return __the minimum number of operations needed to display __target__ on the calculator__. Example 1: Input: startValue = 2, target = 3 Output: 2 Explanation: Use double operation and then decrement operation {2 -&amp;gt; 4 -&amp;gt; 3}.</description>
    </item>
    <item>
      <title>127. word ladder</title>
      <link>http://localhost:1313/leetcode/127/</link>
      <pubDate>Tue, 22 Mar 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/127/</guid>
      <description>https://leetcode.com/problems/word-ladder/&#xA;A transformation sequence from word beginWord to word endWord using a dictionary wordList is a sequence of words beginWord -&amp;gt; s1 -&amp;gt; s2 -&amp;gt; &amp;hellip; -&amp;gt; sk such that:&#xA;Every adjacent pair of words differs by a single letter. Every si for 1 &amp;lt;= i &amp;lt;= k is in wordList. Note that beginWord does not need to be in wordList. sk == endWordGiven two words, beginWord and endWord, and a dictionary wordList, return __the **number of words** in the **shortest transformation sequence** from__ beginWord __to__ endWord__, or __0__ if no such sequence exists.</description>
    </item>
    <item>
      <title>1663. Smallest String With A Given Numeric Value</title>
      <link>http://localhost:1313/leetcode/1663/</link>
      <pubDate>Tue, 22 Mar 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/1663/</guid>
      <description>Smallest String With A Given Numeric Value - LeetCode&#xA;The numeric value of a lowercase character is defined as its position (1-indexed) in the alphabet, so the numeric value of a is 1, the numeric value of b is 2, the numeric value of c is 3, and so on. The numeric value of a string consisting of lowercase characters is defined as the sum of its characters&amp;rsquo; numeric values. For example, the numeric value of the string &amp;ldquo;abe&amp;rdquo; is equal to 1 + 2 + 5 = 8.</description>
    </item>
    <item>
      <title>183. Customers Who Never Order</title>
      <link>http://localhost:1313/leetcode/183/</link>
      <pubDate>Tue, 22 Mar 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/183/</guid>
      <description>Customers Who Never Order - LeetCode&#xA;Write an SQL query to report all customers who never order anything. Return the result table in any order.&#xA;Input: Customers table:&#xA;+&amp;mdash;-+&amp;mdash;&amp;mdash;-+&#xA;| id | name |&#xA;+&amp;mdash;-+&amp;mdash;&amp;mdash;-+&#xA;| 1 | Joe |&#xA;| 2 | Henry |&#xA;| 3 | Sam |&#xA;| 4 | Max |&#xA;+&amp;mdash;-+&amp;mdash;&amp;mdash;-+&#xA;Orders table:&#xA;+&amp;mdash;-+&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;+&#xA;| id | customerId |&#xA;+&amp;mdash;-+&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;+&#xA;| 1 | 3 |</description>
    </item>
    <item>
      <title>283. Move Zeroes</title>
      <link>http://localhost:1313/leetcode/283-move-zeros/</link>
      <pubDate>Tue, 22 Mar 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/283-move-zeros/</guid>
      <description>Move Zeroes - LeetCode&#xA;Given an array nums, write a function to move all 0&amp;rsquo;s to the end of it while maintaining the relative order of the non-zero elements. Example: Input: [0,1,0,3,12]Output: [1,3,12,0,0]&#xA;code class Solution: def moveZeroes(self, nums: List[int]) -&amp;gt; None: start = 0 for v in nums: if v != 0: nums[start] = v start += 1 while start &amp;lt; len(nums): nums[start] = 0 start += 1 code class Solution: def moveZeroes(self, nums: List[int]) -&amp;gt; None: start = 0 for i, v in enumerate(nums): if v !</description>
    </item>
    <item>
      <title>29. Divide Two Integers</title>
      <link>http://localhost:1313/leetcode/29-divide-two-integers/</link>
      <pubDate>Tue, 22 Mar 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/29-divide-two-integers/</guid>
      <description>Divide Two Integers - LeetCode&#xA;Given two integers dividend and divisor, divide two integers without using multiplication, division and mod operator. Return the quotient after dividing dividend by divisor. The integer division should truncate toward zero. Example 1: Input: dividend = 10, divisor = 3 Output: 3&#xA;c0 same idea with c1 class Solution: def divide(self, dividend: int, divisor: int) -&amp;gt; int: a , b = dividend, divisor sig = (a &amp;lt; 0) == (b &amp;lt; 0) a, b, res = abs(a), abs(b), 0 while a &amp;gt;= b: x = 0 while a &amp;gt;= b &amp;lt;&amp;lt; (x + 1): x += 1 res += 1 &amp;lt;&amp;lt; x # res+=2**x a -= b &amp;lt;&amp;lt; x # a -= b*(2**x) return min(res if sig else -res, 2**31-1) c1 class Solution: def divide(self, dividend: int, divisor: int) -&amp;gt; int: x , y = dividend, divisor sig = (x &amp;lt; 0) == (y &amp;lt; 0) x,y = abs(x), abs(y) result, power = 0, 32 y_power = y &amp;lt;&amp;lt; power while x &amp;gt;= y: while y_power &amp;gt; x: y_power &amp;gt;&amp;gt;= 1 power -= 1 result += 1 &amp;lt;&amp;lt; power # result += y_power/y x -= y_power # return result return min(result if sig else -result, 2**31-1) </description>
    </item>
    <item>
      <title>410. Split Array Largest Sum</title>
      <link>http://localhost:1313/leetcode/410/</link>
      <pubDate>Tue, 22 Mar 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/410/</guid>
      <description>Split Array Largest Sum - LeetCode&#xA;Given an array nums which consists of non-negative integers and an integer m, you can split the array into m non-empty continuous subarrays. Write an algorithm to minimize the largest sum among these m subarrays.&#xA;Example 1: Input: nums = [7,2,5,10,8], m = 2 Output: 18 Explanation: There are four ways to split nums into two subarrays. The best way is to split it into [7,2,5] and [10,8], where the largest sum among the two subarrays is only 18.</description>
    </item>
    <item>
      <title>1007. Minimum Domino Rotations For Equal Row</title>
      <link>http://localhost:1313/leetcode/1007/</link>
      <pubDate>Mon, 21 Mar 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/1007/</guid>
      <description>Minimum Domino Rotations For Equal Row - LeetCode&#xA;In a row of dominoes, tops[i] and bottoms[i] represent the top and bottom halves of the ith domino. (A domino is a tile with two numbers from 1 to 6 - one on each half of the tile.) We may rotate the ith domino, so that tops[i] and bottoms[i] swap values. Return the minimum number of rotations so that all the values in tops are the same, or all the values in bottoms are the same.</description>
    </item>
    <item>
      <title>895. Maximum Frequency Stack</title>
      <link>http://localhost:1313/leetcode/895/</link>
      <pubDate>Sat, 19 Mar 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/895/</guid>
      <description>Maximum Frequency Stack - LeetCode&#xA;Design a stack-like data structure to push elements to the stack and pop the most frequent element from the stack. Implement the FreqStack class:&#xA;FreqStack() constructs an empty frequency stack. void push(int val) pushes an integer val onto the top of the stack. int pop() removes and returns the most frequent element in the stack. If there is a tie for the most frequent element, the element closest to the stack&#39;s top is removed and returned.</description>
    </item>
    <item>
      <title>316. Remove Duplicate Letters</title>
      <link>http://localhost:1313/leetcode/316/</link>
      <pubDate>Fri, 18 Mar 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/316/</guid>
      <description>Remove Duplicate Letters - LeetCode&#xA;Given a string s, remove duplicate letters so that every letter appears once and only once. You must make sure your result is the smallest in lexicographical order among all possible results.&#xA;Example 1: Input: s = &amp;ldquo;bcabc&amp;rdquo; Output: &amp;ldquo;abc&amp;rdquo; Example 2: Input: s = &amp;ldquo;cbacdcbc&amp;rdquo; Output: &amp;ldquo;acdb&amp;rdquo;&#xA;Constraints:&#xA;1 &amp;lt;= s.length &amp;lt;= 104 s consists of lowercase English letters. code class Solution: def removeDuplicateLetters(self, s: str) -&amp;gt; str: stack = [] seen = set() last_index = {c: i for i, c in enumerate(s)} for i, c in enumerate(s): if c not in seen: while stack and c &amp;lt; stack[-1] and i &amp;lt; last_index[stack[-1]]: seen.</description>
    </item>
    <item>
      <title>378. Kth Smallest Element in a Sorted Matrix</title>
      <link>http://localhost:1313/leetcode/378/</link>
      <pubDate>Thu, 17 Mar 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/378/</guid>
      <description>Kth Smallest Element in a Sorted Matrix - LeetCode&#xA;Given an n x n matrix where each of the rows and columns is sorted in ascending order, return the kth smallest element in the matrix. Note that it is the kth smallest element in the sorted order, not the kth distinct element. You must find a solution with a memory complexity better than O(n2).&#xA;Example 1: Input: matrix = [[1,5,9],[10,11,13],[12,13,15]], k = 8 Output: 13 Explanation: The elements in the matrix are [1,5,9,10,11,12,13,13,15], and the 8th smallest number is 13 Example 2: Input: matrix = [[-5]], k = 1 Output: -5</description>
    </item>
    <item>
      <title>603. Consecutive Available Seats</title>
      <link>http://localhost:1313/leetcode/603/</link>
      <pubDate>Thu, 17 Mar 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/603/</guid>
      <description>Consecutive Available Seats - LeetCode&#xA;Table: Cinema +&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;-+&amp;mdash;&amp;mdash;+ | Column Name | Type | +&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;-+&amp;mdash;&amp;mdash;+ | seat_id | int | | free | bool | +&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;-+&amp;mdash;&amp;mdash;+&#xA;seat_id is an auto-increment primary key column for this table. Each row of this table indicates whether the ith seat is free or not. 1 means free while 0 means occupied.&#xA;Write an SQL query to report all the consecutive available seats in the cinema.</description>
    </item>
    <item>
      <title>543. Diameter of Binary Tree</title>
      <link>http://localhost:1313/leetcode/543/</link>
      <pubDate>Wed, 16 Mar 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/543/</guid>
      <description>Diameter of Binary Tree - LeetCode&#xA;Given the root of a binary tree, return the length of the diameter of the tree. The diameter of a binary tree is the length of the longest path between any two nodes in a tree. This path may or may not pass through the root. The length of a path between two nodes is represented by the number of edges between them.&#xA;Example 1: Input: root = [1,2,3,4,5] Output: 3 Explanation: 3 is the length of the path [4,2,1,3] or [5,2,1,3].</description>
    </item>
    <item>
      <title>763. Partition Labels</title>
      <link>http://localhost:1313/leetcode/763/</link>
      <pubDate>Wed, 16 Mar 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/763/</guid>
      <description>Partition Labels - LeetCode&#xA;You are given a string s. We want to partition the string into as many parts as possible so that each letter appears in at most one part. Return a list of integers representing the size of these parts.&#xA;Example 1: Input: s = &amp;ldquo;ababcbacadefegdehijhklij&amp;rdquo; Output: [9,7,8] Explanation: The partition is &amp;ldquo;ababcbaca&amp;rdquo;, &amp;ldquo;defegde&amp;rdquo;, &amp;ldquo;hijhklij&amp;rdquo;. This is a partition so that each letter appears in at most one part.</description>
    </item>
    <item>
      <title>946. Validate Stack Sequences</title>
      <link>http://localhost:1313/leetcode/946/</link>
      <pubDate>Wed, 16 Mar 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/946/</guid>
      <description>Validate Stack Sequences - LeetCode&#xA;Given two integer arrays pushed and popped each with distinct values, return true__ if this could have been the result of a sequence of push and pop operations on an initially empty stack, or false otherwise.__&#xA;Example 1: Input: pushed = [1,2,3,4,5], popped = [4,5,3,2,1] Output: true Explanation: We might do the following sequence: push(1), push(2), push(3), push(4), pop() -&amp;gt; 4, push(5), pop() -&amp;gt; 5, pop() -&amp;gt; 3, pop() -&amp;gt; 2, pop() -&amp;gt; 1 Example 2: Input: pushed = [1,2,3,4,5], popped = [4,3,5,1,2] Output: false Explanation: 1 cannot be popped before 2.</description>
    </item>
    <item>
      <title>1249. Minimum Remove to Make Valid Parentheses</title>
      <link>http://localhost:1313/leetcode/1249/</link>
      <pubDate>Tue, 15 Mar 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/1249/</guid>
      <description>Minimum Remove to Make Valid Parentheses - LeetCode&#xA;Given a string s of &amp;lsquo;(&amp;rsquo; , &amp;lsquo;)&amp;rsquo; and lowercase English characters. Your task is to remove the minimum number of parentheses ( &amp;lsquo;(&amp;rsquo; or &amp;lsquo;)&amp;rsquo;, in any positions ) so that the resulting parentheses string is valid and return any valid string. Formally, a parentheses string is valid if and only if:&#xA;It is the empty string, contains only lowercase characters, or It can be written as AB (A concatenated with B), where A and B are valid strings, or It can be written as (A), where A is a valid string.</description>
    </item>
    <item>
      <title>71. Simplify Path</title>
      <link>http://localhost:1313/leetcode/71/</link>
      <pubDate>Tue, 15 Mar 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/71/</guid>
      <description>Simplify Path - LeetCode&#xA;Given a string path, which is an absolute path (starting with a slash &amp;lsquo;/&amp;rsquo;) to a file or directory in a Unix-style file system, convert it to the simplified canonical path. In a Unix-style file system, a period &amp;lsquo;.&amp;rsquo; refers to the current directory, a double period &amp;lsquo;..&amp;rsquo; refers to the directory up a level, and any multiple consecutive slashes (i.e. &amp;lsquo;//&amp;rsquo;) are treated as a single slash &amp;lsquo;/&amp;rsquo;.</description>
    </item>
    <item>
      <title>1057. Campus Bikes</title>
      <link>http://localhost:1313/leetcode/1057/</link>
      <pubDate>Sun, 13 Mar 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/1057/</guid>
      <description>Campus Bikes - LeetCode&#xA;On a campus represented on the X-Y plane, there are n workers and m bikes, with n &amp;lt;= m. You are given an array workers of length n where workers[i] = [xi, yi] is the position of the ith worker. You are also given an array bikes of length m where bikes[j] = [xj, yj] is the position of the jth bike. All the given positions are unique.</description>
    </item>
    <item>
      <title>138. Copy list with random pointer</title>
      <link>http://localhost:1313/leetcode/138/</link>
      <pubDate>Sun, 13 Mar 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/138/</guid>
      <description>Copy List with Random Pointer - LeetCode&#xA;A linked list of length n is given such that each node contains an additional random pointer, which could point to any node in the list, or null. Construct a deep copy of the list. The deep copy should consist of exactly n brand new nodes, where each new node has its value set to the value of its corresponding original node. Both the next and random pointer of the new nodes should point to new nodes in the copied list such that the pointers in the original list and copied list represent the same list state.</description>
    </item>
    <item>
      <title>20. Valid Parentheses</title>
      <link>http://localhost:1313/leetcode/20-valid-parentheses/</link>
      <pubDate>Sun, 13 Mar 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/20-valid-parentheses/</guid>
      <description>Valid Parentheses - LeetCode&#xA;Given a string s containing just the characters &amp;lsquo;(&amp;rsquo;, &amp;lsquo;)&amp;rsquo;, &amp;lsquo;{&amp;rsquo;, &amp;lsquo;}&amp;rsquo;, &amp;lsquo;[&amp;rsquo; and &amp;lsquo;]&amp;rsquo;, determine if the input string is valid. An input string is valid if:&#xA;Open brackets must be closed by the same type of brackets. Open brackets must be closed in the correct order. Example 1: Input: s = &amp;ldquo;()&amp;rdquo; Output: true Example 2: Input: s = &amp;ldquo;()[]{}&amp;rdquo; Output: true Example 3: Input: s = &amp;ldquo;(]&amp;rdquo; Output: false</description>
    </item>
    <item>
      <title>2. Add Two Numbers</title>
      <link>http://localhost:1313/leetcode/2-add-two-numbers/</link>
      <pubDate>Thu, 10 Mar 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/2-add-two-numbers/</guid>
      <description>https://leetcode.com/problems/add-two-numbers/&#xA;You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself. Example: Input: (2 -&amp;gt; 4 -&amp;gt; 3) + (5 -&amp;gt; 6 -&amp;gt; 4) Output: 7 -&amp;gt; 0 -&amp;gt; 8 Explanation: 342 + 465 = 807.</description>
    </item>
    <item>
      <title>247. Strobogrammatic Number II</title>
      <link>http://localhost:1313/leetcode/247/</link>
      <pubDate>Wed, 09 Mar 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/247/</guid>
      <description>https://leetcode.com/problems/strobogrammatic-number-ii/&#xA;Given an integer n, return all the strobogrammatic numbers that are of length n. You may return the answer in any order. A strobogrammatic number is a number that looks the same when rotated 180 degrees (looked at upside down).&#xA;Example 1: Input: n = 2 Output: [&amp;ldquo;11&amp;rdquo;,&amp;ldquo;69&amp;rdquo;,&amp;ldquo;88&amp;rdquo;,&amp;ldquo;96&amp;rdquo;] Example 2: Input: n = 1 Output: [&amp;ldquo;0&amp;rdquo;,&amp;ldquo;1&amp;rdquo;,&amp;ldquo;8&amp;rdquo;]&#xA;Constraints:&#xA;1 &amp;lt;= n &amp;lt;= 14&#xA;code class Solution: def findStrobogrammatic(self, n: int) -&amp;gt; List[str]: if n == 1: return [&amp;#39;0&amp;#39;,&amp;#39;1&amp;#39;,&amp;#39;8&amp;#39;] res = [] dic = {&amp;#39;6&amp;#39;:&amp;#39;9&amp;#39;,&amp;#39;9&amp;#39;:&amp;#39;6&amp;#39;,&amp;#39;0&amp;#39;:&amp;#39;0&amp;#39;,&amp;#39;1&amp;#39;:&amp;#39;1&amp;#39;,&amp;#39;8&amp;#39;:&amp;#39;8&amp;#39;} def backtracking(left, path): if left &amp;lt; 0: return if left == 0: res.</description>
    </item>
    <item>
      <title>82. Remove Duplicates from Sorted List II</title>
      <link>http://localhost:1313/leetcode/82/</link>
      <pubDate>Wed, 09 Mar 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/82/</guid>
      <description>Given the head of a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list. Return the linked list sorted as well.&#xA;Example 1: Input: head = [1,2,3,3,4,4,5] Output: [1,2,5] Example 2: Input: head = [1,1,1,2,3] Output: [2,3]&#xA;Constraints:&#xA;The number of nodes in the list is in the range [0, 300]. -100 &amp;lt;= Node.val &amp;lt;= 100 The list is guaranteed to be **sorted** in ascending order.</description>
    </item>
    <item>
      <title>1359. Count All Valid Pickup and Delivery Options</title>
      <link>http://localhost:1313/leetcode/1359/</link>
      <pubDate>Sun, 06 Mar 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/1359/</guid>
      <description>Count All Valid Pickup and Delivery Options - LeetCode&#xA;Given n orders, each order consist in pickup and delivery services. Count all valid pickup/delivery possible sequences such that delivery(i) is always after of pickup(i). Since the answer may be too large, return it modulo 10^9 + 7.&#xA;Example 1: Input: n = 1 Output: 1 Explanation: Unique order (P1, D1), Delivery 1 always is after of Pickup 1. Example 2: Input: n = 2 Output: 6 Explanation: All possible orders: (P1,P2,D1,D2), (P1,P2,D2,D1), (P1,D1,P2,D2), (P2,P1,D1,D2), (P2,P1,D2,D1) and (P2,D2,P1,D1).</description>
    </item>
    <item>
      <title>799. Champagne Tower</title>
      <link>http://localhost:1313/leetcode/799/</link>
      <pubDate>Fri, 04 Mar 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/799/</guid>
      <description>Champagne Tower - LeetCode&#xA;We stack glasses in a pyramid, where the first row has 1 glass, the second row has 2 glasses, and so on until the 100th row. Each glass holds one cup of champagne. Then, some champagne is poured into the first glass at the top. When the topmost glass is full, any excess liquid poured will fall equally to the glass immediately to the left and right of it.</description>
    </item>
    <item>
      <title>1490. Clone N-ary Tree</title>
      <link>http://localhost:1313/leetcode/1490/</link>
      <pubDate>Thu, 03 Mar 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/1490/</guid>
      <description>Clone N-ary Tree - LeetCode&#xA;Given a root of an N-ary tree, return a deep copy (clone) of the tree. Each node in the n-ary tree contains a val (int) and a list (List[Node]) of its children. class Node { public int val; public List children; } Nary-Tree input serialization is represented in their level order traversal, each group of children is separated by the null value (See examples).&#xA;Example 1: Input: root = [1,null,3,2,4,null,5,6] Output: [1,null,3,2,4,null,5,6] Example 2: Input: root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14] Output: [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]</description>
    </item>
    <item>
      <title>413. Arithmetic Slices</title>
      <link>http://localhost:1313/leetcode/413/</link>
      <pubDate>Thu, 03 Mar 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/413/</guid>
      <description>Arithmetic Slices - LeetCode&#xA;An integer array is called arithmetic if it consists of at least three elements and if the difference between any two consecutive elements is the same.&#xA;For example, [1,3,5,7,9], [7,7,7,7], and [3,-1,-5,-9] are arithmetic sequences.Given an integer array nums, return __the number of arithmetic subarrays of__ nums. A subarray is a contiguous subsequence of the array.&#xA;Example 1: Input: nums = [1,2,3,4] Output: 3 Explanation: We have 3 arithmetic slices in nums: [1, 2, 3], [2, 3, 4] and [1,2,3,4] itself.</description>
    </item>
    <item>
      <title>61. Rotate list</title>
      <link>http://localhost:1313/leetcode/61/</link>
      <pubDate>Thu, 03 Mar 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/61/</guid>
      <description>Rotate List - LeetCode&#xA;Given the head of a linked list, rotate the list to the right by k places.&#xA;Example 1: Input: head = [1,2,3,4,5], k = 2 Output: [4,5,1,2,3] Example 2: Input: head = [0,1,2], k = 4 Output: [2,0,1]&#xA;Constraints:&#xA;The number of nodes in the list is in the range [0, 500]. -100 &amp;lt;= Node.val &amp;lt;= 100 0 &amp;lt;= k &amp;lt;= 2 * 109 code class Solution: def rotateRight(self, head: ListNode, k: int) -&amp;gt; ListNode: if not head: return None run_count = head count = 1 while run_count and run_count.</description>
    </item>
    <item>
      <title>797. All Paths From Source to Target</title>
      <link>http://localhost:1313/leetcode/797/</link>
      <pubDate>Thu, 03 Mar 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/797/</guid>
      <description>All Paths From Source to Target - LeetCode&#xA;Given a directed acyclic graph (DAG) of n nodes labeled from 0 to n - 1, find all possible paths from node 0 to node n - 1 and return them in any order. The graph is given as follows: graph[i] is a list of all nodes you can visit from node i (i.e., there is a directed edge from node i to node graph[i][j]).</description>
    </item>
    <item>
      <title>239. Sliding Window Maximum</title>
      <link>http://localhost:1313/leetcode/239/</link>
      <pubDate>Tue, 01 Mar 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/239/</guid>
      <description>You are given an array of integers nums, there is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position. Return the max sliding window.&#xA;Example 1: Input: nums = [1,3,-1,-3,5,3,6,7], k = 3 Output: [3,3,5,5,6,7] Explanation: Window position Max &amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash; &amp;mdash;&amp;ndash; [1 3 -1] -3 5 3 6 7 3 1 [3 -1 -3] 5 3 6 7 3 1 3 [-1 -3 5] 3 6 7 5 1 3 -1 [-3 5 3] 6 7 5 1 3 -1 -3 [5 3 6] 7 6 1 3 -1 -3 5 [3 6 7] 7 Example 2: Input: nums = [1], k = 1 Output: [1]</description>
    </item>
    <item>
      <title>338. Counting Bits</title>
      <link>http://localhost:1313/leetcode/338/</link>
      <pubDate>Tue, 01 Mar 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/338/</guid>
      <description>Counting Bits - LeetCode&#xA;Given an integer n, return __an array ans of length n + 1 such that for each i (0 &amp;lt;= i &amp;lt;= n), ans[i] is the number of 1&amp;rsquo;s in the binary representation of __i.&#xA;Example 1: Input: n = 2 Output: [0,1,1] Explanation: 0 &amp;ndash;&amp;gt; 0 1 &amp;ndash;&amp;gt; 1 2 &amp;ndash;&amp;gt; 10 Example 2: Input: n = 5 Output: [0,1,1,2,1,2] Explanation: 0 &amp;ndash;&amp;gt; 0 1 &amp;ndash;&amp;gt; 1 2 &amp;ndash;&amp;gt; 10 3 &amp;ndash;&amp;gt; 11 4 &amp;ndash;&amp;gt; 100 5 &amp;ndash;&amp;gt; 101</description>
    </item>
    <item>
      <title>228. Summary Ranges</title>
      <link>http://localhost:1313/leetcode/228/</link>
      <pubDate>Mon, 28 Feb 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/228/</guid>
      <description>Summary Ranges - LeetCode&#xA;You are given a sorted unique integer array nums. Return the smallest sorted list of ranges that cover all the numbers in the array exactly. That is, each element of nums is covered by exactly one of the ranges, and there is no integer x such that x is in one of the ranges but not in nums. Each range [a,b] in the list should be output as:</description>
    </item>
    <item>
      <title>662. Maximum Width of Binary Tree</title>
      <link>http://localhost:1313/leetcode/662/</link>
      <pubDate>Sun, 27 Feb 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/662/</guid>
      <description>Maximum Width of Binary Tree - LeetCode&#xA;Given the root of a binary tree, return the maximum width of the given tree. The maximum width of a tree is the maximum width among all levels. The width of one level is defined as the length between the end-nodes (the leftmost and rightmost non-null nodes), where the null nodes between the end-nodes are also counted into the length calculation. It is guaranteed that the answer will in the range of 32-bit signed integer.</description>
    </item>
    <item>
      <title>148. Sort List</title>
      <link>http://localhost:1313/leetcode/148/</link>
      <pubDate>Sat, 26 Feb 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/148/</guid>
      <description>Sort List - LeetCode&#xA;Given the head of a linked list, return the list after sorting it in ascending order.&#xA;Example 1: Input: head = [4,2,1,3] Output: [1,2,3,4] Example 2: Input: head = [-1,5,3,4,0] Output: [-1,0,3,4,5] Example 3: Input: head = [] Output: []&#xA;Constraints:&#xA;The number of nodes in the list is in the range [0, 5 * 104]. -105 &amp;lt;= Node.val &amp;lt;= 105 code #mergeSort # Definition for singly-linked list.</description>
    </item>
    <item>
      <title>165. Compare Version Numbers</title>
      <link>http://localhost:1313/leetcode/165/</link>
      <pubDate>Sat, 26 Feb 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/165/</guid>
      <description>Compare Version Numbers - LeetCode&#xA;Given two version numbers, version1 and version2, compare them. Version numbers consist of one or more revisions joined by a dot &amp;lsquo;.&amp;rsquo;. Each revision consists of digits and may contain leading zeros. Every revision contains at least one character. Revisions are 0-indexed from left to right, with the leftmost revision being revision 0, the next revision being revision 1, and so on. For example 2.5.33 and 0.</description>
    </item>
    <item>
      <title>692. Top K Frequent Words</title>
      <link>http://localhost:1313/leetcode/692/</link>
      <pubDate>Sat, 26 Feb 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/692/</guid>
      <description>Top K Frequent Words - LeetCode&#xA;Given an array of strings words and an integer k, return the k most frequent strings. Return the answer sorted by the frequency from highest to lowest. Sort the words with the same frequency by their lexicographical order.&#xA;Example 1: Input: words = [&amp;ldquo;i&amp;rdquo;,&amp;ldquo;love&amp;rdquo;,&amp;ldquo;leetcode&amp;rdquo;,&amp;ldquo;i&amp;rdquo;,&amp;ldquo;love&amp;rdquo;,&amp;ldquo;coding&amp;rdquo;], k = 2 Output: [&amp;ldquo;i&amp;rdquo;,&amp;ldquo;love&amp;rdquo;] Explanation: &amp;ldquo;i&amp;rdquo; and &amp;ldquo;love&amp;rdquo; are the two most frequent words. Note that &amp;ldquo;i&amp;rdquo; comes before &amp;ldquo;love&amp;rdquo; due to a lower alphabetical order.</description>
    </item>
    <item>
      <title>847. Shortest Path Visiting All Nodes</title>
      <link>http://localhost:1313/leetcode/847/</link>
      <pubDate>Sat, 26 Feb 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/847/</guid>
      <description>Shortest Path Visiting All Nodes - LeetCode&#xA;You have an undirected, connected graph of n nodes labeled from 0 to n - 1. You are given an array graph where graph[i] is a list of all the nodes connected with node i by an edge. Return the length of the shortest path that visits every node. You may start and stop at any node, you may revisit nodes multiple times, and you may reuse edges.</description>
    </item>
    <item>
      <title>856. Score of Parentheses</title>
      <link>http://localhost:1313/leetcode/856/</link>
      <pubDate>Sat, 26 Feb 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/856/</guid>
      <description>Score of Parentheses - LeetCode&#xA;Given a balanced parentheses string s, return the score of the string. The score of a balanced parentheses string is based on the following rule:&#xA;&amp;quot;()&amp;quot; has score 1. AB has score A + B, where A and B are balanced parentheses strings. (A) has score 2 * A, where A is a balanced parentheses string. Example 1: Input: s = &amp;ldquo;()&amp;rdquo; Output: 1 Example 2: Input: s = &amp;ldquo;(())&amp;rdquo; Output: 2 Example 3: Input: s = &amp;ldquo;()()&amp;rdquo; Output: 2</description>
    </item>
    <item>
      <title>171. Excel Sheet Column Number</title>
      <link>http://localhost:1313/leetcode/171-excel-sheet-column-number/</link>
      <pubDate>Tue, 22 Feb 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/171-excel-sheet-column-number/</guid>
      <description>Excel Sheet Column Number - LeetCode&#xA;Given a string columnTitle that represents the column title as appear in an Excel sheet, return its corresponding column number. For example: A -&amp;gt; 1 B -&amp;gt; 2 C -&amp;gt; 3 &amp;hellip; Z -&amp;gt; 26 AA -&amp;gt; 27 AB -&amp;gt; 28 &amp;hellip;&#xA;Example 1: Input: columnTitle = &amp;ldquo;A&amp;rdquo; Output: 1 Example 2: Input: columnTitle = &amp;ldquo;AB&amp;rdquo; Output: 28 Example 3: Input: columnTitle = &amp;ldquo;ZY&amp;rdquo; Output: 701</description>
    </item>
    <item>
      <title>1288. Remove Covered Intervals</title>
      <link>http://localhost:1313/leetcode/1288/</link>
      <pubDate>Sun, 20 Feb 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/1288/</guid>
      <description>Remove Covered Intervals - LeetCode&#xA;Given an array intervals where intervals[i] = [li, ri] represent the interval [li, ri), remove all intervals that are covered by another interval in the list. The interval [a, b) is covered by the interval [c, d) if and only if c &amp;lt;= a and b &amp;lt;= d. Return the number of remaining intervals.&#xA;Example 1: Input: intervals = [[1,4],[3,6],[2,8]] Output: 2 Explanation: Interval [3,6] is covered by [2,8], therefore it is removed.</description>
    </item>
    <item>
      <title>1064. Fixed Point </title>
      <link>http://localhost:1313/leetcode/1064/</link>
      <pubDate>Fri, 18 Feb 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/1064/</guid>
      <description>Fixed Point - LeetCode&#xA;Given an array of distinct integers arr, where arr is sorted in ascending order, return the smallest index i that satisfies arr[i] == i. If there is no such index, return -1.&#xA;Example 1: Input: arr = [-10,-5,0,3,7] Output: 3 Explanation: For the given array, arr[0] = -10, arr[1] = -5, arr[2] = 0, arr[3] = 3, thus the output is 3. Example 2: Input: arr = [0,2,5,8,17] Output: 0 Explanation: arr[0] = 0, thus the output is 0.</description>
    </item>
    <item>
      <title>402. Remove K Digits</title>
      <link>http://localhost:1313/leetcode/402/</link>
      <pubDate>Fri, 18 Feb 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/402/</guid>
      <description>Remove K Digits - LeetCode&#xA;Given string num representing a non-negative integer num, and an integer k, return the smallest possible integer after removing k digits from num.&#xA;Example 1: Input: num = &amp;ldquo;1432219&amp;rdquo;, k = 3 Output: &amp;ldquo;1219&amp;rdquo; Explanation: Remove the three digits 4, 3, and 2 to form the new number 1219 which is the smallest. Example 2: Input: num = &amp;ldquo;10200&amp;rdquo;, k = 1 Output: &amp;ldquo;200&amp;rdquo; Explanation: Remove the leading 1 and the number is 200.</description>
    </item>
    <item>
      <title>739. Daily temperatures</title>
      <link>http://localhost:1313/leetcode/739/</link>
      <pubDate>Fri, 18 Feb 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/739/</guid>
      <description>Daily Temperatures - LeetCode&#xA;Given a list of daily temperatures temperatures, return a list such that, for each day in the input, tells you how many days you would have to wait until a warmer temperature. If there is no future day for which this is possible, put 0 instead. For example, given the list of temperatures temperatures = [73, 74, 75, 71, 69, 72, 76, 73], your output should be [1, 1, 4, 2, 1, 1, 0, 0].</description>
    </item>
    <item>
      <title>39. Combination sum</title>
      <link>http://localhost:1313/leetcode/39/</link>
      <pubDate>Thu, 17 Feb 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/39/</guid>
      <description>Combination Sum - LeetCode&#xA;Given an array of distinct integers candidates and a target integer target, return a list of all unique combinations of candidates where the chosen numbers sum to target. You may return the combinations in any order. The same number may be chosen from candidates an unlimited number of times. Two combinations are unique if the frequency of at least one of the chosen numbers is different. It is guaranteed that the number of unique combinations that sum up to target is less than 150 combinations for the given input.</description>
    </item>
    <item>
      <title>24. Swap nodes in pairs</title>
      <link>http://localhost:1313/leetcode/24/</link>
      <pubDate>Wed, 16 Feb 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/24/</guid>
      <description>Given a linked list, swap every two adjacent nodes and return its head. You must solve the problem without modifying the values in the list&amp;rsquo;s nodes (i.e., only nodes themselves may be changed.)&#xA;Example 1: Input: head = [1,2,3,4] Output: [2,1,4,3]&#xA;code class Solution: def swapPairs(self, head): res = pre = ListNode() pre.next = head while pre.next and pre.next.next: first = pre.next second = pre.next.next pre.next, second.next, first.next = second, first, second.</description>
    </item>
    <item>
      <title>136. Single Number</title>
      <link>http://localhost:1313/leetcode/136-single-number/</link>
      <pubDate>Tue, 15 Feb 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/136-single-number/</guid>
      <description>Single Number - LeetCode&#xA;Given a non-empty array of integers nums, every element appears twice except for one. Find that single one. You must implement a solution with a linear runtime complexity and use only constant extra space.&#xA;Example 1: Input: nums = [2,2,1] Output: 1 Example 2: Input: nums = [4,1,2,1,2] Output: 4 Example 3: Input: nums = [1] Output: 1&#xA;Constraints:&#xA;1 &amp;lt;= nums.length &amp;lt;= 3 * 104 -3 * 104 &amp;lt;= nums[i] &amp;lt;= 3 * 104 Each element in the array appears twice except for one element which appears only once.</description>
    </item>
    <item>
      <title>225. Implement Stack using Queues</title>
      <link>http://localhost:1313/leetcode/225/</link>
      <pubDate>Tue, 15 Feb 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/225/</guid>
      <description>Implement Stack using Queues - LeetCode&#xA;Implement a last in first out (LIFO) stack using only two queues. The implemented stack should support all the functions of a normal queue (push, top, pop, and empty). Implement the MyStack class:&#xA;void push(int x) Pushes element x to the top of the stack. int pop() Removes the element on the top of the stack and returns it. int top() Returns the element on the top of the stack.</description>
    </item>
    <item>
      <title>232. Implement queue using stacks</title>
      <link>http://localhost:1313/leetcode/232/</link>
      <pubDate>Tue, 15 Feb 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/232/</guid>
      <description>Implement Queue using Stacks - LeetCode&#xA;Implement a first in first out (FIFO) queue using only two stacks. The implemented queue should support all the functions of a normal queue (push, peek, pop, and empty). Implement the MyQueue class:&#xA;void push(int x) Pushes element x to the back of the queue. int pop() Removes the element from the front of the queue and returns it. int peek() Returns the element at the front of the queue.</description>
    </item>
    <item>
      <title>104. Maximum Depth of Binary Tree</title>
      <link>http://localhost:1313/leetcode/104-maximum-depth-of-binary-tree/</link>
      <pubDate>Mon, 14 Feb 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/104-maximum-depth-of-binary-tree/</guid>
      <description>Maximum Depth of Binary Tree - LeetCode&#xA;Given the root of a binary tree, return its maximum depth. A binary tree&amp;rsquo;s maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.&#xA;Example 1: Input: root = [3,9,20,null,null,15,7] Output: 3 Example 2: Input: root = [1,null,2] Output: 2&#xA;Constraints:&#xA;The number of nodes in the tree is in the range [0, 104].</description>
    </item>
    <item>
      <title>1143. Longest Common Subsequence</title>
      <link>http://localhost:1313/leetcode/1143/</link>
      <pubDate>Mon, 14 Feb 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/1143/</guid>
      <description>Longest Common Subsequence - LeetCode&#xA;Given two strings text1 and text2, return __the length of their longest common subsequence. __If there is no common subsequence, return 0. A subsequence of a string is a new string generated from the original string with some characters (can be none) deleted without changing the relative order of the remaining characters.&#xA;For example, &amp;quot;ace&amp;quot; is a subsequence of &amp;quot;abcde&amp;quot;.A common subsequence of two strings is a subsequence that is common to both strings.</description>
    </item>
    <item>
      <title>567. Permutation in String</title>
      <link>http://localhost:1313/leetcode/567/</link>
      <pubDate>Fri, 11 Feb 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/567/</guid>
      <description>Permutation in String - LeetCode&#xA;Given two strings s1 and s2, return true__ if s2 contains a permutation of s1, or false otherwise__. In other words, return true if one of s1&amp;rsquo;s permutations is the substring of s2.&#xA;Example 1: Input: s1 = &amp;ldquo;ab&amp;rdquo;, s2 = &amp;ldquo;eidbaooo&amp;rdquo; Output: true Explanation: s2 contains one permutation of s1 (&amp;ldquo;ba&amp;rdquo;). Example 2: Input: s1 = &amp;ldquo;ab&amp;rdquo;, s2 = &amp;ldquo;eidboaoo&amp;rdquo; Output: false&#xA;Constraints:&#xA;1 &amp;lt;= s1.</description>
    </item>
    <item>
      <title>714. Best Time to Buy and Sell Stock with Transaction Fee</title>
      <link>http://localhost:1313/leetcode/714/</link>
      <pubDate>Fri, 11 Feb 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/714/</guid>
      <description>Best Time to Buy and Sell Stock with Transaction Fee - LeetCode&#xA;You are given an array prices where prices[i] is the price of a given stock on the ith day, and an integer fee representing a transaction fee. Find the maximum profit you can achieve. You may complete as many transactions as you like, but you need to pay the transaction fee for each transaction. Note: You may not engage in multiple transactions simultaneously (i.</description>
    </item>
    <item>
      <title>1274. Number of Ships in a Rectangle</title>
      <link>http://localhost:1313/leetcode/1274/</link>
      <pubDate>Thu, 10 Feb 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/1274/</guid>
      <description>Number of Ships in a Rectangle - LeetCode&#xA;(This problem is an interactive problem.) Each ship is located at an integer point on the sea represented by a cartesian plane, and each integer point may contain at most 1 ship. You have a function Sea.hasShips(topRight, bottomLeft) which takes two points as arguments and returns true If there is at least one ship in the rectangle represented by the two points, including on the boundary.</description>
    </item>
    <item>
      <title>560. Subarray Sum Equals K</title>
      <link>http://localhost:1313/leetcode/560/</link>
      <pubDate>Thu, 10 Feb 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/560/</guid>
      <description>Subarray Sum Equals K - LeetCode&#xA;Given an array of integers nums and an integer k, return the total number of continuous subarrays whose sum equals to k.&#xA;Example 1: Input: nums = [1,1,1], k = 2 Output: 2 Example 2: Input: nums = [1,2,3], k = 3 Output: 2&#xA;Constraints:&#xA;1 &amp;lt;= nums.length &amp;lt;= 2 * 104 -1000 &amp;lt;= nums[i] &amp;lt;= 1000 -107 &amp;lt;= k &amp;lt;= 107 code TLE $$O(n^2)$$ class Solution: def subarraySum(self, nums: List[int], k: int) -&amp;gt; int: c = 0 memo = {} memo[-1] = 0 for i in range(len(nums)): memo[i] = memo[i-1] + nums[i] for i in range(-1, len(nums)): for j in range(i+1, len(nums)): if (memo[j] - memo[i]) == k: c += 1 return c code O(n) class Solution: def subarraySum(self, nums: List[int], k: int) -&amp;gt; int: res = 0 memo = defaultdict(int) memo[0] = 1 # sum 0.</description>
    </item>
    <item>
      <title>650. 2 Keys Keyboard </title>
      <link>http://localhost:1313/leetcode/650/</link>
      <pubDate>Thu, 10 Feb 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/650/</guid>
      <description>2 Keys Keyboard - LeetCode&#xA;There is only one character &amp;lsquo;A&amp;rsquo; on the screen of a notepad. You can perform two operations on this notepad for each step:&#xA;Copy All: You can copy all the characters present on the screen (a partial copy is not allowed). Paste: You can paste the characters which are copied last time.Given an integer n, return __the minimum number of operations to get the character__ &#39;A&#39; __exactly__ n __times on the screen__.</description>
    </item>
    <item>
      <title>532. K-diff Pairs in an Array</title>
      <link>http://localhost:1313/leetcode/532/</link>
      <pubDate>Wed, 09 Feb 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/532/</guid>
      <description>K-diff Pairs in an Array - LeetCode&#xA;Given an array of integers nums and an integer k, return the number of unique k-diff pairs in the array. A k-diff pair is an integer pair (nums[i], nums[j]), where the following are true:&#xA;0 &amp;lt;= i &amp;lt; j &amp;lt; nums.length |nums[i] - nums[j]| == kNotice that |val| denotes the absolute value of val. Example 1: Input: nums = [3,1,4,1,5], k = 2 Output: 2 Explanation: There are two 2-diff pairs in the array, (1, 3) and (3, 5).</description>
    </item>
    <item>
      <title>258. Add Digits</title>
      <link>http://localhost:1313/leetcode/258/</link>
      <pubDate>Tue, 08 Feb 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/258/</guid>
      <description>Add Digits - LeetCode&#xA;Given an integer num, repeatedly add all its digits until the result has only one digit, and return it.&#xA;Example 1: Input: num = 38 Output: 2 Explanation: The process is 38 &amp;ndash;&amp;gt; 3 + 8 &amp;ndash;&amp;gt; 11 11 &amp;ndash;&amp;gt; 1 + 1 &amp;ndash;&amp;gt; 2 Since 2 has only one digit, return it. Example 2: Input: num = 0 Output: 0&#xA;Constraints:&#xA;0 &amp;lt;= num &amp;lt;= 231 - 1 code class Solution: def addDigits(self, num: int) -&amp;gt; int: res = str(num) while int(res) &amp;gt;= 10: nres = 0 for v in str(res): nres += int(v) res = nres return res code class Solution: def addDigits(self, num: int) -&amp;gt; int: res = 0 while num &amp;gt; 0: res += num % 10 num //= 10 if num == 0 and res &amp;gt; 9: num, res = res, 0 return res code class Solution: def addDigits(self, num: int) -&amp;gt; int: if num == 0: return 0 if num % 9 == 0: return 9 return num % 9 </description>
    </item>
    <item>
      <title>91. Decode Ways</title>
      <link>http://localhost:1313/leetcode/91/</link>
      <pubDate>Tue, 08 Feb 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/91/</guid>
      <description>Decode Ways - LeetCode&#xA;A message containing letters from A-Z can be encoded into numbers using the following mapping: &amp;lsquo;A&amp;rsquo; -&amp;gt; &amp;ldquo;1&amp;rdquo; &amp;lsquo;B&amp;rsquo; -&amp;gt; &amp;ldquo;2&amp;rdquo; &amp;hellip; &amp;lsquo;Z&amp;rsquo; -&amp;gt; &amp;ldquo;26&amp;rdquo; To decode an encoded message, all the digits must be grouped then mapped back into letters using the reverse of the mapping above (there may be multiple ways). For example, &amp;ldquo;11106&amp;rdquo; can be mapped into:&#xA;&amp;quot;AAJF&amp;quot; with the grouping (1 1 10 6) &amp;quot;KJF&amp;quot; with the grouping (11 10 6)Note that the grouping (1 11 06) is invalid because &amp;quot;06&amp;quot; cannot be mapped into &#39;F&#39; since &amp;quot;6&amp;quot; is different from &amp;quot;06&amp;quot;.</description>
    </item>
    <item>
      <title>389. Find the Difference</title>
      <link>http://localhost:1313/leetcode/389/</link>
      <pubDate>Mon, 07 Feb 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/389/</guid>
      <description>Find the Difference - LeetCode&#xA;You are given two strings s and t. String t is generated by random shuffling string s and then add one more letter at a random position. Return the letter that was added to t.&#xA;Example 1: Input: s = &amp;ldquo;abcd&amp;rdquo;, t = &amp;ldquo;abcde&amp;rdquo; Output: &amp;ldquo;e&amp;rdquo; Explanation: &amp;rsquo;e&amp;rsquo; is the letter that was added. Example 2: Input: s = &amp;ldquo;&amp;rdquo;, t = &amp;ldquo;y&amp;rdquo; Output: &amp;ldquo;y&amp;rdquo;</description>
    </item>
    <item>
      <title>416. Partition Equal Subset Sum</title>
      <link>http://localhost:1313/leetcode/416/</link>
      <pubDate>Mon, 07 Feb 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/416/</guid>
      <description>Partition Equal Subset Sum - LeetCode&#xA;Given a non-empty array nums containing only positive integers, find if the array can be partitioned into two subsets such that the sum of elements in both subsets is equal.&#xA;Example 1: Input: nums = [1,5,11,5] Output: true Explanation: The array can be partitioned as [1, 5, 5] and [11].&#xA;Example 2: Input: nums = [1,2,3,5] Output: false Explanation: The array cannot be partitioned into equal sum subsets.</description>
    </item>
    <item>
      <title>23. Merge k Sorted Lists</title>
      <link>http://localhost:1313/leetcode/23/</link>
      <pubDate>Sat, 05 Feb 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/23/</guid>
      <description>Merge k Sorted Lists - LeetCode&#xA;You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it.&#xA;Example 1: Input: lists = [[1,4,5],[1,3,4],[2,6]] Output: [1,1,2,3,4,4,5,6] Explanation: The linked-lists are: [ 1-&amp;gt;4-&amp;gt;5, 1-&amp;gt;3-&amp;gt;4, 2-&amp;gt;6 ] merging them into one sorted list: 1-&amp;gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;4-&amp;gt;5-&amp;gt;6 Example 2: Input: lists = [] Output: [] Example 3: Input: lists = [[]] Output: []</description>
    </item>
    <item>
      <title>525. Contiguous Array</title>
      <link>http://localhost:1313/leetcode/525/</link>
      <pubDate>Fri, 04 Feb 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/525/</guid>
      <description>Contiguous Array - LeetCode&#xA;Given a binary array nums, return __the maximum length of a contiguous subarray with an equal number of 0 and __1.&#xA;Example 1: Input: nums = [0,1] Output: 2 Explanation: [0, 1] is the longest contiguous subarray with an equal number of 0 and 1. Example 2: Input: nums = [0,1,0] Output: 2 Explanation: [0, 1] (or [1, 0]) is a longest contiguous subarray with equal number of 0 and 1.</description>
    </item>
    <item>
      <title>454. 4Sum II</title>
      <link>http://localhost:1313/leetcode/454/</link>
      <pubDate>Thu, 03 Feb 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/454/</guid>
      <description>4Sum II - LeetCode&#xA;Given four integer arrays nums1, nums2, nums3, and nums4 all of length n, return the number of tuples (i, j, k, l) such that:&#xA;0 &amp;lt;= i, j, k, l &amp;lt; n nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0&#xA;Example 1: Input: nums1 = [1,2], nums2 = [-2,-1], nums3 = [-1,2], nums4 = [0,2] Output: 2 Explanation: The two tuples are: 1. (0, 0, 0, 1) -&amp;gt; nums1[0] + nums2[0] + nums3[0] + nums4[1] = 1 + (-2) + (-1) + 2 = 0 2.</description>
    </item>
    <item>
      <title>438. Find All Anagrams in a String</title>
      <link>http://localhost:1313/leetcode/438/</link>
      <pubDate>Wed, 02 Feb 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/438/</guid>
      <description>Find All Anagrams in a String - LeetCode&#xA;Given two strings s and p, return __an array of all the start indices of p&amp;rsquo;s anagrams in __s. You may return the answer in any order. An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.&#xA;Example 1: Input: s = &amp;ldquo;cbaebabacd&amp;rdquo;, p = &amp;ldquo;abc&amp;rdquo; Output: [0,6] Explanation: The substring with start index = 0 is &amp;ldquo;cba&amp;rdquo;, which is an anagram of &amp;ldquo;abc&amp;rdquo;.</description>
    </item>
    <item>
      <title>249. Group Shifted Strings</title>
      <link>http://localhost:1313/leetcode/249/</link>
      <pubDate>Sat, 29 Jan 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/249/</guid>
      <description>Group Shifted Strings - LeetCode&#xA;We can shift a string by shifting each of its letters to its successive letter.&#xA;For example, &amp;ldquo;abc&amp;rdquo; can be shifted to be &amp;ldquo;bcd&amp;rdquo;.We can keep shifting the string to form a sequence.&#xA;For example, we can keep shifting &amp;ldquo;abc&amp;rdquo; to form the sequence: &amp;ldquo;abc&amp;rdquo; -&amp;gt; &amp;ldquo;bcd&amp;rdquo; -&amp;gt; &amp;hellip; -&amp;gt; &amp;ldquo;xyz&amp;rdquo;.Given an array of strings strings, group all strings[i] that belong to the same shifting sequence.</description>
    </item>
    <item>
      <title>84. Largest Rectangle in Histogram</title>
      <link>http://localhost:1313/leetcode/84/</link>
      <pubDate>Sat, 29 Jan 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/84/</guid>
      <description>Largest Rectangle in Histogram - LeetCode&#xA;Given an array of integers heights representing the histogram&amp;rsquo;s bar height where the width of each bar is 1, return the area of the largest rectangle in the histogram.&#xA;Example 1: Input: heights = [2,1,5,6,2,3] Output: 10 Explanation: The above is a histogram where width of each bar is 1. The largest rectangle is shown in the red area, which has an area = 10 units.</description>
    </item>
    <item>
      <title>211. Design Add and Search Words Data Structure </title>
      <link>http://localhost:1313/leetcode/211/</link>
      <pubDate>Fri, 28 Jan 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/211/</guid>
      <description>Design Add and Search Words Data Structure - LeetCode&#xA;Design a data structure that supports adding new words and finding if a string matches any previously added string. Implement the WordDictionary class:&#xA;WordDictionary() Initializes the object. void addWord(word) Adds word to the data structure, it can be matched later. bool search(word) Returns true if there is any string in the data structure that matches word or false&#xA;otherwise. word may contain dots &amp;lsquo;.</description>
    </item>
    <item>
      <title>322.  Coin Change</title>
      <link>http://localhost:1313/leetcode/322/</link>
      <pubDate>Fri, 28 Jan 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/322/</guid>
      <description>Coin Change - LeetCode&#xA;You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money. Return the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1. You may assume that you have an infinite number of each kind of coin.</description>
    </item>
    <item>
      <title>421. Maximum XOR of Two Numbers in an Array </title>
      <link>http://localhost:1313/leetcode/421/</link>
      <pubDate>Thu, 27 Jan 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/421/</guid>
      <description>Maximum XOR of Two Numbers in an Array - LeetCode&#xA;Given an integer array nums, return __the maximum result of __nums[i] XOR nums[j], where 0 &amp;lt;= i &amp;lt;= j &amp;lt; n.&#xA;Example 1: Input: nums = [3,10,5,25,2,8] Output: 28 Explanation: The maximum result is 5 XOR 25 = 28.&#xA;Example 2: Input: nums = [14,70,53,83,49,91,36,80,92,51,66,70] Output: 127&#xA;Constraints:&#xA;1 &amp;lt;= nums.length &amp;lt;= 2 * 105 0 &amp;lt;= nums[i] &amp;lt;= 231 - 1</description>
    </item>
    <item>
      <title>1305. All Elements in Two Binary Search Trees</title>
      <link>http://localhost:1313/leetcode/1305/</link>
      <pubDate>Wed, 26 Jan 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/1305/</guid>
      <description>All Elements in Two Binary Search Trees - LeetCode&#xA;Given two binary search trees root1 and root2, return a list containing all the integers from both trees sorted in ascending order.&#xA;Example 1: Input: root1 = [2,1,4], root2 = [1,0,3] Output: [0,1,1,2,3,4] Example 2: Input: root1 = [1,null,8], root2 = [8,1] Output: [1,1,8,8]&#xA;Constraints:&#xA;The number of nodes in each tree is in the range [0, 5000]. -105 &amp;lt;= Node.val &amp;lt;= 105 code recursion + sort class Solution: def getAllElements(self, root1: TreeNode, root2: TreeNode) -&amp;gt; List[int]: def getIntegers(root): res = [] def helper(root): if not root: return helper(root.</description>
    </item>
    <item>
      <title>213. House robber II</title>
      <link>http://localhost:1313/leetcode/213/</link>
      <pubDate>Tue, 25 Jan 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/213/</guid>
      <description>House Robber II - LeetCode&#xA;You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. All houses at this place are arranged in a circle. That means the first house is the neighbor of the last one. Meanwhile, adjacent houses have a security system connected, and it will automatically contact the police if two adjacent houses were broken into on the same night.</description>
    </item>
    <item>
      <title>941. Valid Mountain Array</title>
      <link>http://localhost:1313/leetcode/941/</link>
      <pubDate>Tue, 25 Jan 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/941/</guid>
      <description>Valid Mountain Array - LeetCode&#xA;Given an array of integers arr, return true if and only if it is a valid mountain array. Recall that arr is a mountain array if and only if:&#xA;arr.length &amp;gt;= 3 There exists some i with 0 &amp;lt; i &amp;lt; arr.length - 1 such that: arr[0] &amp;lt; arr[1] &amp;lt; &amp;hellip; &amp;lt; arr[i - 1] &amp;lt; arr[i] arr[i] &amp;gt; arr[i + 1] &amp;gt; &amp;hellip; &amp;gt; arr[arr.</description>
    </item>
    <item>
      <title>520. Detect Capital</title>
      <link>http://localhost:1313/leetcode/520/</link>
      <pubDate>Mon, 24 Jan 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/520/</guid>
      <description>Detect Capital - LeetCode&#xA;We define the usage of capitals in a word to be right when one of the following cases holds:&#xA;All letters in this word are capitals, like &amp;ldquo;USA&amp;rdquo;. All letters in this word are not capitals, like &amp;ldquo;leetcode&amp;rdquo;. Only the first letter in this word is capital, like &amp;ldquo;Google&amp;rdquo;.Given a string word, return true if the usage of capitals in it is right.&#xA;Example 1: Input: word = &amp;ldquo;USA&amp;rdquo; Output: true</description>
    </item>
    <item>
      <title>1291. Sequential Digits</title>
      <link>http://localhost:1313/leetcode/1291/</link>
      <pubDate>Sun, 23 Jan 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/1291/</guid>
      <description>Sequential Digits - LeetCode&#xA;An integer has sequential digits if and only if each digit in the number is one more than the previous digit. Return a sorted list of all the integers in the range [low, high] inclusive that have sequential digits.&#xA;Example 1: Input: low = 100, high = 300 Output: [123,234] Example 2: Input: low = 1000, high = 13000 Output: [1234,2345,3456,4567,5678,6789,12345]&#xA;code #slidingwindow class Solution: def sequentialDigits(self, low: int, high: int) -&amp;gt; List[int]: sample = &amp;#34;123456789&amp;#34; n = 10 nums = [] for length in range(len(str(low)), len(str(high)) + 1): for start in range(n - length): num = int(sample[start: start + length]) if low &amp;lt;= num &amp;lt;= high: nums.</description>
    </item>
    <item>
      <title>1510. Stone Game IV</title>
      <link>http://localhost:1313/leetcode/1510/</link>
      <pubDate>Sat, 22 Jan 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/1510/</guid>
      <description>Stone Game IV - LeetCode&#xA;Alice and Bob take turns playing a game, with Alice starting first. Initially, there are n stones in a pile. On each player&amp;rsquo;s turn, that player makes a move consisting of removing any non-zero square number of stones in the pile. Also, if a player cannot make a move, he/she loses the game. Given a positive integer n, return true if and only if Alice wins the game otherwise return false, assuming both players play optimally.</description>
    </item>
    <item>
      <title>1602. Find Nearest Right Node in Binary Tree</title>
      <link>http://localhost:1313/leetcode/1602/</link>
      <pubDate>Sat, 22 Jan 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/1602/</guid>
      <description>Find Nearest Right Node in Binary Tree - LeetCode&#xA;Given the root of a binary tree and a node u in the tree, return the nearest node on the same level that is to the right of u__, or return__ null __if __u is the rightmost node in its level.&#xA;Example 1: Input: root = [1,2,3,null,4,5,6], u = 4 Output: 5 Explanation: The nearest node on the same level to the right of node 4 is node 5.</description>
    </item>
    <item>
      <title>Dangerous words, why psychology is impossible</title>
      <link>http://localhost:1313/posts/opinion-words-psychology/</link>
      <pubDate>Sat, 22 Jan 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/opinion-words-psychology/</guid>
      <description>“But profound as psychology is, it&amp;rsquo;s a knife that cuts both ways (&amp;hellip;). I have purposely resorted to this method, gentlemen of the jury, to show that you can prove anything by it. It all depends on who makes use of it. Psychology lures even most serious people into romancing, and quite unconsciously.” ― Fyodor Dostoyevsky, The Brothers Karamazov&#xA;“The confusion and barrenness of psychology is not to be explained by calling it a “young science”; its state is not comparable with that of physics, for instance, in its beginnings&amp;hellip; For in psychology there are experimental methods and conceptual confusion&amp;hellip; The existence of the experimental method makes us think we have the means of solving the problems which trouble us; though problem and method pass one another by” (Ludwig Wittgenstein, Philosophical Investigations, 1968, II xiv, 232e).</description>
    </item>
    <item>
      <title>The word &#39;Word&#39; in Bible </title>
      <link>http://localhost:1313/posts/christian-bible-words/</link>
      <pubDate>Sat, 22 Jan 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/christian-bible-words/</guid>
      <description>In the beginning was the Word, and the Word was with God, and the Word was God. John 1:1 (ESV)&#xA;And God said, “Let there be light,” and there was light. Genesis 1:3 NIV&#xA;Therefore this is what the LORD says: “If you repent, I will restore you that you may serve me; if you utter worthy, not worthless, words, you will be my spokesman. Jeremiah 15:19 NIV&#xA;Then Jesus looked up and said, “Father, I thank you that you have heard me.</description>
    </item>
    <item>
      <title>51. N-Queens</title>
      <link>http://localhost:1313/leetcode/51/</link>
      <pubDate>Fri, 21 Jan 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/51/</guid>
      <description>N-Queens - LeetCode&#xA;The n-queens puzzle is the problem of placing n queens on an n x n chessboard such that no two queens attack each other. Given an integer n, return all distinct solutions to the n-queens puzzle. You may return the answer in any order. Each solution contains a distinct board configuration of the n-queens&amp;rsquo; placement, where &amp;lsquo;Q&amp;rsquo; and &amp;lsquo;.&amp;rsquo; both indicate a queen and an empty space, respectively.</description>
    </item>
    <item>
      <title>130. Surrounded Regions</title>
      <link>http://localhost:1313/leetcode/130/</link>
      <pubDate>Thu, 20 Jan 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/130/</guid>
      <description>Surrounded Regions - LeetCode&#xA;Given an m x n matrix board containing &amp;lsquo;X&amp;rsquo; and &amp;lsquo;O&amp;rsquo;, capture all regions that are 4-directionally surrounded by &amp;lsquo;X&amp;rsquo;. A region is captured by flipping all &amp;lsquo;O&amp;rsquo;s into &amp;lsquo;X&amp;rsquo;s in that surrounded region.&#xA;Example 1: Input: board = [[&amp;ldquo;X&amp;rdquo;,&amp;ldquo;X&amp;rdquo;,&amp;ldquo;X&amp;rdquo;,&amp;ldquo;X&amp;rdquo;],[&amp;ldquo;X&amp;rdquo;,&amp;ldquo;O&amp;rdquo;,&amp;ldquo;O&amp;rdquo;,&amp;ldquo;X&amp;rdquo;],[&amp;ldquo;X&amp;rdquo;,&amp;ldquo;X&amp;rdquo;,&amp;ldquo;O&amp;rdquo;,&amp;ldquo;X&amp;rdquo;],[&amp;ldquo;X&amp;rdquo;,&amp;ldquo;O&amp;rdquo;,&amp;ldquo;X&amp;rdquo;,&amp;ldquo;X&amp;rdquo;]] Output: [[&amp;ldquo;X&amp;rdquo;,&amp;ldquo;X&amp;rdquo;,&amp;ldquo;X&amp;rdquo;,&amp;ldquo;X&amp;rdquo;],[&amp;ldquo;X&amp;rdquo;,&amp;ldquo;X&amp;rdquo;,&amp;ldquo;X&amp;rdquo;,&amp;ldquo;X&amp;rdquo;],[&amp;ldquo;X&amp;rdquo;,&amp;ldquo;X&amp;rdquo;,&amp;ldquo;X&amp;rdquo;,&amp;ldquo;X&amp;rdquo;],[&amp;ldquo;X&amp;rdquo;,&amp;ldquo;O&amp;rdquo;,&amp;ldquo;X&amp;rdquo;,&amp;ldquo;X&amp;rdquo;]] Explanation: Surrounded regions should not be on the border, which means that any &amp;lsquo;O&amp;rsquo; on the border of the board are not flipped to &amp;lsquo;X&amp;rsquo;.</description>
    </item>
    <item>
      <title>875. Koko Eating Bananas </title>
      <link>http://localhost:1313/leetcode/875/</link>
      <pubDate>Thu, 20 Jan 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/875/</guid>
      <description>Koko Eating Bananas - LeetCode&#xA;Koko loves to eat bananas. There are n piles of bananas, the ith pile has piles[i] bananas. The guards have gone and will come back in h hours. Koko can decide her bananas-per-hour eating speed of k. Each hour, she chooses some pile of bananas and eats k bananas from that pile. If the pile has less than k bananas, she eats all of them instead and will not eat any more bananas during this hour.</description>
    </item>
    <item>
      <title>78. subsets</title>
      <link>http://localhost:1313/leetcode/78-subset/</link>
      <pubDate>Tue, 18 Jan 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/78-subset/</guid>
      <description>Subsets - LeetCode&#xA;Given a set of distinct integers, nums, return all possible subsets (the power set). Note: The solution set must not contain duplicate subsets. Example: Input: nums = [1,2,3] Output: [ [3], [1], [2], [1,2,3], [1,3], [2,3], [1,2], [] ] code1 class Solution: def subsets(self, nums): res = [[]] for num in nums: last = copy.deepcopy(res) for sublist in res: sublist.append(num) res += last return res code2 shorter version of code1 class Solution: def subsets(self, nums): res = [[]] for num in nums: res += [item+[num] for item in res] return res code backtracking class Solution: def subsets(self, nums): res = [] def dfs(nums, path): res.</description>
    </item>
    <item>
      <title> 17. Letter Combinations of a Phone Number </title>
      <link>http://localhost:1313/leetcode/17-letter-combinations-of-a-phone/</link>
      <pubDate>Sun, 16 Jan 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/17-letter-combinations-of-a-phone/</guid>
      <description>Letter Combinations of a Phone Number - LeetCode&#xA;Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent. Return the answer in any order. A mapping of digit to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters. Example 1: Input: digits = &amp;ldquo;23&amp;rdquo; Output: [&amp;ldquo;ad&amp;rdquo;,&amp;ldquo;ae&amp;rdquo;,&amp;ldquo;af&amp;rdquo;,&amp;ldquo;bd&amp;rdquo;,&amp;ldquo;be&amp;rdquo;,&amp;ldquo;bf&amp;rdquo;,&amp;ldquo;cd&amp;rdquo;,&amp;ldquo;ce&amp;rdquo;,&amp;ldquo;cf&amp;rdquo;]&#xA;Example 2: Input: digits = &amp;quot;&amp;quot; Output: []</description>
    </item>
    <item>
      <title>22. Generate Parentheses</title>
      <link>http://localhost:1313/leetcode/22/</link>
      <pubDate>Sun, 16 Jan 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/22/</guid>
      <description>Generate Parentheses - LeetCode&#xA;Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses. For example, given n = 3, a solution set is: [ &amp;ldquo;((()))&amp;rdquo;, &amp;ldquo;(()())&amp;rdquo;, &amp;ldquo;(())()&amp;rdquo;, &amp;ldquo;()(())&amp;rdquo;, &amp;ldquo;()()()&amp;rdquo; ] code class Solution: def generateParenthesis(self, n: int) -&amp;gt; List[str]: res = [] def dfs(start, end, path): if len(path) == 2 * n: res.append(&amp;#34;&amp;#34;.join(path)) return if start &amp;lt; n: dfs(start + 1, end, path + [&amp;#34;(&amp;#34;]) if end &amp;lt; start: dfs(start, end + 1, path + [&amp;#34;)&amp;#34;]) dfs(0, 0, []) return res </description>
    </item>
    <item>
      <title>46 Permutations</title>
      <link>http://localhost:1313/leetcode/46/</link>
      <pubDate>Sun, 16 Jan 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/46/</guid>
      <description>Permutations - LeetCode&#xA;Given an array nums of distinct integers, return all the possible permutations. You can return the answer in any order.&#xA;Input: [1,2,3] Output: [ [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1] ] c0 class Solution: def permute(self, nums: List[int]) -&amp;gt; List[List[int]]: return list(itertools.permutations(nums, len(nums))) code class Solution: def permute(self, nums: List[int]) -&amp;gt; List[List[int]]: res = [] def backTracking(nums, path, res): if not nums: res.append(path) for i in range(len(nums)): backTracking(nums[:i] + nums[i+1:], path + [nums[i]], res) backTracking(nums, [], res) return res dfs(nums = [1, 2, 3] , path = [] , result = [] ) |____ dfs(nums = [2, 3] , path = [1] , result = [] ) | |___dfs(nums = [3] , path = [1, 2] , result = [] ) | | |___dfs(nums = [] , path = [1, 2, 3] , result = [[1, 2, 3]] ) # added a new permutation to the result | |__dfs(nums = [2] , path = [1, 3] , result = [[1, 2, 3]] ) | |dfs(nums = [] , path = [1, 3, 2] , result = [[1, 2, 3], [1, 3, 2]] ) # added a new permutation to the result | dfs(nums = [1, 3] , path = [2] , result = [[1, 2, 3], [1, 3, 2]] ) | |___dfs(nums = [3] , path = [2, 1] , result = [[1, 2, 3], [1, 3, 2]] ) | | |___dfs(nums = [] , path = [2, 1, 3] , result = [[1, 2, 3], [1, 3, 2], [2, 1, 3]] ) # added a new permutation to the result | |__dfs(nums = [1] , path = [2, 3] , result = [[1, 2, 3], [1, 3, 2], [2, 1, 3]] ) | |dfs(nums = [] , path = [2, 3, 1] , result = [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1]] ) # added a new permutation to the result | dfs(nums = [1, 2] , path = [3] , result = [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1]] ) |___dfs(nums = [2] , path = [3, 1] , result = [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1]] ) | |___dfs(nums = [] , path = [3, 1, 2] , result = [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2]] ) # added a new permutation to the result |___dfs(nums = [1] , path = [3, 2] , result = [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2]] ) |___dfs(nums = [] , path = [3, 2, 1] , result = [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]] ) # added a new permutation to the result</description>
    </item>
    <item>
      <title>79. Word Search</title>
      <link>http://localhost:1313/leetcode/79/</link>
      <pubDate>Sun, 16 Jan 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/79/</guid>
      <description>Word Search - LeetCode&#xA;Given an m x n grid of characters board and a string word, return true if word exists in the grid. The word can be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once.&#xA;Example 1: Input: board = [[&amp;ldquo;A&amp;rdquo;,&amp;ldquo;B&amp;rdquo;,&amp;ldquo;C&amp;rdquo;,&amp;ldquo;E&amp;rdquo;],[&amp;ldquo;S&amp;rdquo;,&amp;ldquo;F&amp;rdquo;,&amp;ldquo;C&amp;rdquo;,&amp;ldquo;S&amp;rdquo;],[&amp;ldquo;A&amp;rdquo;,&amp;ldquo;D&amp;rdquo;,&amp;ldquo;E&amp;rdquo;,&amp;ldquo;E&amp;rdquo;]], word = &amp;ldquo;ABCCED&amp;rdquo; Output: true&#xA;Example 2: Input: board = [[&amp;ldquo;A&amp;rdquo;,&amp;ldquo;B&amp;rdquo;,&amp;ldquo;C&amp;rdquo;,&amp;ldquo;E&amp;rdquo;],[&amp;ldquo;S&amp;rdquo;,&amp;ldquo;F&amp;rdquo;,&amp;ldquo;C&amp;rdquo;,&amp;ldquo;S&amp;rdquo;],[&amp;ldquo;A&amp;rdquo;,&amp;ldquo;D&amp;rdquo;,&amp;ldquo;E&amp;rdquo;,&amp;ldquo;E&amp;rdquo;]], word = &amp;ldquo;SEE&amp;rdquo; Output: true</description>
    </item>
    <item>
      <title>849. Maximize Distance to Closest Person </title>
      <link>http://localhost:1313/leetcode/849/</link>
      <pubDate>Sun, 16 Jan 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/849/</guid>
      <description>Maximize Distance to Closest Person - LeetCode&#xA;You are given an array representing a row of seats where seats[i] = 1 represents a person sitting in the ith seat, and seats[i] = 0 represents that the ith seat is empty (0-indexed). There is at least one empty seat, and at least one person sitting. Alex wants to sit in the seat such that the distance between him and the closest person to him is maximized.</description>
    </item>
    <item>
      <title>1345. Jump Game IV</title>
      <link>http://localhost:1313/leetcode/1345/</link>
      <pubDate>Sat, 15 Jan 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/1345/</guid>
      <description>Jump Game IV - LeetCode&#xA;Given an array of integers arr, you are initially positioned at the first index of the array. In one step you can jump from index i to index:&#xA;i + 1 where: i + 1 &amp;lt; arr.length. i - 1 where: i - 1 &amp;gt;= 0. j where: arr[i] == arr[j] and i != j.Return the minimum number of steps to reach the last index of the array.</description>
    </item>
    <item>
      <title>Mom, let me take the blame for Dad&#39;s mistakes</title>
      <link>http://localhost:1313/posts/christian-let-me-take-it/</link>
      <pubDate>Sat, 15 Jan 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/christian-let-me-take-it/</guid>
      <description>Dad shared such a little story recently.&#xA;The couple quarrelled, and the child ran around and found out: you two are not fighting again!&#xA;He ran to his dad, &amp;ldquo;Dad, dad, you just apologize to mom, you guys make up!&amp;rdquo; Dad sighed sadly and shook his head, &amp;ldquo;Your mom is not even talking to me right now.&amp;rdquo;&#xA;The child rushed to mom&amp;rsquo;s side again, &amp;ldquo;Mom, mom, you make up with dad, dad is not coming to talk now, but I know his heart is weeping!</description>
    </item>
    <item>
      <title>740. Delete and Earn </title>
      <link>http://localhost:1313/leetcode/740/</link>
      <pubDate>Fri, 14 Jan 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/740/</guid>
      <description>Delete and Earn - LeetCode&#xA;You are given an integer array nums. You want to maximize the number of points you get by performing the following operation any number of times:&#xA;Pick any nums[i] and delete it to earn nums[i] points. Afterwards, you must delete every element equal to nums[i] - 1 and every element equal to nums[i] + 1.Return the maximum number of points you can earn by applying the above operation some number of times.</description>
    </item>
    <item>
      <title>8. string to integer</title>
      <link>http://localhost:1313/leetcode/8-string-to-integer/</link>
      <pubDate>Fri, 14 Jan 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/8-string-to-integer/</guid>
      <description>String to Integer (atoi) - LeetCode&#xA;Implement the myAtoi(string s) function, which converts a string to a 32-bit signed integer (similar to C/C++&amp;rsquo;s atoi function). The algorithm for myAtoi(string s) is as follows:&#xA;Read in and ignore any leading whitespace. Check if the next character (if not already at the end of the string) is &amp;lsquo;-&amp;rsquo; or &amp;lsquo;+&amp;rsquo;. Read this character in if it is either. This determines if the final result is negative or positive respectively.</description>
    </item>
    <item>
      <title>934. Shortest Bridge</title>
      <link>http://localhost:1313/leetcode/934/</link>
      <pubDate>Fri, 14 Jan 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/934/</guid>
      <description>Shortest Bridge - LeetCode&#xA;You are given an n x n binary matrix grid where 1 represents land and 0 represents water. An island is a 4-directionally connected group of 1&amp;rsquo;s not connected to any other 1&amp;rsquo;s. There are exactly two islands in grid. You may change 0&amp;rsquo;s to 1&amp;rsquo;s to connect the two islands to form one island. Return the smallest number of 0&amp;rsquo;s you must flip to connect the two islands.</description>
    </item>
    <item>
      <title>257. Binary Tree Paths</title>
      <link>http://localhost:1313/leetcode/257/</link>
      <pubDate>Thu, 13 Jan 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/257/</guid>
      <description>Binary Tree Paths - LeetCode&#xA;Given the root of a binary tree, return all root-to-leaf paths in any order. A leaf is a node with no children.&#xA;Example 1: Input: root = [1,2,3,null,5] Output: [&amp;ldquo;1-&amp;gt;2-&amp;gt;5&amp;rdquo;,&amp;ldquo;1-&amp;gt;3&amp;rdquo;]&#xA;Example 2: Input: root = [1] Output: [&amp;ldquo;1&amp;rdquo;]&#xA;Constraints:&#xA;The number of nodes in the tree is in the range [1, 100]. -100 &amp;lt;= Node.val &amp;lt;= 100 code class Solution: def binaryTreePaths(self, root: Optional[TreeNode]) -&amp;gt; List[str]: def dfs(node, path): if node: if not node.</description>
    </item>
    <item>
      <title>452. Minimum Number of Arrows to Burst Balloons</title>
      <link>http://localhost:1313/leetcode/452/</link>
      <pubDate>Thu, 13 Jan 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/452/</guid>
      <description>Minimum Number of Arrows to Burst Balloons - LeetCode&#xA;There are some spherical balloons taped onto a flat wall that represents the XY-plane. The balloons are represented as a 2D integer array points where points[i] = [xstart, xend] denotes a balloon whose horizontal diameter stretches between xstart and xend. You do not know the exact y-coordinates of the balloons. Arrows can be shot up directly vertically (in the positive y-direction) from different points along the x-axis.</description>
    </item>
    <item>
      <title>417. Pacific Atlantic Water Flow</title>
      <link>http://localhost:1313/leetcode/417/</link>
      <pubDate>Wed, 12 Jan 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/417/</guid>
      <description>Pacific Atlantic Water Flow - LeetCode&#xA;There is an m x n rectangular island that borders both the Pacific Ocean and Atlantic Ocean. The Pacific Ocean touches the island&amp;rsquo;s left and top edges, and the Atlantic Ocean touches the island&amp;rsquo;s right and bottom edges. The island is partitioned into a grid of square cells. You are given an m x n integer matrix heights where heights[r][c] represents the height above sea level of the cell at coordinate (r, c).</description>
    </item>
    <item>
      <title>62. Unique Paths</title>
      <link>http://localhost:1313/leetcode/62/</link>
      <pubDate>Wed, 12 Jan 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/62/</guid>
      <description>Unique Paths - LeetCode&#xA;There is a robot on an m x n grid. The robot is initially located at the top-left corner (i.e., grid[0][0]). The robot tries to move to the bottom-right corner (i.e., grid[m - 1][n - 1]). The robot can only move either down or right at any point in time. Given the two integers m and n, return the number of possible unique paths that the robot can take to reach the bottom-right corner.</description>
    </item>
    <item>
      <title>701. Insert into a binary search tree</title>
      <link>http://localhost:1313/leetcode/701/</link>
      <pubDate>Wed, 12 Jan 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/701/</guid>
      <description>Insert into a Binary Search Tree - LeetCode&#xA;You are given the root node of a binary search tree (BST) and a value to insert into the tree. Return the root node of the BST after the insertion. It is guaranteed that the new value does not exist in the original BST. Notice that there may exist multiple valid ways for the insertion, as long as the tree remains a BST after insertion.</description>
    </item>
    <item>
      <title>81. Search in Rotated Sorted Array II</title>
      <link>http://localhost:1313/leetcode/81/</link>
      <pubDate>Wed, 12 Jan 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/81/</guid>
      <description>Search in Rotated Sorted Array II - LeetCode&#xA;There is an integer array nums sorted in non-decreasing order (not necessarily with distinct values). Before being passed to your function, nums is rotated at an unknown pivot index k (0 &amp;lt;= k &amp;lt; nums.length) such that the resulting array is [nums[k], nums[k+1], &amp;hellip;, nums[n-1], nums[0], nums[1], &amp;hellip;, nums[k-1]] (0-indexed). For example, [0,1,2,4,4,4,5,6,6,7] might be rotated at pivot index 5 and become [4,5,6,6,7,0,1,2,4,4].</description>
    </item>
    <item>
      <title>1022. Sum of Root To Leaf Binary Numbers </title>
      <link>http://localhost:1313/leetcode/1022/</link>
      <pubDate>Mon, 10 Jan 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/1022/</guid>
      <description>Sum of Root To Leaf Binary Numbers - LeetCode&#xA;You are given the root of a binary tree where each node has a value 0 or 1. Each root-to-leaf path represents a binary number starting with the most significant bit.&#xA;For example, if the path is 0 -&amp;gt; 1 -&amp;gt; 1 -&amp;gt; 0 -&amp;gt; 1, then this could represent 01101 in binary, which is 13.For all leaves in the tree, consider the numbers represented by the path from the root to that leaf.</description>
    </item>
    <item>
      <title>5. Longest Palindromic Substring</title>
      <link>http://localhost:1313/leetcode/5-longest-palindromic-substring/</link>
      <pubDate>Mon, 10 Jan 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/5-longest-palindromic-substring/</guid>
      <description>Longest Palindromic Substring - LeetCode&#xA;Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000. Example 1: Input: &amp;ldquo;babad&amp;rdquo; Output: &amp;ldquo;bab&amp;rdquo; Note: &amp;ldquo;aba&amp;rdquo; is also a valid answer.&#xA;code class Solution: def longestPalindrome(self, s: str) -&amp;gt; str: n = len(s) cur = s[0] for i in range(n): # odd l = r = i while 0 &amp;lt;= l - 1 and r + 1 &amp;lt; n and s[l-1] == s[r+1]: l -= 1 r += 1 if r - l + 1 &amp;gt; len(cur): cur = s[l:r+1] # even l = i r = i + 1 if r &amp;lt; n and s[l] == s[r]: while 0 &amp;lt;= l - 1 and r + 1 &amp;lt; n and s[l-1] == s[r+1]: l -= 1 r += 1 if r - l + 1 &amp;gt; len(cur): cur = s[l:r+1] return cur code class Solution: def longestPalindrome(self, s): self.</description>
    </item>
    <item>
      <title>547. Number of Provinces</title>
      <link>http://localhost:1313/leetcode/547/</link>
      <pubDate>Mon, 10 Jan 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/547/</guid>
      <description>Number of Provinces - LeetCode&#xA;There are n cities. Some of them are connected, while some are not. If city a is connected directly with city b, and city b is connected directly with city c, then city a is connected indirectly with city c. A province is a group of directly or indirectly connected cities and no other cities outside of the group. You are given an n x n matrix isConnected where isConnected[i][j] = 1 if the ith city and the jth city are directly connected, and isConnected[i][j] = 0 otherwise.</description>
    </item>
    <item>
      <title>67. Add Binary</title>
      <link>http://localhost:1313/leetcode/67/</link>
      <pubDate>Mon, 10 Jan 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/67/</guid>
      <description>Add Binary - LeetCode&#xA;Given two binary strings a and b, return their sum as a binary string.&#xA;Example 1: Input: a = &amp;ldquo;11&amp;rdquo;, b = &amp;ldquo;1&amp;rdquo; Output: &amp;ldquo;100&amp;rdquo;&#xA;Example 2: Input: a = &amp;ldquo;1010&amp;rdquo;, b = &amp;ldquo;1011&amp;rdquo; Output: &amp;ldquo;10101&amp;rdquo;&#xA;Constraints:&#xA;1 &amp;lt;= a.length, b.length &amp;lt;= 104 a and b consist only of &#39;0&#39; or &#39;1&#39; characters. Each string does not contain leading zeros except for the zero itself. code class Solution: def addBinary(self, a, b) -&amp;gt; str: return bin((int(a, 2) + int(b, 2)))[2:] code wrong ans, class Solution { public String addBinary(String a, String b) { return Integer.</description>
    </item>
    <item>
      <title>1041. Robot Bounded In Circle</title>
      <link>http://localhost:1313/leetcode/1041/</link>
      <pubDate>Sun, 09 Jan 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/1041/</guid>
      <description>Robot Bounded In Circle - LeetCode&#xA;On an infinite plane, a robot initially stands at (0, 0) and faces north. The robot can receive one of three instructions:&#xA;&amp;ldquo;G&amp;rdquo;: go straight 1 unit; &amp;ldquo;L&amp;rdquo;: turn 90 degrees to the left; &amp;ldquo;R&amp;rdquo;: turn 90 degrees to the right.The robot performs the instructions given in order, and repeats them forever. Return true if and only if there exists a circle in the plane such that the robot never leaves the circle.</description>
    </item>
    <item>
      <title>1463. Cherry Pickup II</title>
      <link>http://localhost:1313/leetcode/1463/</link>
      <pubDate>Sat, 08 Jan 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/1463/</guid>
      <description>Cherry Pickup II - LeetCode&#xA;You are given a rows x cols matrix grid representing a field of cherries where grid[i][j] represents the number of cherries that you can collect from the (i, j) cell. You have two robots that can collect cherries for you:&#xA;Robot #1 is located at the top-left corner (0, 0), and Robot #2 is located at the top-right corner (0, cols - 1).Return the maximum number of cherries collection using both robots by following the rules below:</description>
    </item>
    <item>
      <title>588. Design In-Memory File System </title>
      <link>http://localhost:1313/leetcode/588/</link>
      <pubDate>Sat, 08 Jan 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/588/</guid>
      <description>Design In-Memory File System - LeetCode&#xA;Design a data structure that simulates an in-memory file system. Implement the FileSystem class:&#xA;FileSystem() Initializes the object of the system. List ls(String path) If path is a file path, returns a list that only contains this file&amp;rsquo;s name. If path is a directory path, returns the list of file and directory names in this directory.The answer should in lexicographic order. void mkdir(String path) Makes a new directory according to the given path.</description>
    </item>
    <item>
      <title>1770. Maximum Score from Performing Multiplication Operations</title>
      <link>http://localhost:1313/leetcode/1770/</link>
      <pubDate>Fri, 07 Jan 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/1770/</guid>
      <description>Maximum Score from Performing Multiplication Operations - LeetCode&#xA;You are given two integer arrays nums and multipliers of size n and m respectively, where n &amp;gt;= m. The arrays are 1-indexed. You begin with a score of 0. You want to perform exactly m operations. On the ith operation (1-indexed), you will:&#xA;Choose one integer x from either the start or the end of the array nums. Add multipliers[i] * x to your score.</description>
    </item>
    <item>
      <title>382. Linked List Random Node</title>
      <link>http://localhost:1313/leetcode/382/</link>
      <pubDate>Fri, 07 Jan 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/382/</guid>
      <description>Linked List Random Node - LeetCode&#xA;Given a singly linked list, return a random node&amp;rsquo;s value from the linked list. Each node must have the same probability of being chosen. Implement the Solution class:&#xA;Solution(ListNode head) Initializes the object with the integer array nums. int getRandom() Chooses a node randomly from the list and returns its value. All the nodes of the list should be equally likely to be choosen.</description>
    </item>
    <item>
      <title>1094. Car Pooling</title>
      <link>http://localhost:1313/leetcode/1094/</link>
      <pubDate>Thu, 06 Jan 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/1094/</guid>
      <description>Car Pooling - LeetCode&#xA;There is a car with capacity empty seats. The vehicle only drives east (i.e., it cannot turn around and drive west). You are given the integer capacity and an array trips where trip[i] = [numPassengersi, fromi, toi] indicates that the ith trip has numPassengersi passengers and the locations to pick them up and drop them off are fromi and toi respectively. The locations are given as the number of kilometers due east from the car&amp;rsquo;s initial location.</description>
    </item>
    <item>
      <title>131. Palindrome partitioning</title>
      <link>http://localhost:1313/leetcode/131/</link>
      <pubDate>Wed, 05 Jan 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/131/</guid>
      <description>Palindrome Partitioning - LeetCode&#xA;Given a string s, partition s such that every substring of the partition is a palindrome. Return all possible palindrome partitioning of s. A palindrome string is a string that reads the same backward as forward.&#xA;Example 1: Input: s = &amp;ldquo;aab&amp;rdquo; Output: [[&amp;ldquo;a&amp;rdquo;,&amp;ldquo;a&amp;rdquo;,&amp;ldquo;b&amp;rdquo;],[&amp;ldquo;aa&amp;rdquo;,&amp;ldquo;b&amp;rdquo;]]&#xA;code pass string class Solution: def partition(self, s: str) -&amp;gt; List[List[str]]: res = [] def isPalindrome(inp): return inp == inp[::-1] def dfs(s, path): if not s: res.</description>
    </item>
    <item>
      <title>1009. Complement of Base 10 Integer</title>
      <link>http://localhost:1313/leetcode/1009/</link>
      <pubDate>Tue, 04 Jan 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/1009/</guid>
      <description>Complement of Base 10 Integer - LeetCode&#xA;The complement of an integer is the integer you get when you flip all the 0&amp;rsquo;s to 1&amp;rsquo;s and all the 1&amp;rsquo;s to 0&amp;rsquo;s in its binary representation.&#xA;For example, The integer 5 is &amp;ldquo;101&amp;rdquo; in binary and its complement is &amp;ldquo;010&amp;rdquo; which is the integer 2.Given an integer n, return its complement.&#xA;Example 1: Input: n = 5 Output: 2 Explanation: 5 is &amp;ldquo;101&amp;rdquo; in binary, with complement &amp;ldquo;010&amp;rdquo; in binary, which is 2 in base-10.</description>
    </item>
    <item>
      <title>1137. N-th Tribonacci Number </title>
      <link>http://localhost:1313/leetcode/1137/</link>
      <pubDate>Tue, 04 Jan 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/1137/</guid>
      <description>N-th Tribonacci Number - LeetCode&#xA;The Tribonacci sequence Tn is defined as follows: T0 = 0, T1 = 1, T2 = 1, and Tn+3 = Tn + Tn+1 + Tn+2 for n &amp;gt;= 0. Given n, return the value of Tn.&#xA;Example 1: Input: n = 4 Output: 4 Explanation: T_3 = 0 + 1 + 1 = 2 T_4 = 1 + 1 + 2 = 4 Example 2: Input: n = 25 Output: 1389537</description>
    </item>
    <item>
      <title>1167. Minimum Cost to Connect Sticks</title>
      <link>http://localhost:1313/leetcode/1167/</link>
      <pubDate>Tue, 04 Jan 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/1167/</guid>
      <description>Minimum Cost to Connect Sticks - LeetCode&#xA;You have some number of sticks with positive integer lengths. These lengths are given as an array sticks, where sticks[i] is the length of the ith stick. You can connect any two sticks of lengths x and y into one stick by paying a cost of x + y. You must connect all the sticks until there is only one stick remaining. Return the minimum cost of connecting all the given sticks into one stick in this way.</description>
    </item>
    <item>
      <title>1337. The K Weakest Rows in a Matrix</title>
      <link>http://localhost:1313/leetcode/1337/</link>
      <pubDate>Tue, 04 Jan 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/1337/</guid>
      <description>The K Weakest Rows in a Matrix - LeetCode&#xA;You are given an m x n binary matrix mat of 1&amp;rsquo;s (representing soldiers) and 0&amp;rsquo;s (representing civilians). The soldiers are positioned in front of the civilians. That is, all the 1&amp;rsquo;s will appear to the left of all the 0&amp;rsquo;s in each row. A row i is weaker than a row j if one of the following is true:&#xA;The number of soldiers in row i is less than the number of soldiers in row j.</description>
    </item>
    <item>
      <title>1046. Last Stone Weight</title>
      <link>http://localhost:1313/leetcode/1046/</link>
      <pubDate>Mon, 03 Jan 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/1046/</guid>
      <description>Last Stone Weight - LeetCode&#xA;You are given an array of integers stones where stones[i] is the weight of the ith stone. We are playing a game with the stones. On each turn, we choose the heaviest two stones and smash them together. Suppose the heaviest two stones have weights x and y with x &amp;lt;= y. The result of this smash is:&#xA;If x == y, both stones are destroyed, and If x !</description>
    </item>
    <item>
      <title>347. Top K Frequent Elements</title>
      <link>http://localhost:1313/leetcode/347-top-k-frequent-elements/</link>
      <pubDate>Mon, 03 Jan 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/347-top-k-frequent-elements/</guid>
      <description>Top K Frequent Elements - LeetCode&#xA;Given a non-empty array of integers, return the k most frequent elements. Example 1: Input: nums = [1,1,1,2,2,3], k = 2 Output: [1,2]&#xA;code #quickSelection move smaller to left class Solution: def topKFrequent(self, nums: List[int], k: int) -&amp;gt; List[int]: counter = Counter(nums) # num, freq uniq = [k for k in counter.keys()] def partition(left, right): index = randint(left, right) freq_p = counter[uniq[index]] uniq[index], uniq[right] = uniq[right], uniq[index] # move pivot to the end for i in range(left, right): if counter[uniq[i]] &amp;lt; freq_p: uniq[i], uniq[left] = uniq[left], uniq[i] left += 1 uniq[left], uniq[right] = uniq[right], uniq[left] return left left, right = 0, len(uniq) - 1 while left &amp;lt;= right: p = partition(left, right) if p == len(uniq) - k or left == right: return uniq[len(uniq) - k:] elif p &amp;gt; len(uniq) - k: # go left right = p - 1 elif p &amp;lt; len(uniq) - k: # go right left = p + 1 code move bigger to left.</description>
    </item>
    <item>
      <title>703. Kth largest element in a stream</title>
      <link>http://localhost:1313/leetcode/703/</link>
      <pubDate>Mon, 03 Jan 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/703/</guid>
      <description>Kth Largest Element in a Stream - LeetCode&#xA;Design a class to find the kth largest element in a stream. Note that it is the kth largest element in the sorted order, not the kth distinct element. Implement KthLargest class:&#xA;KthLargest(int k, int[] nums) Initializes the object with the integer k and the stream of integers nums. int add(int val) Appends the integer val to the stream and returns the element representing the kth largest element in the stream.</description>
    </item>
    <item>
      <title>746. Min Cost Climbing Stairs </title>
      <link>http://localhost:1313/leetcode/746/</link>
      <pubDate>Mon, 03 Jan 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/746/</guid>
      <description>Min Cost Climbing Stairs - LeetCode&#xA;You are given an integer array cost where cost[i] is the cost of ith step on a staircase. Once you pay the cost, you can either climb one or two steps. You can either start from the step with index 0, or the step with index 1. Return the minimum cost to reach the top of the floor.&#xA;Example 1: Input: cost = [10,15,20] Output: 15 Explanation: You will start at index 1.</description>
    </item>
    <item>
      <title>997. Find the Town Judge</title>
      <link>http://localhost:1313/leetcode/997/</link>
      <pubDate>Mon, 03 Jan 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/997/</guid>
      <description>Find the Town Judge - LeetCode&#xA;In a town, there are n people labeled from 1 to n. There is a rumor that one of these people is secretly the town judge. If the town judge exists, then:&#xA;The town judge trusts nobody. Everybody (except for the town judge) trusts the town judge. There is exactly one person that satisfies properties 1 and 2.You are given an array trust where trust[i] = [ai, bi] representing that the person labeled ai trusts the person labeled bi.</description>
    </item>
    <item>
      <title>1010. Pairs of Songs With Total Durations Divisible by 60</title>
      <link>http://localhost:1313/leetcode/1010/</link>
      <pubDate>Sun, 02 Jan 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/1010/</guid>
      <description>Pairs of Songs With Total Durations Divisible by 60 - LeetCode&#xA;You are given a list of songs where the ith song has a duration of time[i] seconds. Return the number of pairs of songs for which their total duration in seconds is divisible by 60. Formally, we want the number of indices i, j such that i &amp;lt; j with (time[i] + time[j]) % 60 == 0.&#xA;Example 1: Input: time = [30,20,150,100,40] Output: 3 Explanation: Three pairs have a total duration divisible by 60: (time[0] = 30, time[2] = 150): total duration 180 (time[1] = 20, time[3] = 100): total duration 120 (time[1] = 20, time[4] = 40): total duration 60 Example 2: Input: time = [60,60,60] Output: 3 Explanation: All three pairs have a total duration of 120, which is divisible by 60.</description>
    </item>
    <item>
      <title>300. Longest Increasing Subsequence</title>
      <link>http://localhost:1313/leetcode/300/</link>
      <pubDate>Sun, 02 Jan 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/300/</guid>
      <description>Given an unsorted array of integers, find the length of longest increasing subsequence. A subsequence is a sequence that can be derived from an array by deleting some or no elements without changing the order of the remaining elements. For example, [3,6,2,7] is a subsequence of the array [0,3,1,6,2,2,7].&#xA;Example: Input: [10,9,2,5,3,7,101,18] Output: 4 Explanation: The longest increasing subsequence is [2,3,7,101], therefore the length is 4.&#xA;code dp class Solution: def lengthOfLIS(self, nums: List[int]) -&amp;gt; int: dp = [1] * len(nums) for i in range(1, len(nums)): for j in range(i): if nums[i] &amp;gt; nums[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp) code class Solution: def lengthOfLIS(self, nums: List[int]) -&amp;gt; int: sq = [nums[0]] for i in range(1, len(nums)): if nums[i] &amp;gt; sq[-1]: sq.</description>
    </item>
    <item>
      <title>568. Maximum Vacation Days</title>
      <link>http://localhost:1313/leetcode/568/</link>
      <pubDate>Sun, 02 Jan 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/568/</guid>
      <description>Maximum Vacation Days - LeetCode&#xA;LeetCode wants to give one of its best employees the option to travel among n cities to collect algorithm problems. But all work and no play makes Jack a dull boy, you could take vacations in some particular cities and weeks. Your job is to schedule the traveling to maximize the number of vacation days you could take, but there are certain rules and restrictions you need to follow.</description>
    </item>
    <item>
      <title>312. Burst Balloons</title>
      <link>http://localhost:1313/leetcode/312/</link>
      <pubDate>Sat, 01 Jan 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/312/</guid>
      <description>Burst Balloons - LeetCode&#xA;You are given n balloons, indexed from 0 to n - 1. Each balloon is painted with a number on it represented by an array nums. You are asked to burst all the balloons. If you burst the ith balloon, you will get nums[i - 1] * nums[i] * nums[i + 1] coins. If i - 1 or i + 1 goes out of bounds of the array, then treat it as if there is a balloon with a 1 painted on it.</description>
    </item>
    <item>
      <title>1026. Maximum Difference Between Node and Ancestor </title>
      <link>http://localhost:1313/leetcode/1026/</link>
      <pubDate>Fri, 31 Dec 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/1026/</guid>
      <description>Maximum Difference Between Node and Ancestor - LeetCode&#xA;Given the root of a binary tree, find the maximum value v for which there exist different nodes a and b where v = |a.val - b.val| and a is an ancestor of b. A node a is an ancestor of b if either: any child of a is equal to b or any child of a is an ancestor of b.</description>
    </item>
    <item>
      <title>399. Evaluate Division</title>
      <link>http://localhost:1313/leetcode/399/</link>
      <pubDate>Fri, 31 Dec 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/399/</guid>
      <description>Evaluate Division - LeetCode&#xA;You are given an array of variable pairs equations and an array of real numbers values, where equations[i] = [Ai, Bi] and values[i] represent the equation Ai / Bi = values[i]. Each Ai or Bi is a string that represents a single variable. You are also given some queries, where queries[j] = [Cj, Dj] represents the jth query where you must find the answer for Cj / Dj = ?</description>
    </item>
    <item>
      <title>1015. Smallest Integer Divisible by K </title>
      <link>http://localhost:1313/leetcode/1015/</link>
      <pubDate>Thu, 30 Dec 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/1015/</guid>
      <description>Smallest Integer Divisible by K - LeetCode&#xA;Given a positive integer k, you need to find the length of the smallest positive integer n such that n is divisible by k, and n only contains the digit 1. Return __the length of __n. If there is no such n, return -1. Note: n may not fit in a 64-bit signed integer.&#xA;Example 1: Input: k = 1 Output: 1 Explanation: The smallest answer is n = 1, which has length 1.</description>
    </item>
    <item>
      <title>1202. Smallest String With Swaps</title>
      <link>http://localhost:1313/leetcode/1202/</link>
      <pubDate>Thu, 30 Dec 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/1202/</guid>
      <description>Smallest String With Swaps - LeetCode&#xA;You are given a string s, and an array of pairs of indices in the string pairs where pairs[i] = [a, b] indicates 2 indices(0-indexed) of the string. You can swap the characters at any pair of indices in the given pairs any number of times. Return the lexicographically smallest string that s can be changed to after using the swaps.&#xA;Example 1: Input: s = &amp;ldquo;dcab&amp;rdquo;, pairs = [[0,3],[1,2]] Output: &amp;ldquo;bacd&amp;rdquo; Explaination: Swap s[0] and s[3], s = &amp;ldquo;bcad&amp;rdquo; Swap s[1] and s[2], s = &amp;ldquo;bacd&amp;rdquo; Example 2: Input: s = &amp;ldquo;dcab&amp;rdquo;, pairs = [[0,3],[1,2],[0,2]] Output: &amp;ldquo;abcd&amp;rdquo; Explaination: Swap s[0] and s[3], s = &amp;ldquo;bcad&amp;rdquo; Swap s[0] and s[2], s = &amp;ldquo;acbd&amp;rdquo; Swap s[1] and s[2], s = &amp;ldquo;abcd&amp;rdquo; Example 3: Input: s = &amp;ldquo;cba&amp;rdquo;, pairs = [[0,1],[1,2]] Output: &amp;ldquo;abc&amp;rdquo; Explaination: Swap s[0] and s[1], s = &amp;ldquo;bca&amp;rdquo; Swap s[1] and s[2], s = &amp;ldquo;bac&amp;rdquo; Swap s[0] and s[1], s = &amp;ldquo;abc&amp;rdquo;</description>
    </item>
    <item>
      <title>1244. Design A Leaderboard</title>
      <link>http://localhost:1313/leetcode/1244/</link>
      <pubDate>Thu, 30 Dec 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/1244/</guid>
      <description>Design A Leaderboard - LeetCode&#xA;Design a Leaderboard class, which has 3 functions:&#xA;addScore(playerId, score): Update the leaderboard by adding score to the given player&amp;rsquo;s score. If there is no player with such id in the leaderboard, add him to the leaderboard with the given score. top(K): Return the score sum of the top K players. reset(playerId): Reset the score of the player with the given id to 0 (in other words erase it from the leaderboard).</description>
    </item>
    <item>
      <title>1631. Path With Minimum Effort</title>
      <link>http://localhost:1313/leetcode/1631/</link>
      <pubDate>Thu, 30 Dec 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/1631/</guid>
      <description>Path With Minimum Effort - LeetCode&#xA;You are a hiker preparing for an upcoming hike. You are given heights, a 2D array of size rows x columns, where heights[row][col] represents the height of cell (row, col). You are situated in the top-left cell, (0, 0), and you hope to travel to the bottom-right cell, (rows-1, columns-1) (i.e., 0-indexed). You can move up, down, left, or right, and you wish to find a route that requires the minimum effort.</description>
    </item>
    <item>
      <title>116. Populating Next Right Pointers in Each Node</title>
      <link>http://localhost:1313/leetcode/116-populating-next-right-pointers/</link>
      <pubDate>Wed, 29 Dec 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/116-populating-next-right-pointers/</guid>
      <description>Populating Next Right Pointers in Each Node - LeetCode&#xA;You are given a perfect binary tree where all leaves are on the same level, and every parent has two children. The binary tree has the following definition: struct Node { int val; Node *left; Node *right; Node *next; } Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL.</description>
    </item>
    <item>
      <title>787. Cheapest Flights Within K Stops </title>
      <link>http://localhost:1313/leetcode/787/</link>
      <pubDate>Wed, 29 Dec 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/787/</guid>
      <description>Cheapest Flights Within K Stops - LeetCode&#xA;There are n cities connected by some number of flights. You are given an array flights where flights[i] = [fromi, toi, pricei] indicates that there is a flight from city fromi to city toi with cost pricei. You are also given three integers src, dst, and k, return __the cheapest price from src to dst with at most k stops. If there is no such route, return __-1.</description>
    </item>
    <item>
      <title>leetcode: mini spanning tree, single src shortest path, topological</title>
      <link>http://localhost:1313/dev/lee-graph-advanced/</link>
      <pubDate>Wed, 29 Dec 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/dev/lee-graph-advanced/</guid>
      <description>Minimum spanning tree A minimum spanning tree is a spanning tree with the minimum possible total edge weight in a “weighted undirected graph”. Min Cost to Connect All Points - LeetCode&#xA;You are given an array points representing integer coordinates of some points on a 2D-plane, where points[i] = [xi, yi]. The cost of connecting two points [xi, yi] and [xj, yj] is the manhattan distance between them: |xi - xj| + |yi - yj|, where |val| denotes the absolute value of val.</description>
    </item>
    <item>
      <title>253. Meeting Rooms II</title>
      <link>http://localhost:1313/leetcode/253/</link>
      <pubDate>Tue, 28 Dec 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/253/</guid>
      <description>Meeting Rooms II - LeetCode&#xA;Given an array of meeting time intervals intervals where intervals[i] = [starti, endi], return the minimum number of conference rooms required.&#xA;Example 1: Input: intervals = [[0,30],[5,10],[15,20]] Output: 2&#xA;Example 2: Input: intervals = [[7,10],[2,4]] Output: 1&#xA;Constraints:&#xA;1 &amp;lt;= intervals.length &amp;lt;= 104 0 &amp;lt;= starti &amp;lt; endi &amp;lt;= 106&#xA;code class Solution: def minMeetingRooms(self, intervals: List[List[int]]) -&amp;gt; int: intervals.sort() rooms = [intervals[0][1]] # end time for i in range(1, len(intervals)): cur_start, cur_end = intervals[i] for r_index in range(len(rooms)): if cur_start &amp;gt;= rooms[r_index]: rooms[r_index] = cur_end break else: rooms.</description>
    </item>
    <item>
      <title>743. Network Delay Time </title>
      <link>http://localhost:1313/leetcode/743/</link>
      <pubDate>Tue, 28 Dec 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/743/</guid>
      <description>Network Delay Time - LeetCode&#xA;You are given a network of n nodes, labeled from 1 to n. You are also given times, a list of travel times as directed edges times[i] = (ui, vi, wi), where ui is the source node, vi is the target node, and wi is the time it takes for a signal to travel from source to target. We will send a signal from a given node k.</description>
    </item>
    <item>
      <title>876. Middle of the Linked List</title>
      <link>http://localhost:1313/leetcode/876/</link>
      <pubDate>Tue, 28 Dec 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/876/</guid>
      <description>Middle of the Linked List - LeetCode&#xA;Given the head of a singly linked list, return the middle node of the linked list. If there are two middle nodes, return the second middle node.&#xA;Example 1:&#xA;Input: head = [1,2,3,4,5] Output: [3,4,5] Explanation: The middle node of the list is node 3. Example 2:&#xA;Input: head = [1,2,3,4,5,6] Output: [4,5,6] Explanation: Since the list has two middle nodes with values 3 and 4, we return the second one.</description>
    </item>
    <item>
      <title>1584. Min Cost to Connect All Points</title>
      <link>http://localhost:1313/leetcode/1584/</link>
      <pubDate>Mon, 27 Dec 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/1584/</guid>
      <description>Min Cost to Connect All Points - LeetCode&#xA;You are given an array points representing integer coordinates of some points on a 2D-plane, where points[i] = [xi, yi]. The cost of connecting two points [xi, yi] and [xj, yj] is the manhattan distance between them: |xi - xj| + |yi - yj|, where |val| denotes the absolute value of val. Return the minimum cost to make all points connected. All points are connected if there is exactly one simple path between any two points.</description>
    </item>
    <item>
      <title>476. Number Complement</title>
      <link>http://localhost:1313/leetcode/476/</link>
      <pubDate>Mon, 27 Dec 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/476/</guid>
      <description>Number Complement - LeetCode&#xA;The complement of an integer is the integer you get when you flip all the 0&amp;rsquo;s to 1&amp;rsquo;s and all the 1&amp;rsquo;s to 0&amp;rsquo;s in its binary representation.&#xA;For example, The integer 5 is &amp;ldquo;101&amp;rdquo; in binary and its complement is &amp;ldquo;010&amp;rdquo; which is the integer 2.Given an integer num, return its complement.&#xA;Example 1: Input: num = 5 Output: 2 Explanation: The binary representation of 5 is 101 (no leading zero bits), and its complement is 010.</description>
    </item>
    <item>
      <title>1136. Parallel Courses </title>
      <link>http://localhost:1313/leetcode/1136/</link>
      <pubDate>Sun, 26 Dec 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/1136/</guid>
      <description>Parallel Courses - LeetCode&#xA;You are given an integer n, which indicates that there are n courses labeled from 1 to n. You are also given an array relations where relations[i] = [prevCoursei, nextCoursei], representing a prerequisite relationship between course prevCoursei and course nextCoursei: course prevCoursei has to be taken before course nextCoursei. In one semester, you can take any number of courses as long as you have taken all the prerequisites in the previous semester for the courses you are taking.</description>
    </item>
    <item>
      <title>429. N-ary Tree Level Order Traversal</title>
      <link>http://localhost:1313/leetcode/429/</link>
      <pubDate>Sun, 26 Dec 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/429/</guid>
      <description>N-ary Tree Level Order Traversal - LeetCode&#xA;Given an n-ary tree, return the level order traversal of its nodes&amp;rsquo; values. Nary-Tree input serialization is represented in their level order traversal, each group of children is separated by the null value (See examples).&#xA;Example 1:&#xA;Input: root = [1,null,3,2,4,null,5,6] Output: [[1],[3,2,4],[5,6]]&#xA;Example 2:&#xA;Input: root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14] Output: [[1],[2,3,4,5],[6,7,8,9,10],[11,12,13],[14]]&#xA;Constraints:&#xA;The height of the n-ary tree is less than or equal to 1000 The total number of nodes is between [0, 104]</description>
    </item>
    <item>
      <title>973. K Closest Points to Origin </title>
      <link>http://localhost:1313/leetcode/973/</link>
      <pubDate>Sun, 26 Dec 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/973/</guid>
      <description>K Closest Points to Origin - LeetCode&#xA;Given an array of points where points[i] = [xi, yi] represents a point on the X-Y plane and an integer k, return the k closest points to the origin (0, 0). The distance between two points on the X-Y plane is the Euclidean distance (i.e., √(x1 - x2)2 + (y1 - y2)2). You may return the answer in any order. The answer is guaranteed to be unique (except for the order that it is in).</description>
    </item>
    <item>
      <title>994. Rotting Oranges </title>
      <link>http://localhost:1313/leetcode/994/</link>
      <pubDate>Sun, 26 Dec 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/994/</guid>
      <description>Rotting Oranges - LeetCode&#xA;You are given an m x n grid where each cell can have one of three values:&#xA;0 representing an empty cell, 1 representing a fresh orange, or 2 representing a rotten orange.Every minute, any fresh orange that is 4-directionally adjacent to a rotten orange becomes rotten. Return the minimum number of minutes that must elapse until no cell has a fresh orange. If this is impossible, return -1.</description>
    </item>
    <item>
      <title>227. Basic Calculator II</title>
      <link>http://localhost:1313/leetcode/227/</link>
      <pubDate>Sat, 25 Dec 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/227/</guid>
      <description>Basic Calculator II - LeetCode&#xA;Given a string s which represents an expression, evaluate this expression and return its value. The integer division should truncate toward zero. You may assume that the given expression is always valid. All intermediate results will be in the range of [-231, 231 - 1]. Note: You are not allowed to use any built-in function which evaluates strings as mathematical expressions, such as eval().&#xA;Example 1: Input: s = &amp;ldquo;3+2*2&amp;rdquo; Output: 7 Example 2: Input: s = &amp;quot; 3/2 &amp;quot; Output: 1 Example 3: Input: s = &amp;quot; 3+5 / 2 &amp;quot; Output: 5</description>
    </item>
    <item>
      <title>269. Alien Dictionary</title>
      <link>http://localhost:1313/leetcode/269/</link>
      <pubDate>Fri, 24 Dec 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/269/</guid>
      <description>Alien Dictionary - LeetCode&#xA;There is a new alien language that uses the English alphabet. However, the order among the letters is unknown to you. You are given a list of strings words from the alien language&amp;rsquo;s dictionary, where the strings in words are sorted lexicographically by the rules of this new language. Return a string of the unique letters in the new alien language sorted in lexicographically increasing order by the new language&amp;rsquo;s rules.</description>
    </item>
    <item>
      <title>207. Course Schedule </title>
      <link>http://localhost:1313/leetcode/207/</link>
      <pubDate>Thu, 23 Dec 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/207/</guid>
      <description>Course Schedule - LeetCode&#xA;There are a total of numCourses courses you have to take, labeled from 0 to numCourses - 1. You are given an array prerequisites where prerequisites[i] = [ai, bi] indicates that you must take course bi first if you want to take course ai.&#xA;For example, the pair [0, 1], indicates that to take course 0 you have to first take course 1.Return true if you can finish all courses.</description>
    </item>
    <item>
      <title>210. Course Schedule II </title>
      <link>http://localhost:1313/leetcode/210/</link>
      <pubDate>Thu, 23 Dec 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/210/</guid>
      <description>Course Schedule II - LeetCode&#xA;There are a total of numCourses courses you have to take, labeled from 0 to numCourses - 1. You are given an array prerequisites where prerequisites[i] = [ai, bi] indicates that you must take course bi first if you want to take course ai.&#xA;For example, the pair [0, 1], indicates that to take course 0 you have to first take course 1.Return the ordering of courses you should take to finish all courses.</description>
    </item>
    <item>
      <title>1153. String Transforms Into Another String</title>
      <link>http://localhost:1313/leetcode/1153/</link>
      <pubDate>Wed, 22 Dec 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/1153/</guid>
      <description>String Transforms Into Another String - LeetCode&#xA;Given two strings str1 and str2 of the same length, determine whether you can transform str1 into str2 by doing zero or more conversions. In one conversion you can convert all occurrences of one character in str1 to any other lowercase English character. Return true if and only if you can transform str1 into str2.&#xA;Example 1: Input: str1 = &amp;ldquo;aabcc&amp;rdquo;, str2 = &amp;ldquo;ccdee&amp;rdquo; Output: true Explanation: Convert &amp;lsquo;c&amp;rsquo; to &amp;rsquo;e&amp;rsquo; then &amp;lsquo;b&amp;rsquo; to &amp;rsquo;d&amp;rsquo; then &amp;lsquo;a&amp;rsquo; to &amp;lsquo;c&amp;rsquo;.</description>
    </item>
    <item>
      <title>1091. Shortest Path in Binary Matrix </title>
      <link>http://localhost:1313/leetcode/1091/</link>
      <pubDate>Tue, 21 Dec 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/1091/</guid>
      <description>Shortest Path in Binary Matrix - LeetCode&#xA;Given an n x n binary matrix grid, return the length of the shortest clear path in the matrix. If there is no clear path, return -1. A clear path in a binary matrix is a path from the top-left cell (i.e., (0, 0)) to the bottom-right cell (i.e., (n - 1, n - 1)) such that:&#xA;All the visited cells of the path are 0.</description>
    </item>
    <item>
      <title>143. Reorder List </title>
      <link>http://localhost:1313/leetcode/143/</link>
      <pubDate>Tue, 21 Dec 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/143/</guid>
      <description>Reorder List - LeetCode&#xA;You are given the head of a singly linked-list. The list can be represented as: L0 → L1 → … → Ln - 1 → Ln Reorder the list to be on the following form: L0 → Ln → L1 → Ln - 1 → L2 → Ln - 2 → … You may not modify the values in the list&amp;rsquo;s nodes. Only nodes themselves may be changed.</description>
    </item>
    <item>
      <title>231. Power of Two</title>
      <link>http://localhost:1313/leetcode/231/</link>
      <pubDate>Tue, 21 Dec 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/231/</guid>
      <description>Power of Two - LeetCode&#xA;Given an integer n, return true if it is a power of two. Otherwise, return false. An integer n is a power of two, if there exists an integer x such that n == 2x.&#xA;Example 1: Input: n = 1 Output: true Explanation: 20 = 1 Example 2: Input: n = 16 Output: true Explanation: 24 = 16 Example 3: Input: n = 3 Output: false</description>
    </item>
    <item>
      <title>1200. Minimum Absolute Difference</title>
      <link>http://localhost:1313/leetcode/1200/</link>
      <pubDate>Mon, 20 Dec 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/1200/</guid>
      <description>Minimum Absolute Difference - LeetCode Given an array of distinct integers arr, find all pairs of elements with the minimum absolute difference of any two elements. Return a list of pairs in ascending order(with respect to pairs), each pair [a, b] follows&#xA;a, b are from arr a &amp;lt; b b - a equals to the minimum absolute difference of any two elements in arr Example 1: Input: arr = [4,2,1,3] Output: [[1,2],[2,3],[3,4]] Explanation: The minimum absolute difference is 1.</description>
    </item>
    <item>
      <title>332. Reconstruct Itinerary</title>
      <link>http://localhost:1313/leetcode/332/</link>
      <pubDate>Mon, 20 Dec 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/332/</guid>
      <description>Reconstruct Itinerary - LeetCode&#xA;You are given a list of airline tickets where tickets[i] = [fromi, toi] represent the departure and the arrival airports of one flight. Reconstruct the itinerary in order and return it. All of the tickets belong to a man who departs from &amp;ldquo;JFK&amp;rdquo;, thus, the itinerary must begin with &amp;ldquo;JFK&amp;rdquo;. If there are multiple valid itineraries, you should return the itinerary that has the smallest lexical order when read as a single string.</description>
    </item>
    <item>
      <title>1059. All Paths from Source Lead to Destination</title>
      <link>http://localhost:1313/leetcode/1059/</link>
      <pubDate>Sun, 19 Dec 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/1059/</guid>
      <description>All Paths from Source Lead to Destination - LeetCode&#xA;Given the edges of a directed graph where edges[i] = [ai, bi] indicates there is an edge between nodes ai and bi, and two nodes source and destination of this graph, determine whether or not all paths starting from source eventually, end at destination, that is:&#xA;At least one path exists from the source node to the destination node If a path exists from the source node to a node with no outgoing edges, then that node is equal to destination.</description>
    </item>
    <item>
      <title>902. Numbers At Most N Given Digit Set</title>
      <link>http://localhost:1313/leetcode/902/</link>
      <pubDate>Sat, 18 Dec 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/902/</guid>
      <description>Numbers At Most N Given Digit Set - LeetCode&#xA;Given an array of digits which is sorted in non-decreasing order. You can write numbers using each digits[i] as many times as we want. For example, if digits = [&amp;lsquo;1&amp;rsquo;,&amp;lsquo;3&amp;rsquo;,&amp;lsquo;5&amp;rsquo;], we may write numbers such as &amp;lsquo;13&amp;rsquo;, &amp;lsquo;551&amp;rsquo;, and &amp;lsquo;1351315&amp;rsquo;. Return __the number of positive integers that can be generated __that are less than or equal to a given integer n.</description>
    </item>
    <item>
      <title>221. Maximal Square</title>
      <link>http://localhost:1313/leetcode/221/</link>
      <pubDate>Fri, 17 Dec 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/221/</guid>
      <description>Maximal Square - LeetCode Given an m x n binary matrix filled with 0&amp;rsquo;s and 1&amp;rsquo;s, find the largest square containing only 1&amp;rsquo;s and return its area.&#xA;Example 1: Input: matrix = [[&amp;ldquo;1&amp;rdquo;,&amp;ldquo;0&amp;rdquo;,&amp;ldquo;1&amp;rdquo;,&amp;ldquo;0&amp;rdquo;,&amp;ldquo;0&amp;rdquo;],[&amp;ldquo;1&amp;rdquo;,&amp;ldquo;0&amp;rdquo;,&amp;ldquo;1&amp;rdquo;,&amp;ldquo;1&amp;rdquo;,&amp;ldquo;1&amp;rdquo;],[&amp;ldquo;1&amp;rdquo;,&amp;ldquo;1&amp;rdquo;,&amp;ldquo;1&amp;rdquo;,&amp;ldquo;1&amp;rdquo;,&amp;ldquo;1&amp;rdquo;],[&amp;ldquo;1&amp;rdquo;,&amp;ldquo;0&amp;rdquo;,&amp;ldquo;0&amp;rdquo;,&amp;ldquo;1&amp;rdquo;,&amp;ldquo;0&amp;rdquo;]] Output: 4 Example 2:&#xA;Input: matrix = [[&amp;ldquo;0&amp;rdquo;,&amp;ldquo;1&amp;rdquo;],[&amp;ldquo;1&amp;rdquo;,&amp;ldquo;0&amp;rdquo;]] Output: 1 Example 3: Input: matrix = [[&amp;ldquo;0&amp;rdquo;]] Output: 0&#xA;Constraints:&#xA;m == matrix.length n == matrix[i].length 1 &amp;lt;= m, n &amp;lt;= 300 matrix[i][j] is &amp;lsquo;0&amp;rsquo; or &amp;lsquo;1&amp;rsquo;.&#xA;code public class Solution { public int maximalSquare(char[][] matrix) { int rows = matrix.</description>
    </item>
    <item>
      <title>310. Minimum Height Trees</title>
      <link>http://localhost:1313/leetcode/310/</link>
      <pubDate>Thu, 16 Dec 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/310/</guid>
      <description>Minimum Height Trees - LeetCode A tree is an undirected graph in which any two vertices are connected by exactly one path. In other words, any connected graph without simple cycles is a tree. Given a tree of n nodes labelled from 0 to n - 1, and an array of n - 1 edges where edges[i] = [ai, bi] indicates that there is an undirected edge between the two nodes ai and bi in the tree, you can choose any node of the tree as the root.</description>
    </item>
    <item>
      <title>559. Maximum Depth of N-ary Tree</title>
      <link>http://localhost:1313/leetcode/559/</link>
      <pubDate>Thu, 16 Dec 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/559/</guid>
      <description>Maximum Depth of N-ary Tree - LeetCode Given a n-ary tree, find its maximum depth. The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node. Nary-Tree input serialization is represented in their level order traversal, each group of children is separated by the null value (See examples).&#xA;Example 1:&#xA;Input: root = [1,null,3,2,4,null,5,6] Output: 3 Example 2:&#xA;Input: root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14] Output: 5</description>
    </item>
    <item>
      <title>1168. Optimize Water Distribution in a Village</title>
      <link>http://localhost:1313/leetcode/1168/</link>
      <pubDate>Wed, 15 Dec 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/1168/</guid>
      <description>Optimize Water Distribution in a Village - LeetCode There are n houses in a village. We want to supply water for all the houses by building wells and laying pipes. For each house i, we can either build a well inside it directly with cost wells[i - 1] (note the -1 due to 0-indexing), or pipe in water from another well to it. The costs to lay pipes between houses are given by the array pipes, where each pipes[j] = [house1j, house2j, costj] represents the cost to connect house1j and house2j together using a pipe.</description>
    </item>
    <item>
      <title>147. Insertion Sort List</title>
      <link>http://localhost:1313/leetcode/147/</link>
      <pubDate>Wed, 15 Dec 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/147/</guid>
      <description>Insertion Sort List - LeetCode Given the head of a singly linked list, sort the list using insertion sort, and return the sorted list&amp;rsquo;s head. The steps of the insertion sort algorithm:&#xA;Insertion sort iterates, consuming one input element each repetition and growing a sorted output list. At each iteration, insertion sort removes one element from the input data, finds the location it belongs within the sorted list and inserts it there.</description>
    </item>
    <item>
      <title>624. Maximum Distance in Arrays</title>
      <link>http://localhost:1313/leetcode/624/</link>
      <pubDate>Wed, 15 Dec 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/624/</guid>
      <description>Maximum Distance in Arrays - LeetCode You are given m arrays, where each array is sorted in ascending order. You can pick up two integers from two different arrays (each array picks one) and calculate the distance. We define the distance between two integers a and b to be their absolute difference |a - b|. Return the maximum distance.&#xA;Example 1: Input: arrays = [[1,2,3],[4,5],[1,2,3]] Output: 4 Explanation: One way to reach the maximum distance 4 is to pick 1 in the first or third array and pick 5 in the second array.</description>
    </item>
    <item>
      <title>938. Range Sum of BST</title>
      <link>http://localhost:1313/leetcode/938/</link>
      <pubDate>Tue, 14 Dec 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/938/</guid>
      <description>Range Sum of BST - LeetCode&#xA;Given the root node of a binary search tree and two integers low and high, return __the sum of values of all nodes with a value in the inclusive range __[low, high].&#xA;Example 1:&#xA;Input: root = [10,5,15,3,7,null,18], low = 7, high = 15 Output: 32 Explanation: Nodes 7, 10, and 15 are in the range [7, 15]. 7 + 10 + 15 = 32.</description>
    </item>
    <item>
      <title>1101. The Earliest Moment When Everyone Become Friends</title>
      <link>http://localhost:1313/leetcode/1101/</link>
      <pubDate>Mon, 13 Dec 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/1101/</guid>
      <description>The Earliest Moment When Everyone Become Friends - LeetCode There are n people in a social group labeled from 0 to n - 1. You are given an array logs where logs[i] = [timestampi, xi, yi] indicates that xi and yi will be friends at the time timestampi. Friendship is symmetric. That means if a is friends with b, then b is friends with a. Also, person a is acquainted with a person b if a is friends with b, or a is a friend of someone acquainted with b.</description>
    </item>
    <item>
      <title>1446. Consecutive Characters</title>
      <link>http://localhost:1313/leetcode/1446/</link>
      <pubDate>Mon, 13 Dec 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/1446/</guid>
      <description>Consecutive Characters - LeetCode The power of the string is the maximum length of a non-empty substring that contains only one unique character. Given a string s, return the power of s.&#xA;Example 1: Input: s = &amp;ldquo;leetcode&amp;rdquo; Output: 2 Explanation: The substring &amp;ldquo;ee&amp;rdquo; is of length 2 with the character &amp;rsquo;e&amp;rsquo; only.&#xA;code class Solution: def maxPower(self, s: str) -&amp;gt; int: start = 0 res = i = 1 while i &amp;lt; len(s): if s[i] == s[start]: res = max(res, i - start + 1) else: start = i i += 1 return res </description>
    </item>
    <item>
      <title>323. Number of Connected Components in an Undirected Graph</title>
      <link>http://localhost:1313/leetcode/323/</link>
      <pubDate>Sat, 11 Dec 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/323/</guid>
      <description>Number of Connected Components in an Undirected Graph - LeetCode You have a graph of n nodes. You are given an integer n and an array edges where edges[i] = [ai, bi] indicates that there is an edge between ai and bi in the graph. Return the number of connected components in the graph.&#xA;Example 1: Input: n = 5, edges = [[0,1],[1,2],[3,4]] Output: 2&#xA;code class Solution: def countComponents(self, n: int, edges: List[List[int]]) -&amp;gt; int: root = [i for i in range(n)] rank = [1] * n self.</description>
    </item>
    <item>
      <title>364. Nested List Weight Sum II</title>
      <link>http://localhost:1313/leetcode/364/</link>
      <pubDate>Sat, 11 Dec 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/364/</guid>
      <description>Nested List Weight Sum II - LeetCode You are given a nested list of integers nestedList. Each element is either an integer or a list whose elements may also be integers or other lists. The depth of an integer is the number of lists that it is inside of. For example, the nested list [1,[2,2],[[3],2],1] has each integer&amp;rsquo;s value set to its depth. Let maxDepth be the maximum depth of any integer.</description>
    </item>
    <item>
      <title>878. Nth Magical Number</title>
      <link>http://localhost:1313/leetcode/878/</link>
      <pubDate>Sat, 11 Dec 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/878/</guid>
      <description>Nth Magical Number - LeetCode&#xA;A positive integer is magical if it is divisible by either a or b. Given the three integers n, a, and b, return the nth magical number. Since the answer may be very large, return it modulo 109 + 7.&#xA;Example 1: Input: n = 1, a = 2, b = 3 Output: 2 Example 2: Input: n = 4, a = 2, b = 3 Output: 6 Example 3: Input: n = 5, a = 2, b = 4 Output: 10 code class Solution: def nthMagicalNumber(self, n: int, a: int, b: int) -&amp;gt; int: L = a * b // gcd(a, b) # how many mag nums &amp;lt; x def magnums_belowx(x): return x // a + x // b - x // L l, r = 1, n * min(a, b) while l &amp;lt; r: mid = l + (r - l) // 2 if magnums_belowx(mid) &amp;lt; n: l = mid + 1 else: r = mid return l % (10 ** 9 + 7) code TLE class Solution: def nthMagicalNumber(self, n: int, a: int, b: int) -&amp;gt; int: if a &amp;gt; b: # let a be the small one a, b = b, a # 2, 3, 2+2, 2+2+2(3+3), 2+2+2+2, 3+3+3 # 1, 2, 3, 4, 5, 6 c = 10 ** 9 + 7 ans = lasta = a lasta = lasta + a lastb = b if a == b: lastb = lastb + b for i in range(2, n+1): if lasta &amp;lt; lastb: ans = lasta lasta = (lasta + a) % c elif lasta &amp;gt; lastb: ans = lastb lastb = (lastb + b) % c else: ans = lasta lasta = (lasta + a) % c lastb = (lastb + b) % c return ans </description>
    </item>
    <item>
      <title>261. Graph Valid Tree</title>
      <link>http://localhost:1313/leetcode/261/</link>
      <pubDate>Fri, 10 Dec 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/261/</guid>
      <description>Graph Valid Tree - LeetCode You have a graph of n nodes labeled from 0 to n - 1. You are given an integer n and a list of edges where edges[i] = [ai, bi] indicates that there is an undirected edge between nodes ai and bi in the graph. Return true if the edges of the given graph make up a valid tree, and false otherwise.&#xA;Example 1:&#xA;Input: n = 5, edges = [[0,1],[0,2],[0,3],[1,4]] Output: true Example 2:</description>
    </item>
    <item>
      <title>790. Domino and Tromino Tiling</title>
      <link>http://localhost:1313/leetcode/790/</link>
      <pubDate>Fri, 10 Dec 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/790/</guid>
      <description>You have two types of tiles: a 2 x 1 domino shape and a tromino shape. You may rotate these shapes.&#xA;Given an integer n, return the number of ways to tile an 2 x n board. Since the answer may be very large, return it modulo 109 + 7. In a tiling, every square must be covered by a tile. Two tilings are different if and only if there are two 4-directionally adjacent cells on the board such that exactly one of the tilings has both squares occupied by a tile.</description>
    </item>
    <item>
      <title>1306. Jump Game III</title>
      <link>http://localhost:1313/leetcode/1306/</link>
      <pubDate>Thu, 09 Dec 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/1306/</guid>
      <description>Given an array of non-negative integers arr, you are initially positioned at start index of the array. When you are at index i, you can jump to i + arr[i] or i - arr[i], check if you can reach to any index with value 0. Notice that you can not jump outside of the array at any time.&#xA;Example 1: Input: arr = [4,2,3,0,3,1,2], start = 5 Output: true Explanation: All possible ways to reach at index 3 with value 0 are: index 5 -&amp;gt; index 4 -&amp;gt; index 1 -&amp;gt; index 3 index 5 -&amp;gt; index 6 -&amp;gt; index 4 -&amp;gt; index 1 -&amp;gt; index 3</description>
    </item>
    <item>
      <title>451. Sort Characters By Frequency</title>
      <link>http://localhost:1313/leetcode/451/</link>
      <pubDate>Thu, 09 Dec 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/451/</guid>
      <description>Given a string s, sort it in decreasing order based on the frequency of the characters. The frequency of a character is the number of times it appears in the string. Return the sorted string. If there are multiple answers, return any of them.&#xA;Example 1: Input: s = &amp;ldquo;tree&amp;rdquo; Output: &amp;ldquo;eert&amp;rdquo; Explanation: &amp;rsquo;e&amp;rsquo; appears twice while &amp;lsquo;r&amp;rsquo; and &amp;rsquo;t&amp;rsquo; both appear once. So &amp;rsquo;e&amp;rsquo; must appear before both &amp;lsquo;r&amp;rsquo; and &amp;rsquo;t&amp;rsquo;.</description>
    </item>
    <item>
      <title>719. Find K-th Smallest Pair Distance</title>
      <link>http://localhost:1313/leetcode/719/</link>
      <pubDate>Thu, 09 Dec 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/719/</guid>
      <description>The distance of a pair of integers a and b is defined as the absolute difference between a and b. Given an integer array nums and an integer k, return the kth smallest distance among all the pairs nums[i] and nums[j] where 0 &amp;lt;= i &amp;lt; j &amp;lt; nums.length.&#xA;Example 1: Input: nums = [1,3,1], k = 1 Output: 0 Explanation: Here are all the pairs: (1,3) -&amp;gt; 2 (1,1) -&amp;gt; 0 (3,1) -&amp;gt; 2 Then the 1st smallest distance pair is (1,1), and its distance is 0.</description>
    </item>
    <item>
      <title>367. Valid Perfect Square</title>
      <link>http://localhost:1313/leetcode/367/</link>
      <pubDate>Wed, 08 Dec 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/367/</guid>
      <description>Given a positive integer num, write a function which returns True if num is a perfect square else False. Follow up: Do not use any built-in library function such as sqrt.&#xA;Example 1: Input: num = 16 Output: true&#xA;code class Solution: def isPerfectSquare(self, num: int) -&amp;gt; bool: l, r = 1, num while l &amp;lt;= r: mid = l + (r-l) // 2 if mid * mid &amp;lt; num: l = mid + 1 elif mid * mid &amp;gt; num: r = mid - 1 else: return True return False </description>
    </item>
    <item>
      <title>563. Binary Tree Tilt</title>
      <link>http://localhost:1313/leetcode/563/</link>
      <pubDate>Wed, 08 Dec 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/563/</guid>
      <description>Given the root of a binary tree, return the sum of every tree node&amp;rsquo;s tilt. The tilt of a tree node is the absolute difference between the sum of all left subtree node values and all right subtree nsode values. If a node does not have a left child, then the sum of the left subtree node values is treated as 0. The rule is similar if there the node does not have a right child.</description>
    </item>
    <item>
      <title>744. Find Smallest Letter Greater Than Target</title>
      <link>http://localhost:1313/leetcode/744/</link>
      <pubDate>Wed, 08 Dec 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/744/</guid>
      <description>Given a characters array letters that is sorted in non-decreasing order and a character target, return __the smallest character in the array that is larger than __target. Note that the letters wrap around.&#xA;For example, if target == &#39;z&#39; and letters == [&#39;a&#39;, &#39;b&#39;], the answer is &#39;a&#39;. Example 1: Input: letters = [&amp;ldquo;c&amp;rdquo;,&amp;ldquo;f&amp;rdquo;,&amp;ldquo;j&amp;rdquo;], target = &amp;ldquo;a&amp;rdquo; Output: &amp;ldquo;c&amp;rdquo; Example 2: Input: letters = [&amp;ldquo;c&amp;rdquo;,&amp;ldquo;f&amp;rdquo;,&amp;ldquo;j&amp;rdquo;], target = &amp;ldquo;c&amp;rdquo; Output: &amp;ldquo;f&amp;rdquo;</description>
    </item>
    <item>
      <title>270. Closest Binary Search Tree Value</title>
      <link>http://localhost:1313/leetcode/270/</link>
      <pubDate>Tue, 07 Dec 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/270/</guid>
      <description>Given the root of a binary search tree and a target value, return the value in the BST that is closest to the target.&#xA;Example 1:&#xA;Input: root = [4,2,5,1,3], target = 3.714286 Output: 4&#xA;code class Solution: def closestValue(self, root: Optional[TreeNode], target: float) -&amp;gt; int: mindif = inf res = root.val while root: curdif = abs(root.val - target) if curdif &amp;lt; mindif: mindif = curdif res = root.val if root.</description>
    </item>
    <item>
      <title>702. Search in a Sorted Array of Unknown Size</title>
      <link>http://localhost:1313/leetcode/702/</link>
      <pubDate>Tue, 07 Dec 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/702/</guid>
      <description>This is an interactive problem. You have a sorted array of unique elements and an unknown size. You do not have an access to the array but you can use the ArrayReader interface to access it. You can call ArrayReader.get(i) that:&#xA;returns the value at the ith index (0-indexed) of the secret array (i.e., secret[i]), or returns 231 - 1 if the i is out of the boundary of the array.</description>
    </item>
    <item>
      <title>1217. Minimum Cost to Move Chips to The Same Position</title>
      <link>http://localhost:1313/leetcode/1217/</link>
      <pubDate>Mon, 06 Dec 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/1217/</guid>
      <description>Minimum Cost to Move Chips to The Same Position - LeetCode&#xA;We have n chips, where the position of the ith chip is position[i]. We need to move all the chips to the same position. In one step, we can change the position of the ith chip from position[i] to:&#xA;position[i] + 2 or position[i] - 2 with cost = 0. position[i] + 1 or position[i] - 1 with cost = 1.</description>
    </item>
    <item>
      <title>1290. Convert Binary Number in a Linked List to Integer</title>
      <link>http://localhost:1313/leetcode/1290/</link>
      <pubDate>Mon, 06 Dec 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/1290/</guid>
      <description>Convert Binary Number in a Linked List to Integer - LeetCode&#xA;Given head which is a reference node to a singly-linked list. The value of each node in the linked list is either 0 or 1. The linked list holds the binary representation of a number. Return the decimal value of the number in the linked list.&#xA;Example 1:&#xA;Input: head = [1,0,1] Output: 5 Explanation: (101) in base 2 = (5) in base 10 Example 2:</description>
    </item>
    <item>
      <title>154. Find Minimum in Rotated Sorted Array II</title>
      <link>http://localhost:1313/leetcode/154/</link>
      <pubDate>Mon, 06 Dec 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/154/</guid>
      <description>Suppose an array of length n sorted in ascending order is rotated between 1 and n times. For example, the array nums = [0,1,4,4,5,6,7] might become:&#xA;[4,5,6,7,0,1,4] if it was rotated 4 times. [0,1,4,4,5,6,7] if it was rotated 7 times.Notice that rotating an array [a[0], a[1], a[2], &amp;hellip;, a[n-1]] 1 time results in the array [a[n-1], a[0], a[1], a[2], &amp;hellip;, a[n-2]]. Given the sorted rotated array nums that may contain duplicates, return the minimum element of this array.</description>
    </item>
    <item>
      <title>4. Median of Two Sorted Arrays</title>
      <link>http://localhost:1313/leetcode/4/</link>
      <pubDate>Mon, 06 Dec 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/4/</guid>
      <description>Median of Two Sorted Arrays - LeetCode Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).&#xA;Example 1: Input: nums1 = [1,3], nums2 = [2] Output: 2.00000 Explanation: merged array = [1,2,3] and median is 2. Example 2: Input: nums1 = [1,2], nums2 = [3,4] Output: 2.50000 Explanation: merged array = [1,2,3,4] and median is (2 + 3) / 2 = 2.</description>
    </item>
    <item>
      <title>540. Single Element in a Sorted Array</title>
      <link>http://localhost:1313/leetcode/540/</link>
      <pubDate>Mon, 06 Dec 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/540/</guid>
      <description>Single Element in a Sorted Array - LeetCode You are given a sorted array consisting of only integers where every element appears exactly twice, except for one element which appears exactly once. Return the single element that appears only once. Your solution must run in O(log n) time and O(1) space.&#xA;Example 1: Input: nums = [1,1,2,3,3,4,4,8,8] Output: 2 Example 2: Input: nums = [3,3,7,7,10,11,11] Output: 10&#xA;code class Solution { public int singleNonDuplicate(int[] nums) { int begin = 0, end = nums.</description>
    </item>
    <item>
      <title>337. House Robber III</title>
      <link>http://localhost:1313/leetcode/337/</link>
      <pubDate>Sun, 05 Dec 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/337/</guid>
      <description>The thief has found himself a new place for his thievery again. There is only one entrance to this area, called root. Besides the root, each house has one and only one parent house. After a tour, the smart thief realized that all houses in this place form a binary tree. It will automatically contact the police if two directly-linked houses were broken into on the same night. Given the root of the binary tree, return the maximum amount of money the thief can rob without alerting the police.</description>
    </item>
    <item>
      <title>496. Next Greater Element I</title>
      <link>http://localhost:1313/leetcode/496/</link>
      <pubDate>Sun, 05 Dec 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/496/</guid>
      <description>The next greater element of some element x in an array is the first greater element that is to the right of x in the same array. You are given two distinct 0-indexed integer arrays nums1 and nums2, where nums1 is a subset of nums2. For each 0 &amp;lt;= i &amp;lt; nums1.length, find the index j such that nums1[i] == nums2[j] and determine the next greater element of nums2[j] in nums2.</description>
    </item>
    <item>
      <title>1032. Stream of Characters</title>
      <link>http://localhost:1313/leetcode/1032/</link>
      <pubDate>Sat, 04 Dec 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/1032/</guid>
      <description>Design an algorithm that accepts a stream of characters and checks if a suffix of these characters is a string of a given array of strings words. For example, if words = [&amp;ldquo;abc&amp;rdquo;, &amp;ldquo;xyz&amp;rdquo;] and the stream added the four characters (one by one) &amp;lsquo;a&amp;rsquo;, &amp;lsquo;x&amp;rsquo;, &amp;lsquo;y&amp;rsquo;, and &amp;lsquo;z&amp;rsquo;, your algorithm should detect that the suffix &amp;ldquo;xyz&amp;rdquo; of the characters &amp;ldquo;axyz&amp;rdquo; matches &amp;ldquo;xyz&amp;rdquo; from words. Implement the StreamChecker class:&#xA;StreamChecker(String[] words) Initializes the object with the strings array words.</description>
    </item>
    <item>
      <title>152. Maximum product subarray</title>
      <link>http://localhost:1313/leetcode/152/</link>
      <pubDate>Fri, 03 Dec 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/152/</guid>
      <description>Given an integer array nums, find a contiguous non-empty subarray within the array that has the largest product, and return the product. It is guaranteed that the answer will fit in a 32-bit integer. A subarray is a contiguous subsequence of the array.&#xA;Example 1: Input: nums = [2,3,-2,4] Output: 6 Explanation: [2,3] has the largest product 6.&#xA;code class Solution: def maxProduct(self, nums: List[int]) -&amp;gt; int: self.res = nums[0] def cal(nums): # nums doesn&amp;#39;t have 0 if not nums: return l, r = 0, len(nums)-1 cur_res = prod(nums[l:r+1]) if cur_res &amp;gt; 0: self.</description>
    </item>
    <item>
      <title>633. Sum of square numbers</title>
      <link>http://localhost:1313/leetcode/633/</link>
      <pubDate>Fri, 03 Dec 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/633/</guid>
      <description>Sum of Square Numbers - LeetCode&#xA;Given a non-negative integer c, decide whether there&amp;rsquo;re two integers a and b such that a2 + b2 = c.&#xA;Example 1: Input: c = 5 Output: true Explanation: 1 * 1 + 2 * 2 = 5 Example 2: Input: c = 3 Output: false&#xA;code class Solution: def judgeSquareSum(self, c: int) -&amp;gt; bool: l, r = 0, int(c ** 0.5) while l &amp;lt;= r: res = l ** 2 + r ** 2 if res &amp;lt; c: l += 1 elif res &amp;gt; c: r -= 1 else: return True return False </description>
    </item>
    <item>
      <title>680. Valid Palindrome II</title>
      <link>http://localhost:1313/leetcode/680/</link>
      <pubDate>Fri, 03 Dec 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/680/</guid>
      <description>Given a string s, return true if the s can be palindrome after deleting at most one character from it.&#xA;Example 1: Input: s = &amp;ldquo;aba&amp;rdquo; Output: true Example 2: Input: s = &amp;ldquo;abca&amp;rdquo; Output: true Explanation: You could delete the character &amp;lsquo;c&amp;rsquo;.&#xA;code class Solution: def validPalindrome(self, s: str) -&amp;gt; bool: def helper(s): return s == s[::-1] l, r = 0, len(s) - 1 while l &amp;lt; r: if s[l] == s[r]: l += 1 r -= 1 else: if s[l] == s[r-1]: r -= 1 if helper(s[l:r+1]): return True r += 1 if s[l+1] == s[r]: l += 1 if helper(s[l:r+1]): return True return False return True code class Solution: def validPalindrome(self, s: str) -&amp;gt; bool: l, r = 0, len(s) - 1 while l &amp;lt; r: if s[l] !</description>
    </item>
    <item>
      <title>85.  Maximal Rectangle</title>
      <link>http://localhost:1313/leetcode/85/</link>
      <pubDate>Tue, 30 Nov 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/85/</guid>
      <description>Given a rows x cols binary matrix filled with 0&amp;rsquo;s and 1&amp;rsquo;s, find the largest rectangle containing only 1&amp;rsquo;s and return its area.&#xA;Example 1:&#xA;Input: matrix = [[&amp;ldquo;1&amp;rdquo;,&amp;ldquo;0&amp;rdquo;,&amp;ldquo;1&amp;rdquo;,&amp;ldquo;0&amp;rdquo;,&amp;ldquo;0&amp;rdquo;],[&amp;ldquo;1&amp;rdquo;,&amp;ldquo;0&amp;rdquo;,&amp;ldquo;1&amp;rdquo;,&amp;ldquo;1&amp;rdquo;,&amp;ldquo;1&amp;rdquo;],[&amp;ldquo;1&amp;rdquo;,&amp;ldquo;1&amp;rdquo;,&amp;ldquo;1&amp;rdquo;,&amp;ldquo;1&amp;rdquo;,&amp;ldquo;1&amp;rdquo;],[&amp;ldquo;1&amp;rdquo;,&amp;ldquo;0&amp;rdquo;,&amp;ldquo;0&amp;rdquo;,&amp;ldquo;1&amp;rdquo;,&amp;ldquo;0&amp;rdquo;]] Output: 6 Explanation: The maximal rectangle is shown in the above picture.&#xA;code class Solution: def maximalRectangle(self, matrix: List[List[str]]) -&amp;gt; int: if not matrix: return 0 def calRecHistogram(height): stack = [-1] maxArea = 0 for i in range(len(height)): while stack[-1] != -1 and height[i] &amp;lt;= height[stack[-1]]: curHeight = height[stack.</description>
    </item>
    <item>
      <title>286. Walls and Gates</title>
      <link>http://localhost:1313/leetcode/286/</link>
      <pubDate>Mon, 29 Nov 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/286/</guid>
      <description>You are given an m x n grid rooms initialized with these three possible values.&#xA;-1 A wall or an obstacle. 0 A gate. INF Infinity means an empty room. We use the value 231 - 1 = 2147483647 to represent INF as you may assume that the distance to a gate is less than 2147483647.Fill each empty room with the distance to __its nearest gate__. If it is impossible to reach a gate, it should be filled with INF.</description>
    </item>
    <item>
      <title>346. Moving Average from Data Stream</title>
      <link>http://localhost:1313/leetcode/346/</link>
      <pubDate>Mon, 29 Nov 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/346/</guid>
      <description>Given a stream of integers and a window size, calculate the moving average of all integers in the sliding window. Implement the MovingAverage class:&#xA;MovingAverage(int size) Initializes the object with the size of the window size. double next(int val) Returns the moving average of the last size values of the stream.&#xA;Example 1: Input [&amp;ldquo;MovingAverage&amp;rdquo;, &amp;ldquo;next&amp;rdquo;, &amp;ldquo;next&amp;rdquo;, &amp;ldquo;next&amp;rdquo;, &amp;ldquo;next&amp;rdquo;] [[3], [1], [10], [3], [5]] Output [null, 1.0, 5.5, 4.66667, 6.0]</description>
    </item>
    <item>
      <title>721. Accounts Merge</title>
      <link>http://localhost:1313/leetcode/721/</link>
      <pubDate>Mon, 29 Nov 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/721/</guid>
      <description>Given a list of accounts where each element accounts[i] is a list of strings, where the first element accounts[i][0] is a name, and the rest of the elements are emails representing emails of the account. Now, we would like to merge these accounts. Two accounts definitely belong to the same person if there is some common email to both accounts. Note that even if two accounts have the same name, they may belong to different people as people could have the same name.</description>
    </item>
    <item>
      <title>435. Non-overlapping intervals</title>
      <link>http://localhost:1313/leetcode/435/</link>
      <pubDate>Sat, 27 Nov 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/435/</guid>
      <description>Given an array of intervals intervals where intervals[i] = [starti, endi], return the minimum number of intervals you need to remove to make the rest of the intervals non-overlapping.&#xA;Example 1: Input: intervals = [[1,2],[2,3],[3,4],[1,3]] Output: 1 Explanation: [1,3] can be removed and the rest of the intervals are non-overlapping.&#xA;Example 2: Input: intervals = [[1,2],[1,2],[1,2]] Output: 2 Explanation: You need to remove two [1,2] to make the rest of the intervals non-overlapping.</description>
    </item>
    <item>
      <title>708. Insert into a Sorted Circular Linked List</title>
      <link>http://localhost:1313/leetcode/708/</link>
      <pubDate>Sat, 27 Nov 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/708/</guid>
      <description>Given a Circular Linked List node, which is sorted in ascending order, write a function to insert a value insertVal into the list such that it remains a sorted circular list. The given node can be a reference to any single node in the list and may not necessarily be the smallest value in the circular list. If there are multiple suitable places for insertion, you may choose any place to insert the new value.</description>
    </item>
    <item>
      <title>605. Can Place Flowers</title>
      <link>http://localhost:1313/leetcode/605/</link>
      <pubDate>Fri, 26 Nov 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/605/</guid>
      <description>Can Place Flowers - LeetCode&#xA;You have a long flowerbed in which some of the plots are planted, and some are not. However, flowers cannot be planted in adjacent plots. Given an integer array flowerbed containing 0&amp;rsquo;s and 1&amp;rsquo;s, where 0 means empty and 1 means not empty, and an integer n, return if n new flowers can be planted in the flowerbed without violating the no-adjacent-flowers rule.&#xA;Example 1: Input: flowerbed = [1,0,0,0,1], n = 1 Output: true Example 2: Input: flowerbed = [1,0,0,0,1], n = 2 Output: false code class Solution(object): def canPlaceFlowers(self, flowerbed, n): &amp;#34;&amp;#34;&amp;#34; :type flowerbed: List[int] :type n: int :rtype: bool &amp;#34;&amp;#34;&amp;#34; flowerbed = [0] + flowerbed + [0] i = 1 while i &amp;lt; len(flowerbed)-1 and n &amp;gt; 0: if flowerbed[i-1] == flowerbed[i] == flowerbed[i+1] == 0: n -= 1 i += 2 else: i += 1 return n == 0 code class Solution(object): def canPlaceFlowers(self, flowerbed, n): &amp;#34;&amp;#34;&amp;#34; :type flowerbed: List[int] :type n: int :rtype: bool &amp;#34;&amp;#34;&amp;#34; i = 0 while i &amp;lt; len(flowerbed) and n &amp;gt; 0: if (flowerbed[i] == 0 and (i == 0 or flowerbed[i-1] == 0) and (i == len(flowerbed)-1 or flowerbed[i+1] == 0)): n -= 1 i += 2 else: i += 1 return n == 0 </description>
    </item>
    <item>
      <title>250. Count Univalue Subtrees</title>
      <link>http://localhost:1313/leetcode/250/</link>
      <pubDate>Thu, 25 Nov 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/250/</guid>
      <description>Given the root of a binary tree, return the number of uni-value subtrees. A uni-value subtree means all nodes of the subtree have the same value.&#xA;Example 1:&#xA;Input: root = [5,1,5,5,5,null,5] Output: 4 Example 2: Input: root = [] Output: 0&#xA;code class Solution: def countUnivalSubtrees(self, root): if root is None: return 0 self.count = 0 self.is_uni(root) return self.count def is_uni(self, node): # base case - if the node has no children this is a univalue subtree if node.</description>
    </item>
    <item>
      <title>487. Max Consecutive Ones II</title>
      <link>http://localhost:1313/leetcode/487/</link>
      <pubDate>Tue, 23 Nov 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/487/</guid>
      <description>Given a binary array nums, return the maximum number of consecutive 1&amp;rsquo;s in the array if you can flip at most one 0.&#xA;Example 1: Input: nums = [1,0,1,1,0] Output: 4 Explanation: Flip the first zero will get the maximum number of consecutive 1s. After flipping, the maximum number of consecutive 1s is 4.&#xA;Example 2: Input: nums = [1,0,1,1,0,1] Output: 4&#xA;code class Solution: def findMaxConsecutiveOnes(self, nums: List[int]) -&amp;gt; int: l = r = 0 res = 0 count0 = 0 while r &amp;lt; len(nums): if nums[r] == 0: count0 += 1 while count0 == 2: if nums[l] == 0: count0 -= 1 l += 1 res = max(res, r - l + 1) r += 1 return res code class Solution: def findMaxConsecutiveOnes(self, nums: List[int]) -&amp;gt; int: count_last = count = res = 0 if len(nums) == 1: return 1 for i in range(len(nums)): if nums[i] == 1: count += 1 else: if i &amp;gt;= count + 2 and nums[i-count-2] == 1: res = max(count_last + count + 1, res) count_last = count count = 0 if i &amp;gt;= count + 1 and nums[i-count-1] == 1: res = max(count_last + count + 1, res) if count == 0: return max(res, count_last + 1) return min(max(res, count + 1), len(nums)) </description>
    </item>
    <item>
      <title>216. Combination Sum III</title>
      <link>http://localhost:1313/leetcode/216/</link>
      <pubDate>Sat, 13 Nov 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/216/</guid>
      <description>Find all valid combinations of k numbers that sum up to n such that the following conditions are true:&#xA;Only numbers 1 through 9 are used. Each number is used **at most once**.Return __a list of all possible valid combinations__. The list must not contain the same combination twice, and the combinations may be returned in any order. Example 1: Input: k = 3, n = 7 Output: [[1,2,4]] Explanation: 1 + 2 + 4 = 7 There are no other valid combinations.</description>
    </item>
    <item>
      <title>40. Combination Sum II</title>
      <link>http://localhost:1313/leetcode/40/</link>
      <pubDate>Fri, 12 Nov 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/40/</guid>
      <description>Given a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sum to target. Each number in candidates may only be used once in the combination.&#xA;Note: The solution set must not contain duplicate combinations.&#xA;Example 1: Input: candidates = [10,1,2,7,6,1,5], target = 8 Output: [ [1,1,6], [1,2,5], [1,7], [2,6] ]&#xA;code class Solution: def combinationSum2(self, candidates: List[int], target: int) -&amp;gt; List[List[int]]: candidates.</description>
    </item>
    <item>
      <title>90. Subsets II</title>
      <link>http://localhost:1313/leetcode/90/</link>
      <pubDate>Wed, 10 Nov 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/90/</guid>
      <description>Subsets II - LeetCode&#xA;Given an integer array nums that may contain duplicates, return all possible subsets (the power set). The solution set must not contain duplicate subsets. Return the solution in any order.&#xA;Example 1: Input: nums = [1,2,2] Output: [[],[1],[1,2],[1,2,2],[2],[2,2]]&#xA;code class Solution: def subsetsWithDup(self, nums: List[int]) -&amp;gt; List[List[int]]: res = [] def backtracking(nums, path, res): path = sorted(path) if path not in res: res.append(path) for i in range(len(nums)): backtracking(nums[i+1:], path + [nums[i]], res) backtracking(nums, [], res) return res code class Solution: def subsetsWithDup(self, nums: List[int]) -&amp;gt; List[List[int]]: res = [[]] nums.</description>
    </item>
    <item>
      <title>784. Letter case permutation</title>
      <link>http://localhost:1313/leetcode/784/</link>
      <pubDate>Tue, 09 Nov 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/784/</guid>
      <description>Letter Case Permutation - LeetCode&#xA;Given a string s, we can transform every letter individually to be lowercase or uppercase to create another string. Return a list of all possible strings we could create. You can return the output in any order.&#xA;Example 1: Input: s = &amp;ldquo;a1b2&amp;rdquo; Output: [&amp;ldquo;a1b2&amp;rdquo;,&amp;ldquo;a1B2&amp;rdquo;,&amp;ldquo;A1b2&amp;rdquo;,&amp;ldquo;A1B2&amp;rdquo;]&#xA;code class Solution: def letterCasePermutation(self, s: str) -&amp;gt; List[str]: res = [] def recur(i, sofar): if i == len(s): res.append(sofar) return if s[i].</description>
    </item>
    <item>
      <title>442. Find All Duplicates in an Array</title>
      <link>http://localhost:1313/leetcode/442/</link>
      <pubDate>Tue, 02 Nov 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/442/</guid>
      <description>Given an integer array nums of length n where all the integers of nums are in the range [1, n] and each integer appears once or twice, return an array of all the integers that appears twice. You must write an algorithm that runs in O(n) time and uses only constant extra space.&#xA;Example 1: Input: nums = [4,3,2,7,8,2,3,1] Output: [2,3]&#xA;code flip the coin, if already flipped, then it&amp;rsquo;s twice class Solution: def findDuplicates(self, nums: List[int]) -&amp;gt; List[int]: rs = [] for num in nums: num = abs(num) if nums[num-1] &amp;lt; 0: rs.</description>
    </item>
    <item>
      <title>287. Find the duplicate number</title>
      <link>http://localhost:1313/leetcode/287/</link>
      <pubDate>Mon, 01 Nov 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/287/</guid>
      <description>Given an array of integers nums containing n + 1 integers where each integer is in the range [1, n] inclusive. There is only one repeated number in nums, return this repeated number. You must solve the problem without modifying the array nums and uses only constant extra space.&#xA;Example 1: Input: nums = [1,3,4,2,2] Output: 2&#xA;code class Solution: def findDuplicate(self, nums: List[int]) -&amp;gt; int: slow = fast = finder = 0 while True: slow = nums[slow] fast = nums[nums[fast]] if slow == fast: while finder !</description>
    </item>
    <item>
      <title>1971. find if path exists in graph</title>
      <link>http://localhost:1313/leetcode/1971/</link>
      <pubDate>Tue, 26 Oct 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/1971/</guid>
      <description>Find if Path Exists in Graph - LeetCode There is a bi-directional graph with n vertices, where each vertex is labeled from 0 to n - 1 (inclusive). The edges in the graph are represented as a 2D integer array edges, where each edges[i] = [ui, vi] denotes a bi-directional edge between vertex ui and vertex vi. Every vertex pair is connected by at most one edge, and no vertex has an edge to itself.</description>
    </item>
    <item>
      <title>628. Maximum product of three numbers</title>
      <link>http://localhost:1313/leetcode/628/</link>
      <pubDate>Mon, 25 Oct 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/628/</guid>
      <description>Given an integer array nums, find three numbers whose product is maximum and return the maximum product.&#xA;Example 1: Input: nums = [1,2,3] Output: 6&#xA;Example 2: Input: nums = [1,2,3,4] Output: 24&#xA;code class Solution: def maximumProduct(self, nums: List[int]) -&amp;gt; int: nums.sort() return max(nums[-1] * nums[-2] * nums[-3], nums[0] * nums[1] * nums [-1]) code class Solution: def maximumProduct(self, nums: List[int]) -&amp;gt; int: smallestTwo = [float(&amp;#39;inf&amp;#39;)]*2 largestThree = [float(&amp;#39;-inf&amp;#39;)]*3 for num in nums: if num &amp;lt;= smallestTwo[0]: smallestTwo[0] = num smallestTwo.</description>
    </item>
    <item>
      <title>The Karamazov Brothers is the best novel I have ever read</title>
      <link>http://localhost:1313/posts/book-brothers-karamazov/</link>
      <pubDate>Sun, 24 Oct 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/book-brothers-karamazov/</guid>
      <description>It&amp;rsquo;s simply the best novel I have ever read. I agree with almost every place in the book where you can feel Dostoevsky’s strong point of view and laugh with joy.&#xA;I convinced my father, a few Christian and non-Christian friends to read it, and I&amp;rsquo;m pleased few people already have it in their hands. I definitely will reread it.&#xA;I read it in Chinese, and for different English versions, I compared some reviews and bought Ignat Avsey&amp;rsquo;s English translation.</description>
    </item>
    <item>
      <title>140. word break II</title>
      <link>http://localhost:1313/leetcode/140/</link>
      <pubDate>Sat, 23 Oct 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/140/</guid>
      <description>Given a string s and a dictionary of strings wordDict, add spaces in s to construct a sentence where each word is a valid dictionary word. Return all such possible sentences in any order.&#xA;Note that the same word in the dictionary may be reused multiple times in the segmentation.&#xA;Example 1: Input: s = &amp;ldquo;catsanddog&amp;rdquo;, wordDict = [&amp;ldquo;cat&amp;rdquo;,&amp;ldquo;cats&amp;rdquo;,&amp;ldquo;and&amp;rdquo;,&amp;ldquo;sand&amp;rdquo;,&amp;ldquo;dog&amp;rdquo;] Output: [&amp;ldquo;cats and dog&amp;rdquo;,&amp;ldquo;cat sand dog&amp;rdquo;]&#xA;code dp tabluation class Solution: def wordBreak(self, s: str, wordDict: List[str]) -&amp;gt; List[str]: ansList = [[[None]]] * (len(s) + 1) # [[[None]], [[None]], [[None]].</description>
    </item>
    <item>
      <title>64. Minimum path sum</title>
      <link>http://localhost:1313/leetcode/64/</link>
      <pubDate>Wed, 20 Oct 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/64/</guid>
      <description>Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right, which minimizes the sum of all numbers along its path. Note: You can only move either down or right at any point in time.&#xA;Example 1: Input: grid = [[1,3,1],[1,5,1],[4,2,1]] Output: 7 Explanation: Because the path 1 → 3 → 1 → 1 → 1 minimizes the sum.&#xA;code better dp class Solution: def minPathSum(self, grid): m = len(grid) n = len(grid[0]) for i in range(1, n): grid[0][i] += grid[0][i-1] for i in range(1, m): grid[i][0] += grid[i-1][0] for i in range(1, m): for j in range(1, n): grid[i][j] += min(grid[i-1][j], grid[i][j-1]) return grid[-1][-1] code naive dp class Solution: def minPathSum(self, grid: List[List[int]]) -&amp;gt; int: m, n = len(grid), len(grid[0]) path = {(0,0):grid[0][0]} for x in range(m): for y in range(n): if x == 0 and y == 0: continue if x == 0: path[(x, y)] = path[(x, y-1)] + grid[x][y] elif y == 0: path[(x, y)] = path[(x-1, y)] + grid[x][y] else: path[(x, y)] = min(path[(x, y-1)], path[(x-1, y)]) + grid[x][y] return path[(m-1, n-1)] </description>
    </item>
    <item>
      <title>303. Range sum query immutable</title>
      <link>http://localhost:1313/leetcode/303/</link>
      <pubDate>Fri, 15 Oct 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/303/</guid>
      <description>Given an integer array nums, handle multiple queries of the following type:&#xA;Calculate the sum of the elements of nums between indices left and right inclusive where left &amp;lt;= right.Implement the NumArray class:&#xA;NumArray(int[] nums) Initializes the object with the integer array nums. int sumRange(int left, int right) Returns the sum of the elements of nums between indices left and right inclusive (i.e. nums[left] + nums[left + 1] + &amp;hellip; + nums[right]).</description>
    </item>
    <item>
      <title>leetcode questions: Backtracking</title>
      <link>http://localhost:1313/dev/lee-backtracking/</link>
      <pubDate>Mon, 11 Oct 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/dev/lee-backtracking/</guid>
      <description>Template def backtrack(candidate): if find_solution(candidate): output(candidate) return # iterate all possible candidates. for next_candidate in list_of_candidates: if is_valid(next_candidate): # try this partial candidate solution place(next_candidate) # given the candidate, explore further. backtrack(next_candidate) # backtrack remove(next_candidate) 17. Letter Combinations of a Phone Number Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent. Return the answer in any order.&#xA;A mapping of digit to letters (just like on the telephone buttons) is given below.</description>
    </item>
    <item>
      <title>leetcode questions: BFS</title>
      <link>http://localhost:1313/dev/lee-bfs/</link>
      <pubDate>Mon, 11 Oct 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/dev/lee-bfs/</guid>
      <description>BFS Template /** * Return the length of the shortest path between root and target node. */ int BFS(Node root, Node target) { Queue&amp;lt;Node&amp;gt; queue; // store all nodes which are waiting to be processed Set&amp;lt;Node&amp;gt; visited; // store all the nodes that we&amp;#39;ve visited int step = 0; // number of steps neeeded from root to current node // initialize add root to queue; add root to visited; // BFS while (queue is not empty) { step = step + 1; // iterate the nodes which are already in the queue int size = queue.</description>
    </item>
    <item>
      <title>leetcode questions: DFS</title>
      <link>http://localhost:1313/dev/lee-dfs/</link>
      <pubDate>Mon, 11 Oct 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/dev/lee-dfs/</guid>
      <description>DFS Templates Template 1:&#xA;/* * Return true if there is a path from cur to target. */ boolean DFS(Node cur, Node target, Set&amp;lt;Node&amp;gt; visited) { return true if cur is target; for (next : each neighbor of cur) { if (next is not in visited) { add next to visted; return true if DFS(next, target, visited) == true; } } return false; } Template 2 using an explicit stack to avoid stack overflow:</description>
    </item>
    <item>
      <title>leetcode questions: dynamic programming</title>
      <link>http://localhost:1313/dev/lee-dp/</link>
      <pubDate>Mon, 11 Oct 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/dev/lee-dp/</guid>
      <description>Intro Good video: Dynamic Programming - Learn to Solve Algorithmic Problems &amp;amp; Coding Challenges - YouTube&#xA;DP is a style of coding where you store the results of your algorithm in a data structure while it runs.&#xA;dynamic programming - What is the difference between bottom-up and top-down? - Stack Overflow&#xA;code function dp(dp_state, memo_dict) { // check if we have seen this dp_state if dp_state in memo_dict return memo_dict[dp_state] // base case (a case that we know the answer for already) such as dp_state is empty if dp_state is the base cases return things like 0 or null calculate dp(dp_state) from dp(other_state) save dp_state and the result into memo_dict } function answerToProblem(input) { return dp(start_state, empty_memo_dict) } The same subproblem may reoccur compared to divide-and-conquer, a key to solve is to break the problem into subproblems such that</description>
    </item>
    <item>
      <title>637. Average of levels in binary tree</title>
      <link>http://localhost:1313/leetcode/637/</link>
      <pubDate>Fri, 08 Oct 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/637/</guid>
      <description>Given the root of a binary tree, return the average value of the nodes on each level in the form of an array. Answers within 10-5 of the actual answer will be accepted.&#xA;Example 1:&#xA;Input: root = [3,9,20,null,null,15,7] Output: [3.00000,14.50000,11.00000] Explanation: The average value of nodes on level 0 is 3, on level 1 is 14.5, and on level 2 is 11. Hence return [3, 14.5, 11].&#xA;code class Solution: def averageOfLevels(self, root: Optional[TreeNode]) -&amp;gt; List[float]: res = [] level = [root] while level: res.</description>
    </item>
    <item>
      <title>My story with God</title>
      <link>http://localhost:1313/posts/christian-testimony/</link>
      <pubDate>Thu, 30 Sep 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/christian-testimony/</guid>
      <description>When I was in university in China, for a while I was not busy, and interested in dreams. In my lucid dreams, I knew I was in a dream, I could have keys in my hands by just thinking of keys, and the feeling of keys in my dream was the same as in reality. I felt there’s something beyond this material world, and couldn’t stop reading the next book, new age, Buddhism, psychology, etc.</description>
    </item>
    <item>
      <title>110. Balanced binary tree</title>
      <link>http://localhost:1313/leetcode/110/</link>
      <pubDate>Wed, 22 Sep 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/110/</guid>
      <description>Given a binary tree, determine if it is height-balanced. For this problem, a height-balanced binary tree is defined as: a binary tree in which the left and right subtrees of every node differ in height by no more than 1.&#xA;Example 1:&#xA;Input: root = [3,9,20,null,null,15,7]&#xA;code class Solution: def isBalanced(self, root: Optional[TreeNode]) -&amp;gt; bool: def helper(root, isBalanced = True): if not root: return (-1, True) # height, isBalanced left_height, left_balance = helper(root.</description>
    </item>
    <item>
      <title>450. delete node in a bst</title>
      <link>http://localhost:1313/leetcode/450/</link>
      <pubDate>Fri, 17 Sep 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/450/</guid>
      <description>Given a root node reference of a BST and a key, delete the node with the given key in the BST. Return the root node reference (possibly updated) of the BST. Basically, the deletion can be divided into two stages:&#xA;Search for a node to remove. If the node is found, delete the node.&#xA;Follow up: Can you solve it with time complexity O(height of tree)?&#xA;code class Solution(object): def deleteNode(self, root, key): &amp;#34;&amp;#34;&amp;#34; :type root: TreeNode :type key: int :rtype: TreeNode &amp;#34;&amp;#34;&amp;#34; if not root: return None if root.</description>
    </item>
    <item>
      <title>173. Binary search tree iterator</title>
      <link>http://localhost:1313/leetcode/173/</link>
      <pubDate>Thu, 16 Sep 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/173/</guid>
      <description>Implement the BSTIterator class that represents an iterator over the in-order traversal of a binary search tree (BST):&#xA;BSTIterator(TreeNode root) Initializes an object of the BSTIterator class. The root of the BST is given as part of the constructor. The pointer should be initialized to a non-existent number smaller than any element in the BST. boolean hasNext() Returns true if there exists a number in the traversal to the right of the pointer, otherwise returns false.</description>
    </item>
    <item>
      <title>771. jewels and stones</title>
      <link>http://localhost:1313/leetcode/771/</link>
      <pubDate>Tue, 14 Sep 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/771/</guid>
      <description>You&amp;rsquo;re given strings jewels representing the types of stones that are jewels, and stones representing the stones you have. Each character in stones is a type of stone you have. You want to know how many of the stones you have are also jewels. Letters are case sensitive, so &amp;ldquo;a&amp;rdquo; is considered a different type of stone from &amp;ldquo;A&amp;rdquo;.&#xA;Example 1: Input: jewels = &amp;ldquo;aA&amp;rdquo;, stones = &amp;ldquo;aAAbbbb&amp;rdquo; Output: 3</description>
    </item>
    <item>
      <title>652. Find duplicate subtrees</title>
      <link>http://localhost:1313/leetcode/652/</link>
      <pubDate>Fri, 10 Sep 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/652/</guid>
      <description>Given the root of a binary tree, return all duplicate subtrees. For each kind of duplicate subtrees, you only need to return the root node of any one of them. Two trees are duplicate if they have the same structure with the same node values.&#xA;Example 1:&#xA;Input: root = [1,2,3,4,null,2,4,null,null,4] Output: [[2,4],[4]]&#xA;code class Solution: # key the sub tree, value, value is count of this sub tree def findDuplicateSubtrees(self, root: TreeNode) -&amp;gt; List[TreeNode]: if root is None: return [] self.</description>
    </item>
    <item>
      <title>219. Contains duplicate II</title>
      <link>http://localhost:1313/leetcode/219/</link>
      <pubDate>Wed, 08 Sep 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/219/</guid>
      <description>Given an integer array nums and an integer k, return true if there are two distinct indices i and j in the array such that nums[i] == nums[j] and abs(i - j) &amp;lt;= k.&#xA;Example 1: Input: nums = [1,2,3,1], k = 3 Output: true&#xA;code class Solution: def containsNearbyDuplicate(self, nums, k): dic = {} for i, v in enumerate(nums): if v in dic and i - dic[v] &amp;lt;= k: return True else: dic[v] = i return False </description>
    </item>
    <item>
      <title>349. Intersection of two arrays</title>
      <link>http://localhost:1313/leetcode/349/</link>
      <pubDate>Wed, 08 Sep 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/349/</guid>
      <description>Given two integer arrays nums1 and nums2, return an array of their intersection. Each element in the result must be unique and you may return the result in any order.&#xA;Example 1: Input: nums1 = [1,2,2,1], nums2 = [2,2] Output: [2]&#xA;code class Solution: def intersection(self, nums1, nums2): return list(set(nums1) &amp;amp; set(nums2)) code class Solution: def intersection(self, nums1: List[int], nums2: List[int]) -&amp;gt; List[int]: return set(nums1).intersection(set(nums2)) code class Solution(object): def intersection(self, nums1, nums2): res = [] nums1.</description>
    </item>
    <item>
      <title>705. Design hash set</title>
      <link>http://localhost:1313/leetcode/705/</link>
      <pubDate>Mon, 06 Sep 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/705/</guid>
      <description>Design HashSet - LeetCode Design a HashSet without using any built-in hash table libraries. Implement MyHashSet class:&#xA;void add(key) Inserts the value key into the HashSet. bool contains(key) Returns whether the value key exists in the HashSet or not. void remove(key) Removes the value key in the HashSet. If key does not exist in the HashSet, do nothing. code class MyHashSet { LinkedList[] list; public MyHashSet() { list = new LinkedList[713]; // Arrays.</description>
    </item>
    <item>
      <title>658. Find k closest elements</title>
      <link>http://localhost:1313/leetcode/658/</link>
      <pubDate>Mon, 30 Aug 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/658/</guid>
      <description>Given a sorted integer array arr, two integers k and x, return the k closest integers to x in the array. The result should also be sorted in ascending order. An integer a is closer to x than an integer b if:&#xA;|a - x| &amp;lt; |b - x|, or |a - x| == |b - x| and a &amp;lt; b Example 1: Input: arr = [1,2,3,4,5], k = 4, x = 3 Output: [1,2,3,4]</description>
    </item>
    <item>
      <title>374. Guess number higher or lower</title>
      <link>http://localhost:1313/leetcode/374/</link>
      <pubDate>Wed, 25 Aug 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/374/</guid>
      <description>We are playing the Guess Game. The game is as follows: I pick a number from 1 to n. You have to guess which number I picked. Every time you guess wrong, I will tell you whether the number I picked is higher or lower than your guess. You call a pre-defined API int guess(int num), which returns 3 possible results:&#xA;-1: The number I picked is lower than your guess (i.</description>
    </item>
    <item>
      <title>704. binary search</title>
      <link>http://localhost:1313/leetcode/704/</link>
      <pubDate>Tue, 24 Aug 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/704/</guid>
      <description>Given an array of integers nums which is sorted in ascending order, and an integer target, write a function to search target in nums. If target exists, then return its index. Otherwise, return -1. You must write an algorithm with O(log n) runtime complexity.&#xA;Example 1: Input: nums = [-1,0,3,5,9,12], target = 9 Output: 4 Explanation: 9 exists in nums and its index is 4&#xA;code class Solution: def search(self, nums: List[int], target: int) -&amp;gt; int: left, right = 0, len(nums)-1 while left &amp;lt;= right: mid = left + (right-left)//2 if nums[mid] == target: return mid elif target &amp;gt; nums[mid]: left = mid + 1 else: right = mid - 1 return -1 code class Solution: def search(self, nums: List[int], target: int) -&amp;gt; int: def binary_search(start, end): if start &amp;gt; end: return -1 mid = start + (end-start) // 2 if nums[mid] == target: return mid elif nums[mid] &amp;lt; target: return binary_search(mid+1, end) elif nums[mid] &amp;gt; target: return binary_search(start, mid-1) return binary_search(0, len(nums)-1) </description>
    </item>
    <item>
      <title>Shadian, a war between Communists and Muslims in China 1975</title>
      <link>http://localhost:1313/posts/story-shadian/</link>
      <pubDate>Sat, 21 Aug 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/story-shadian/</guid>
      <description>During the Cultural Revolution, communists were supposed to eliminate all religious and old cultures, including Confucious, Christianity, Buddism, and Muslim as well.&#xA;The communist army put pigs&amp;rsquo; heads in the Muslim community&amp;rsquo;s well. The tension kept growing, the Muslim elite from Shadian went to Beijing to talk about the situation with communist leaders, and when they came back they knew the situation was going to be worse. Obviously, they felt what was going to happen, one of the elites begged their Muslim people to send women and children out, but people were so angry and refused and thought he has betrayed them.</description>
    </item>
    <item>
      <title>47. Permutations II</title>
      <link>http://localhost:1313/leetcode/47/</link>
      <pubDate>Tue, 17 Aug 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/47/</guid>
      <description>Permutations II - LeetCode&#xA;Given a collection of numbers, nums, that might contain duplicates, return all possible unique permutations in any order.&#xA;Example 1: Input: nums = [1,1,2] Output: [[1,1,2], [1,2,1], [2,1,1]] Example 2: Input: nums = [1,2,3] Output: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]&#xA;code class Solution: def permuteUnique(self, nums: List[int]) -&amp;gt; List[List[int]]: def dfs(nums, cur, res): if not nums: res.append(cur) return visited = set() for i,num in enumerate(nums): if num not in visited: visited.</description>
    </item>
    <item>
      <title>77. combinations</title>
      <link>http://localhost:1313/leetcode/77/</link>
      <pubDate>Thu, 12 Aug 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/77/</guid>
      <description>Combinations - LeetCode&#xA;Given two integers n and k, return all possible combinations of k numbers out of the range [1, n]. You may return the answer in any order.&#xA;Example 1: Input: n = 4, k = 2 Output: [ [2,4], [3,4], [2,3], [1,2], [1,3], [1,4], ]&#xA;code dfs class Solution: def combine(self, n: int, k: int) -&amp;gt; List[List[int]]: result = [] def gen_comb(start, cur_comb): if k == len(cur_comb): result.</description>
    </item>
    <item>
      <title>37. sudoku solver</title>
      <link>http://localhost:1313/leetcode/37/</link>
      <pubDate>Tue, 10 Aug 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/37/</guid>
      <description>Sudoku Solver - LeetCode&#xA;Write a program to solve a Sudoku puzzle by filling the empty cells. A sudoku solution must satisfy all of the following rules:&#xA;Each of the digits 1-9 must occur exactly once in each row. Each of the digits 1-9 must occur exactly once in each column. Each of the digits 1-9 must occur exactly once in each of the 9 3x3 sub-boxes of the grid.The &#39;.</description>
    </item>
    <item>
      <title>52. N-Queens II</title>
      <link>http://localhost:1313/leetcode/52/</link>
      <pubDate>Wed, 28 Jul 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/52/</guid>
      <description>N-Queens II - LeetCode&#xA;The n-queens puzzle is the problem of placing n queens on an n x n chessboard such that no two queens attack each other. Given an integer n, return the number of distinct solutions to the n-queens puzzle.&#xA;Example 1:&#xA;Input: n = 4 Output: 2 Explanation: There are two distinct solutions to the 4-queens puzzle as shown.&#xA;code def totalNQueens(self, n): self.res = 0 self.dfs([-1]*n, 0) return self.</description>
    </item>
    <item>
      <title>912. sort an array</title>
      <link>http://localhost:1313/leetcode/912/</link>
      <pubDate>Fri, 23 Jul 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/912/</guid>
      <description>Given an array of integers nums, sort the array in ascending order. quick sort py&#xA;code class Solution: def sortArray(self, nums: List[int]) -&amp;gt; List[int]: self.quickSort(nums, 0, len(nums)-1) return nums def quickSort(self, arr, left, right): mid = (left + right) // 2 arr[mid], arr[right] = arr[right], arr[mid] # pick the mid as pivot every time if left &amp;lt; right: pivot = self.partition(arr, left, right) self.quickSort(arr, left, pivot-1) self.quickSort(arr, pivot+1, right) def partition(self, arr, left, right): i = left pivot = arr[right] for n in range(left, right): if arr[n] &amp;lt; pivot: arr[i], arr[n] = arr[n], arr[i] i += 1 arr[right], arr[i] = arr[i], arr[right] return i code class Solution(object): def sortArray(self, nums): self.</description>
    </item>
    <item>
      <title>95. Unique binary search tree II</title>
      <link>http://localhost:1313/leetcode/95/</link>
      <pubDate>Thu, 08 Jul 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/95/</guid>
      <description>Given an integer n, return all the structurally unique **BST&amp;rsquo;**s (binary search trees), which has exactly n nodes of unique values from 1 to n. Return the answer in any order.&#xA;Example 1:&#xA;Input: n = 3 Output: [[1,null,2,null,3],[1,null,3,2],[2,1,3],[3,1,null,null,2],[3,2,null,1]]&#xA;95*. Unique Binary Search Trees II · leetcode&#xA;code class Solution: def generateTrees(self, n): def generate(first, last): trees = [] for root in range(first, last+1): for left in generate(first, root-1): for right in generate(root+1, last): node = TreeNode(root) node.</description>
    </item>
    <item>
      <title>779. K-th Symbol in Grammar</title>
      <link>http://localhost:1313/leetcode/779/</link>
      <pubDate>Mon, 28 Jun 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/779/</guid>
      <description>We build a table of n rows (1-indexed). We start by writing 0 in the 1st row. Now in every subsequent row, we look at the previous row and replace each occurrence of 0 with 01, and each occurrence of 1 with 10.&#xA;For example, for n = 3, the 1st row is 0, the 2nd row is 01, and the 3rd row is 0110.Given two integer n and k, return the kth (1-indexed) symbol in the nth row of a table of n rows.</description>
    </item>
    <item>
      <title>We love because He first loved us, not meaningless self love</title>
      <link>http://localhost:1313/posts/christian-god-loved-us-not-self-love/</link>
      <pubDate>Mon, 21 Jun 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/christian-god-loved-us-not-self-love/</guid>
      <description>Self-esteem, self-love, self-help, self-respect, self, self, self.&#xA;You can&amp;rsquo;t love others properly without loving yourself at first. - popular idea&#xA;We love because He first loved us. 1 John 4: 19&#xA;Mental states do not come before language nor accompany a sequence of words but are lived and experienced in the context of linguistic expression. -Wittgenstein&#xA;It&amp;rsquo;s wrong from a syntax perspective at first. Help, love, respect, and care, when we use these words, they are usually correctly used to describe the relationship between people.</description>
    </item>
    <item>
      <title>Modern Java in Action code configuration in intellij</title>
      <link>http://localhost:1313/dev/java-modern-java-intellij/</link>
      <pubDate>Thu, 10 Jun 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/dev/java-modern-java-intellij/</guid>
      <description>There&amp;rsquo;s source code in this page.&#xA;Set up the language level to 9 and then compile works for me.&#xA;This is the pom works for me.&#xA;&amp;lt;?xml version=&amp;#34;1.0&amp;#34; encoding=&amp;#34;UTF-8&amp;#34;?&amp;gt; &amp;lt;project xmlns=&amp;#34;http://maven.apache.org/POM/4.0.0&amp;#34; xmlns:xsi=&amp;#34;http://www.w3.org/2001/XMLSchema-instance&amp;#34; xsi:schemaLocation=&amp;#34;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&amp;#34;&amp;gt; &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt; &amp;lt;groupId&amp;gt;manning&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;modernjavainaction&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;2.0&amp;lt;/version&amp;gt; &amp;lt;properties&amp;gt; &amp;lt;project.build.sourceEncoding&amp;gt;UTF-8&amp;lt;/project.build.sourceEncoding&amp;gt; &amp;lt;/properties&amp;gt; &amp;lt;dependencies&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.openjdk.jmh&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;jmh-core&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.21&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.openjdk.jmh&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;jmh-generator-annprocess&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.21&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;io.reactivex.rxjava2&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;rxjava&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;2.2.2&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;com.typesafe.akka&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;akka-actor_2.12&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;2.5.16&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;com.typesafe.akka&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;akka-stream_2.12&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;2.5.16&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;junit&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;junit&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;4.</description>
    </item>
    <item>
      <title>119. Pascal triangle II</title>
      <link>http://localhost:1313/leetcode/119/</link>
      <pubDate>Wed, 09 Jun 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/119/</guid>
      <description>Given an integer rowIndex, return the rowIndexth (0-indexed) row of the Pascal&amp;rsquo;s triangle. In Pascal&amp;rsquo;s triangle, each number is the sum of the two numbers directly above it as shown: Example 1: Input: rowIndex = 3 Output: [1,3,3,1] Example 2: Input: rowIndex = 0 Output: [1]&#xA;code class Solution: def getRow(self, rowIndex: int) -&amp;gt; List[int]: if rowIndex == 0: return [1] elif rowIndex == 1: return [1,1] def next(row): cur = [1] for i in range(len(row)-1): cur.</description>
    </item>
    <item>
      <title>509. Fibonacci number</title>
      <link>http://localhost:1313/leetcode/509/</link>
      <pubDate>Wed, 09 Jun 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/509/</guid>
      <description>he Fibonacci numbers, commonly denoted F(n) form a sequence, called the Fibonacci sequence, such that each number is the sum of the two preceding ones, starting from 0 and 1. That is, F(0) = 0, F(1) = 1 F(n) = F(n - 1) + F(n - 2), for n &amp;gt; 1. Given n, calculate F(n).&#xA;Example 1: Input: n = 2 Output: 1 Explanation: F(2) = F(1) + F(0) = 1 + 0 = 1.</description>
    </item>
    <item>
      <title>700. Search in a binary search tree</title>
      <link>http://localhost:1313/leetcode/700/</link>
      <pubDate>Wed, 09 Jun 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/700/</guid>
      <description>You are given the root of a binary search tree (BST) and an integer val. Find the node in the BST that the node&amp;rsquo;s value equals val and return the subtree rooted with that node. If such a node does not exist, return null.&#xA;Example 1:&#xA;Input: root = [4,2,7,1,3], val = 2 Output: [2,1,3]&#xA;code class Solution: def searchBST(self, root: TreeNode, val: int) -&amp;gt; TreeNode: def rec(root): if root: if root.</description>
    </item>
    <item>
      <title>841. Keys and rooms</title>
      <link>http://localhost:1313/leetcode/841/</link>
      <pubDate>Tue, 08 Jun 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/841/</guid>
      <description>There are N rooms and you start in room 0. Each room has a distinct number in 0, 1, 2, &amp;hellip;, N-1, and each room may have some keys to access the next room. Formally, each room i has a list of keys rooms[i], and each key rooms[i][j] is an integer in [0, 1, &amp;hellip;, N-1] where N = rooms.length. A key rooms[i][j] = v opens the room with number v.</description>
    </item>
    <item>
      <title>542. 01-matrix</title>
      <link>http://localhost:1313/leetcode/542/</link>
      <pubDate>Mon, 07 Jun 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/542/</guid>
      <description>Given an m x n binary matrix mat, return the distance of the nearest 0 for each cell. The distance between two adjacent cells is 1.&#xA;Example 1:&#xA;Input: mat = [[0,0,0],[0,1,0],[0,0,0]] Output: [[0,0,0],[0,1,0],[0,0,0]]&#xA;code class Solution: def updateMatrix(self, matrix): m, n = len(matrix), len(matrix and matrix[0]) for i in range(m): for j in range(n): if matrix[i][j] != 0: matrix[i][j] = float(&amp;#34;inf&amp;#34;) if i &amp;gt; 0 and matrix[i - 1][j] + 1 &amp;lt; matrix[i][j]: matrix[i][j] = matrix[i - 1][j] + 1 if j &amp;gt; 0 and matrix[i][j - 1] + 1 &amp;lt; matrix[i][j]: matrix[i][j] = matrix[i][j - 1] + 1 for i in range(m - 1, -1, -1): for j in range(n - 1, -1, -1): if matrix[i][j] !</description>
    </item>
    <item>
      <title>733. Flood fill</title>
      <link>http://localhost:1313/leetcode/733/</link>
      <pubDate>Fri, 04 Jun 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/733/</guid>
      <description>CompaniesAn image is represented by an m x n integer grid image where image[i][j] represents the pixel value of the image. You are also given three integers sr, sc, and newColor. You should perform a flood fill on the image starting from the pixel image[sr][sc]. To perform a flood fill, consider the starting pixel, plus any pixels connected 4-directionally to the starting pixel of the same color as the starting pixel, plus any pixels connected 4-directionally to those pixels (also with the same color), and so on.</description>
    </item>
    <item>
      <title>394. Decode string</title>
      <link>http://localhost:1313/leetcode/394/</link>
      <pubDate>Thu, 03 Jun 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/394/</guid>
      <description>Decode String - LeetCode Given an encoded string, return its decoded string. The encoding rule is: k[encoded_string], where the encoded_string inside the square brackets is being repeated exactly k times. Note that k is guaranteed to be a positive integer. You may assume that the input string is always valid; No extra white spaces, square brackets are well-formed, etc. Furthermore, you may assume that the original data does not contain any digits and that digits are only for those repeat numbers, k.</description>
    </item>
    <item>
      <title>494. Target sum</title>
      <link>http://localhost:1313/leetcode/494/</link>
      <pubDate>Wed, 02 Jun 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/494/</guid>
      <description>You are given an integer array nums and an integer target. You want to build an expression out of nums by adding one of the symbols &amp;lsquo;+&amp;rsquo; and &amp;lsquo;-&amp;rsquo; before each integer in nums and then concatenate all the integers.&#xA;For example, if nums = [2, 1], you can add a &#39;+&#39; before 2 and a &#39;-&#39; before 1 and concatenate them to build the expression &amp;quot;+2-1&amp;quot;.Return the number of different **expressions** that you can build, which evaluates to target.</description>
    </item>
    <item>
      <title>133. Clone graph</title>
      <link>http://localhost:1313/leetcode/133/</link>
      <pubDate>Tue, 01 Jun 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/133/</guid>
      <description>Clone Graph - LeetCode&#xA;Given a reference of a node in a connected undirected graph. Return a deep copy (clone) of the graph. Each node in the graph contains a value (int) and a list (List[Node]) of its neighbors. class Node { public int val; public List neighbors; }&#xA;Test case format: For simplicity, each node&amp;rsquo;s value is the same as the node&amp;rsquo;s index (1-indexed). For example, the first node with val == 1, the second node with val == 2, and so on.</description>
    </item>
    <item>
      <title>279. Perfect squares</title>
      <link>http://localhost:1313/leetcode/279/</link>
      <pubDate>Fri, 28 May 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/279/</guid>
      <description>Given an integer n, return the least number of perfect square numbers that sum to n. A perfect square is an integer that is the square of an integer; in other words, it is the product of some integer with itself. For example, 1, 4, 9, and 16 are perfect squares while 3 and 11 are not.&#xA;Example 1: Input: n = 12 Output: 3 Explanation: 12 = 4 + 4 + 4.</description>
    </item>
    <item>
      <title>752. open the lock</title>
      <link>http://localhost:1313/leetcode/752/</link>
      <pubDate>Thu, 27 May 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/752/</guid>
      <description>You have a lock in front of you with 4 circular wheels. Each wheel has 10 slots: &amp;lsquo;0&amp;rsquo;, &amp;lsquo;1&amp;rsquo;, &amp;lsquo;2&amp;rsquo;, &amp;lsquo;3&amp;rsquo;, &amp;lsquo;4&amp;rsquo;, &amp;lsquo;5&amp;rsquo;, &amp;lsquo;6&amp;rsquo;, &amp;lsquo;7&amp;rsquo;, &amp;lsquo;8&amp;rsquo;, &amp;lsquo;9&amp;rsquo;. The wheels can rotate freely and wrap around: for example we can turn &amp;lsquo;9&amp;rsquo; to be &amp;lsquo;0&amp;rsquo;, or &amp;lsquo;0&amp;rsquo; to be &amp;lsquo;9&amp;rsquo;. Each move consists of turning one wheel one slot. The lock initially starts at &amp;lsquo;0000&amp;rsquo;, a string representing the state of the 4 wheels.</description>
    </item>
    <item>
      <title>622. Design circular queue</title>
      <link>http://localhost:1313/leetcode/622/</link>
      <pubDate>Tue, 18 May 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/622/</guid>
      <description>Design your implementation of the circular queue. The circular queue is a linear data structure in which the operations are performed based on FIFO (First In First Out) principle and the last position is connected back to the first position to make a circle. It is also called &amp;ldquo;Ring Buffer&amp;rdquo;. One of the benefits of the circular queue is that we can make use of the spaces in front of the queue.</description>
    </item>
    <item>
      <title>106. construct binary tree from inorder and post order traversal</title>
      <link>http://localhost:1313/leetcode/106/</link>
      <pubDate>Mon, 17 May 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/106/</guid>
      <description>Given two integer arrays inorder and postorder where inorder is the inorder traversal of a binary tree and postorder is the postorder traversal of the same tree, construct and return the binary tree.&#xA;Example 1:&#xA;Input: inorder = [9,3,15,20,7], postorder = [9,15,7,20,3] Output: [3,9,20,null,null,15,7]&#xA;code class Solution: def buildTree(self, inorder, postorder): if not inorder or not postorder: return None root = TreeNode(postorder[-1]) inorderIndex = inorder.index(postorder.pop()) root.right = self.buildTree(inorder[inorderIndex+1:], postorder) root.left = self.</description>
    </item>
    <item>
      <title>112. path sum</title>
      <link>http://localhost:1313/leetcode/112/</link>
      <pubDate>Mon, 17 May 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/112/</guid>
      <description>Given the root of a binary tree and an integer targetSum, return true if the tree has a root-to-leaf path such that adding up all the values along the path equals targetSum. A leaf is a node with no children.&#xA;code class Solution: def hasPathSum(self, root, sum): if not root: return False if not root.left and not root.right and root.val == sum: return True sum -= root.val return self.hasPathSum(root.left, sum) or self.</description>
    </item>
    <item>
      <title>117. Populating Next Right Pointers in Each Node II</title>
      <link>http://localhost:1313/leetcode/117/</link>
      <pubDate>Mon, 17 May 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/117/</guid>
      <description>https://leetcode.com/problems/populating-next-right-pointers-in-each-node-ii/&#xA;Given a binary tree struct Node { int val; Node *left; Node *right; Node *next; } Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL. Initially, all next pointers are set to NULL.&#xA;code class Solution: def connect(self, root: &amp;#39;Node&amp;#39;) -&amp;gt; &amp;#39;Node&amp;#39;: if not root: return None thislevel = [root] while thislevel: for i in range(len(thislevel)): if i == len(thislevel)-1: thislevel[i].</description>
    </item>
    <item>
      <title>144. Binary tree preorder traversal</title>
      <link>http://localhost:1313/leetcode/144/</link>
      <pubDate>Mon, 17 May 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/144/</guid>
      <description>Given the root of a binary tree, return the preorder traversal of its nodes&amp;rsquo; values.&#xA;code class Solution: def preorderTraversal(self, root: TreeNode) -&amp;gt; List[int]: self.res = [] def pre(root): if root: self.res.append(root.val) pre(root.left) pre(root.right) pre(root) return self.res code class Solution: def preorderTraversal(self, root): ret = [] stack = [root] while stack: node = stack.pop() if node: ret.append(node.val) stack.append(node.right) stack.append(node.left) return ret </description>
    </item>
    <item>
      <title>145. Binary tree postorder traversal</title>
      <link>http://localhost:1313/leetcode/145/</link>
      <pubDate>Mon, 17 May 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/145/</guid>
      <description>Given the root of a binary tree, return the postorder traversal of its nodes&amp;rsquo; values. c&#xA;code class Solution: def postorderTraversal(self, root: TreeNode) -&amp;gt; List[int]: self.res = [] def post(root): if root: post(root.left) post(root.right) self.res.append(root.val) post(root) return self.res code modified pre-order class Solution: def postorderTraversal(self, root): traversal, stack = [], [root] while stack: node = stack.pop() if node: # pre-order, right first traversal.append(node.val) stack.append(node.left) stack.append(node.right) # reverse result return traversal[::-1] </description>
    </item>
    <item>
      <title>5-love-languages and Extrovert only exist in our language</title>
      <link>http://localhost:1313/posts/opinion-extrovert/</link>
      <pubDate>Mon, 10 May 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/opinion-extrovert/</guid>
      <description>The craving for generality is a philosophical sin.&#xA;Everyone is born with some difference. Features like hair colour, and sports/music gifts, likes salt/sweet, exist and don&amp;rsquo;t change much according to context, they are self-determined.&#xA;Obviously, there are people who are generally more talkative, and friendly to strangers and people who probably don&amp;rsquo;t talk much. Nobody denies that. By observing these things in real life, we created the concept of introvert and extrovert.</description>
    </item>
    <item>
      <title>430. Flatten a Multilevel Doubly Linked List</title>
      <link>http://localhost:1313/leetcode/430/</link>
      <pubDate>Wed, 05 May 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/430/</guid>
      <description>You are given a doubly linked list which in addition to the next and previous pointers, it could have a child pointer, which may or may not point to a separate doubly linked list. These child lists may have one or more children of their own, and so on, to produce a multilevel data structure, as shown in the example below. Flatten the list so that all the nodes appear in a single-level, doubly linked list.</description>
    </item>
    <item>
      <title>203. Remove linked list elements</title>
      <link>http://localhost:1313/leetcode/203/</link>
      <pubDate>Tue, 04 May 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/203/</guid>
      <description>Given the head of a linked list and an integer val, remove all the nodes of the linked list that has Node.val == val, and return the new head.&#xA;Example 1:&#xA;Input: head = [1,2,6,3,4,5,6], val = 6 Output: [1,2,3,4,5]&#xA;code class Solution: def removeElements(self, head: ListNode, val: int) -&amp;gt; ListNode: if not head: return None while head and head.val == val: head = head.next if head and head.next: pre, cur = head, head.</description>
    </item>
    <item>
      <title>707. Design Linked list</title>
      <link>http://localhost:1313/leetcode/707/</link>
      <pubDate>Sat, 01 May 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/707/</guid>
      <description>Design your implementation of the linked list. You can choose to use a singly or doubly linked list. A node in a singly linked list should have two attributes: val and next. val is the value of the current node, and next is a pointer/reference to the next node. If you want to use the doubly linked list, you will need one more attribute prev to indicate the previous node in the linked list.</description>
    </item>
    <item>
      <title>1051. Height checker</title>
      <link>http://localhost:1313/leetcode/1051/</link>
      <pubDate>Fri, 30 Apr 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/1051/</guid>
      <description>A school is trying to take an annual photo of all the students. The students are asked to stand in a single file line in non-decreasing order by height. Let this ordering be represented by the integer array expected where expected[i] is the expected height of the ith student in line. You are given an integer array heights representing the current order that the students are standing in. Each heights[i] is the height of the ith student in line (0-indexed).</description>
    </item>
    <item>
      <title>414. Third maximum number</title>
      <link>http://localhost:1313/leetcode/414/</link>
      <pubDate>Fri, 30 Apr 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/414/</guid>
      <description>Given integer array nums, return the third maximum number in this array. If the third maximum does not exist, return the maximum number.&#xA;Example 1: Input: nums = [3,2,1] Output: 1 Explanation: The third maximum is 1.&#xA;code class Solution: def thirdMax(self, nums: List[int]) -&amp;gt; int: nums = set(nums) if len(nums) &amp;lt; 3: return max(nums) return heapq.nlargest(3, nums)[-1] code class Solution: def thirdMax(self, nums: List[int]) -&amp;gt; int: n, T = list(set(nums)), [float(&amp;#39;-inf&amp;#39;)]*3 for i in n: if i &amp;gt; T[0]: T = [i,T[0],T[1]] continue if i &amp;gt; T[1]: T = [T[0],i,T[1]] continue if i &amp;gt; T[2]: T = [T[0],T[1],i] return T[2] if T[2] !</description>
    </item>
    <item>
      <title>448. Find All Numbers Disappeared in an Array </title>
      <link>http://localhost:1313/leetcode/448/</link>
      <pubDate>Fri, 30 Apr 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/448/</guid>
      <description>Given an array nums of n integers where nums[i] is in the range [1, n], return an array of all the integers in the range [1, n] that do not appear in nums.&#xA;Example 1: Input: nums = [4,3,2,7,8,2,3,1] Output: [5,6]&#xA;code class Solution: def findDisappearedNumbers(self, nums: List[int]) -&amp;gt; List[int]: return set([i for i in range(1, len(nums) + 1)]) - set(nums) code class Solution: def findDisappearedNumbers(self, nums: List[int]) -&amp;gt; List[int]: for n in nums: a = abs(n) - 1 if nums[a] &amp;gt; 0: nums[a] *= -1 return [i+1 for i in range(len(nums)) if nums[i] &amp;gt; 0] code class Solution: def findDisappearedNumbers(self, nums: List[int]) -&amp;gt; List[int]: allnums = list(range(1, len(nums)+1)) for v in set(nums): allnums[v-1] = 0 return [num for num in allnums if num !</description>
    </item>
    <item>
      <title>1299. Replace Elements with Greatest Element on Right Side</title>
      <link>http://localhost:1313/leetcode/1299/</link>
      <pubDate>Thu, 29 Apr 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/1299/</guid>
      <description>Given an array arr, replace every element in that array with the greatest element among the elements to its right, and replace the last element with -1. After doing so, return the array.&#xA;Example 1: Input: arr = [17,18,5,4,6,1] Output: [18,6,6,6,1,-1]&#xA;code class Solution: def replaceElements(self, arr: List[int]) -&amp;gt; List[int]: right = arr[-1] arr[-1] = -1 for i in range(len(arr)-2, -1, -1): cur = arr[i] arr[i] = right right = max(cur, right) return arr </description>
    </item>
    <item>
      <title>1346. Check If N and Its Double Exist</title>
      <link>http://localhost:1313/leetcode/1346/</link>
      <pubDate>Tue, 27 Apr 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/1346/</guid>
      <description>Given an array arr of integers, check if there exists two integers N and M such that N is the double of M ( i.e. N = 2 * M). More formally check if there exists two indices i and j such that :&#xA;i != j 0 &amp;lt;= i, j &amp;lt; arr.length arr[i] == 2 * arr[j] Example 1: Input: arr = [10,2,5,3] Output: true Explanation: N = 10 is the double of M = 5,that is, 10 = 2 * 5.</description>
    </item>
    <item>
      <title>1089. Duplicate zeros</title>
      <link>http://localhost:1313/leetcode/1089/</link>
      <pubDate>Mon, 26 Apr 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/1089/</guid>
      <description>Given a fixed length array arr of integers, duplicate each occurrence of zero, shifting the remaining elements to the right. Note that elements beyond the length of the original array are not written. Do the above modifications to the input array in place, do not return anything from your function.&#xA;Example 1: Input: [1,0,2,3,0,4,5,0]Output: null Explanation: After calling your function, the input array is modified to: [1,0,0,2,3,0,0,4] c&#xA;code wrong answer.</description>
    </item>
    <item>
      <title>977. Squares of a sorted array</title>
      <link>http://localhost:1313/leetcode/977-squares-of-a-sorted-array/</link>
      <pubDate>Fri, 23 Apr 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/977-squares-of-a-sorted-array/</guid>
      <description>Given an integer array nums sorted in non-decreasing order, return an array of the squares of each number sorted in non-decreasing order.&#xA;Example 1: Input: nums = [-4,-1,0,3,10] Output: [0,1,9,16,100] Explanation: After squaring, the array becomes [16,1,0,9,100]. After sorting, it becomes [0,1,9,16,100].&#xA;code class Solution: def sortedSquares(self, A: List[int]) -&amp;gt; List[int]: for i in range(len(A)): A[i] *= A[i] A.sort() return A code class Solution: def sortedSquares(self, nums: List[int]) -&amp;gt; List[int]: l, r = 0, len(nums)-1 res = collections.</description>
    </item>
    <item>
      <title>1295. Find Numbers with Even Number of Digits</title>
      <link>http://localhost:1313/leetcode/1295-find/</link>
      <pubDate>Thu, 22 Apr 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/1295-find/</guid>
      <description>Given an array nums of integers, return how many of them contain an even number of digits. Example 1: Input: nums = [12,345,2,6,7896] Output: 2 Explanation: 12 contains 2 digits (even number of digits). 345 contains 3 digits (odd number of digits). 2 contains 1 digit (odd number of digits). 6 contains 1 digit (odd number of digits). 7896 contains 4 digits (even number of digits). Therefore only 12 and 7896 contain an even number of digits.</description>
    </item>
    <item>
      <title>485. Max consecutive ones</title>
      <link>http://localhost:1313/leetcode/485-max-ones/</link>
      <pubDate>Wed, 21 Apr 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/485-max-ones/</guid>
      <description>Given a binary array nums, return the maximum number of consecutive 1&amp;rsquo;s in the array.&#xA;Example 1: Input: nums = [1,1,0,1,1,1] Output: 3 Explanation: The first two digits or the last three digits are consecutive 1s. The maximum number of consecutive 1s is 3.&#xA;code class Solution: def findMaxConsecutiveOnes(self, nums: List[int]) -&amp;gt; int: max1 = 0 temp1 = 0 for v in nums: if v == 1: temp1 += 1 max1 = max(max1, temp1) else: temp1 = 0 return max1 code better class Solution: def findMaxConsecutiveOnes(self, nums: List[int]) -&amp;gt; int: max1 = 0 temp1 = 0 for v in nums: if v == 1: temp1 += 1 else: max1 = max(max1, temp1) temp1 = 0 return max(max1, temp1) code class Solution: def findMaxConsecutiveOnes(self, nums): return max(map(len, &amp;#39;&amp;#39;.</description>
    </item>
    <item>
      <title>142. Linked list cycle II</title>
      <link>http://localhost:1313/leetcode/142-linked-list-cycleii/</link>
      <pubDate>Tue, 20 Apr 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/142-linked-list-cycleii/</guid>
      <description>Input: head = [3,2,0,-4], pos = 1 Output: tail connects to node index 1 Explanation: There is a cycle in the linked list, where tail connects to the second node.&#xA;c f there&amp;rsquo;s a cycle, fast and slow will meet. Starts from meet, meet&amp;ndash;ans == head&amp;ndash;ans. class Solution(object): def detectCycle(self, head): &amp;#34;&amp;#34;&amp;#34; :type head: ListNode :rtype: ListNode &amp;#34;&amp;#34;&amp;#34; meet = None fast = head slow = head # must check all 3 here while slow and fast and fast.</description>
    </item>
    <item>
      <title>345. Reverse vowels of a string</title>
      <link>http://localhost:1313/leetcode/345-reverse-vowel/</link>
      <pubDate>Sat, 17 Apr 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/345-reverse-vowel/</guid>
      <description>Given a string s, reverse only all the vowels in the string and return it. The vowels are &amp;lsquo;a&amp;rsquo;, &amp;rsquo;e&amp;rsquo;, &amp;lsquo;i&amp;rsquo;, &amp;lsquo;o&amp;rsquo;, and &amp;lsquo;u&amp;rsquo;, and they can appear in both cases.&#xA;Example 1: Input: &amp;ldquo;hello&amp;quot;Output: &amp;ldquo;holle&amp;rdquo;&#xA;code class Solution: def reverseVowels(self, s): vowels = re.findall(&amp;#39;(?i)[aeiou]&amp;#39;, s) return re.sub(&amp;#39;(?i)[aeiou]&amp;#39;, lambda m: vowels.pop(), s) code class Solution: def reverseVowels(self, s: str) -&amp;gt; str: s = list(s) l, r = 0, len(s)-1 while l &amp;lt; r: while s[l] not in &amp;#39;aeiouAEIOU&amp;#39; and l &amp;lt; len(s)-1: l += 1 while s[r] not in &amp;#39;aeiouAEIOU&amp;#39; and r &amp;gt; 0: r -= 1 if l &amp;lt; r: s[l], s[r] = s[r], s[l] l += 1 r -= 1 return &amp;#34;&amp;#34;.</description>
    </item>
    <item>
      <title>35. Search insert position</title>
      <link>http://localhost:1313/leetcode/35-search-insert-position/</link>
      <pubDate>Wed, 14 Apr 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/35-search-insert-position/</guid>
      <description>Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order. You may assume no duplicates in the array. Example 1: Input: [1,3,5,6], 5 Output: 2&#xA;code class Solution(object): def searchInsert(self, nums, target): &amp;#34;&amp;#34;&amp;#34; :type nums: List[int] :type target: int :rtype: int &amp;#34;&amp;#34;&amp;#34; l = 0 r = len(nums) - 1 while l &amp;lt;= r: mid = l + (r - l) // 2 if nums[mid] &amp;lt; target: l = mid + 1 elif nums[mid] &amp;gt; target: r = mid - 1 else: return mid return r + 1 code class Solution: def searchInsert(self, nums: List[int], target: int) -&amp;gt; int: return bisect.</description>
    </item>
    <item>
      <title>561. Array Partition I</title>
      <link>http://localhost:1313/leetcode/561-array-partition-1/</link>
      <pubDate>Mon, 12 Apr 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/561-array-partition-1/</guid>
      <description>Given an array of 2n integers, your task is to group these integers into n pairs of integer, say (a1, b1), (a2, b2), &amp;hellip;, (an, bn) which makes sum of min(ai, bi) for all i from 1 to n as large as possible.&#xA;Example 1: Input: [1,4,3,2]&#xA;Output: 4 Explanation: n is 2, and the maximum sum of pairs is 4 = min(1, 2) + min(3, 4).&#xA;code class Solution: def arrayPairSum(self, nums: List[int]) -&amp;gt; int: nums.</description>
    </item>
    <item>
      <title>41. First missing positive</title>
      <link>http://localhost:1313/leetcode/41-first-missing/</link>
      <pubDate>Sat, 10 Apr 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/41-first-missing/</guid>
      <description>Given an unsorted integer array, find the smallest missing positive integer.&#xA;Example 1:&#xA;Input: [1,2,0] Output: 3 Example 2:&#xA;Input: [3,4,-1,1] Output: 2&#xA;code class Solution: def firstMissingPositive(self, nums): minMiss = 1 num_set = set(nums) while True: if minMiss in num_set: minMiss += 1 else: break return minMiss code, O(n), move each num to correct position class Solution: def firstMissingPositive(self, nums): for i in range(len(nums)): while 0 &amp;lt;= nums[i]-1 &amp;lt; len(nums) and nums[nums[i]-1] !</description>
    </item>
    <item>
      <title>299. Bulls and cows</title>
      <link>http://localhost:1313/leetcode/299-bulls-cows/</link>
      <pubDate>Fri, 09 Apr 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/299-bulls-cows/</guid>
      <description>Input: secret = &amp;ldquo;1807&amp;rdquo;, guess = &amp;ldquo;7810&amp;rdquo;&#xA;Output: &amp;ldquo;1A3B&amp;rdquo;&#xA;Explanation: 1 bull and 3 cows. The bull is 8, the cows are 0, 1 and 7.&#xA;terate over the secret string, store all the bulls in an array and keep track of the count for each character that isn&amp;rsquo;t a bull in another array tput: &amp;ldquo;1A3B&amp;rdquo; x fasd Iterate over guess string, if the character isn&amp;rsquo;t a bull, then remove the count of that character and increment cows</description>
    </item>
    <item>
      <title>9. Palindrome number</title>
      <link>http://localhost:1313/leetcode/9-palindrome-number/</link>
      <pubDate>Thu, 08 Apr 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/9-palindrome-number/</guid>
      <description>Palindrome Number - LeetCode&#xA;Determine whether an integer is a palindrome. An integer is a palindrome when it reads the same backward as forward. Example 1: Input: 121 Output: true&#xA;code class Solution: def isPalindrome(self, x: int) -&amp;gt; bool: ans = 0 num = x if x &amp;lt; 0: return False while num: ans *= 10 ans += num % 10 num = num//10 return ans == x code class Solution: def isPalindrome(self, x: int) -&amp;gt; bool: strx = str(x) return strx == strx[::-1] </description>
    </item>
    <item>
      <title>60. Permutation sequence</title>
      <link>http://localhost:1313/leetcode/60-permutation/</link>
      <pubDate>Wed, 07 Apr 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/60-permutation/</guid>
      <description>Permutation Sequence - LeetCode&#xA;The set [1,2,3,&amp;hellip;,n] contains a total of n! unique permutations. By listing and labeling all of the permutations in order, we get the following sequence for n = 3:&#xA;&amp;quot;123&amp;quot; &amp;quot;132&amp;quot; &amp;quot;213&amp;quot; &amp;quot;231&amp;quot; &amp;quot;312&amp;quot; &amp;quot;321&amp;quot;Given n and k, return the kth permutation sequence. Note:&#xA;Given n will be between 1 and 9 inclusive. Given k will be between 1 and n! inclusive.Example 1: Input: n = 3, k = 3 Output: &amp;ldquo;213&amp;rdquo;</description>
    </item>
    <item>
      <title>7. Reverse integer</title>
      <link>http://localhost:1313/leetcode/7-reverse-integer/</link>
      <pubDate>Wed, 07 Apr 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/7-reverse-integer/</guid>
      <description>Reverse Integer - LeetCode&#xA;Given a 32-bit signed integer, reverse digits of an integer. Example 1: Input: 123 Output: 321&#xA;code class Solution(object): def reverse(self, x): s = (x &amp;gt; 0) - (x &amp;lt; 0) r = int(str(x*s)[::-1]) return s*r * (r &amp;lt; 2**31) code class Solution: def reverse(self, x: int) -&amp;gt; int: if x &amp;gt;= 2**31-1 or x&amp;lt;=-2**31: return 0 ans = 0 flag = False num = x if x &amp;lt; 0: flag = True num = abs(x) while num: ans *= 10 ans += num % 10 num = num//10 if flag: if ans*(-1)&amp;lt;=-2**31: return 0 return ans*(-1) else: if ans &amp;gt;=2**31-1: return 0 return ans </description>
    </item>
    <item>
      <title>150. Evaluate reverse polish notation</title>
      <link>http://localhost:1313/leetcode/150-evaluate-reverse/</link>
      <pubDate>Tue, 06 Apr 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/150-evaluate-reverse/</guid>
      <description>Evaluate the value of an arithmetic expression in Reverse Polish Notation. Valid operators are +, -, *, /. Each operand may be an integer or another expression. Note:&#xA;Division between two integers should truncate toward zero. The given RPN expression is always valid. That means the expression would always evaluate to a result and there won&amp;rsquo;t be any divide by zero operation.Example 1: Input: [&amp;ldquo;2&amp;rdquo;, &amp;ldquo;1&amp;rdquo;, &amp;ldquo;+&amp;rdquo;, &amp;ldquo;3&amp;rdquo;, &amp;ldquo;*&amp;rdquo;] Output: 9 Explanation: ((2 + 1) * 3) = 9</description>
    </item>
    <item>
      <title>621. Task scheduler</title>
      <link>http://localhost:1313/leetcode/621-task-scheduler/</link>
      <pubDate>Tue, 06 Apr 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/621-task-scheduler/</guid>
      <description>Given a char array representing tasks CPU need to do. It contains capital letters A to Z where different letters represent different tasks. Tasks could be done without original order. Each task could be done in one interval. For each interval, CPU could finish one task or just be idle. However, there is a non-negative cooling interval n that means between two same tasks, there must be at least n intervals that CPU are doing different tasks or just be idle.</description>
    </item>
    <item>
      <title>371. Sum of two integers</title>
      <link>http://localhost:1313/leetcode/371/</link>
      <pubDate>Fri, 02 Apr 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/371/</guid>
      <description>Sum of Two Integers - LeetCode&#xA;Given two integers a and b, return the sum of the two integers without using the operators + and -.&#xA;Example 1: Input: a = 1, b = 2 Output: 3 Example 2: Input: a = 2, b = 3 Output: 5&#xA;Constraints:&#xA;-1000 &amp;lt;= a, b &amp;lt;= 1000 code class Solution { public int getSum(int a, int b) { while (b != 0) { int answer = a ^ b; int carry = (a &amp;amp; b) &amp;lt;&amp;lt; 1; a = answer; b = carry; } return a; } } code class Solution: def getSum(self, a: int, b: int) -&amp;gt; int: mask = 0xffffffff while b &amp;amp; mask: _carry = a &amp;amp; b a = a ^ b b = _carry &amp;lt;&amp;lt; 1 # for overflow condition like # -1 # 1 return (a &amp;amp; mask) if b &amp;gt; mask else a </description>
    </item>
    <item>
      <title>166. Fraction to recurring decimal</title>
      <link>http://localhost:1313/leetcode/166-fraction-to-recurring-decimal/</link>
      <pubDate>Thu, 01 Apr 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/166-fraction-to-recurring-decimal/</guid>
      <description>Fraction to Recurring Decimal - LeetCode&#xA;Given two integers representing the numerator and denominator of a fraction, return the fraction in string format. If the fractional part is repeating, enclose the repeating part in parentheses. Example 1: Input: numerator = 1, denominator = 2 Output: &amp;ldquo;0.5&amp;rdquo; Example 2: Input: numerator = 2, denominator = 1 Output: &amp;ldquo;2&amp;rdquo; Example 3: Input: numerator = 2, denominator = 3 Output: &amp;ldquo;0.(6)&amp;rdquo;&#xA;code class Solution: # @return a string def fractionToDecimal(self, numerator, denominator): n, remainder = divmod(abs(numerator), abs(denominator)) sign = &amp;#39;-&amp;#39; if numerator*denominator &amp;lt; 0 else &amp;#39;&amp;#39; result = [sign+str(n), &amp;#39;.</description>
    </item>
    <item>
      <title>69. Sqrt(x)</title>
      <link>http://localhost:1313/leetcode/69-sqrt/</link>
      <pubDate>Thu, 01 Apr 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/69-sqrt/</guid>
      <description>Sqrt(x) - LeetCode&#xA;Given a non-negative integer x, compute and return the square root of x. Since the return type is an integer, the decimal digits are truncated, and only the integer part of the result is returned.&#xA;code class Solution { public int mySqrt(int x) { if (x &amp;lt; 2) return x; long num; int pivot, left = 2, right = x / 2; while (left &amp;lt;= right) { pivot = left + (right - left) / 2; num = (long)pivot * pivot; if (num &amp;gt; x) right = pivot - 1; else if (num &amp;lt; x) left = pivot + 1; else return pivot; } return right; } } code class Solution: def mySqrt(self, x: int) -&amp;gt; int: left, right = 0, x while True: mid = left + (right-left)//2 if mid*mid &amp;gt; x: right = mid - 1 else: if (mid+1)*(mid+1) &amp;gt; x: return mid left = mid + 1 </description>
    </item>
    <item>
      <title>50. Pow(x, n)</title>
      <link>http://localhost:1313/leetcode/50-pow/</link>
      <pubDate>Wed, 31 Mar 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/50-pow/</guid>
      <description>Pow(x, n) - LeetCode&#xA;Implement pow(x, n), which calculates x raised to the power n (xn). Example 1: Input: 2.00000, 10 Output: 1024.00000 Example 2: Input: 2.10000, 3 Output: 9.26100 Example 3: Input: 2.00000, -2 Output: 0.25000 Explanation: 2-2 = 1/22 = 1/4 = 0.25&#xA;code class Solution: def myPow(self, x: float, n: int) -&amp;gt; float: result = 1 if n &amp;lt; 0: n = -n x = 1/x while n: if n % 2 == 1: result *= x x, n = x * x, n // 2 return result code class Solution: def myPow(self, x, n): if n &amp;lt; 0: x = 1 / x n = -n pow = 1 while n: if n &amp;amp; 1: pow *= x x *= x n &amp;gt;&amp;gt;= 1 return pow code class Solution: def myPow(self, x, n): if not n: return 1 if n &amp;lt; 0: return 1 / self.</description>
    </item>
    <item>
      <title>172. Factorial Trailing Zeroes</title>
      <link>http://localhost:1313/leetcode/172-factorial-trailing-zeros/</link>
      <pubDate>Tue, 30 Mar 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/172-factorial-trailing-zeros/</guid>
      <description>Factorial Trailing Zeroes - LeetCode&#xA;Given an integer n, return the number of trailing zeroes in n!. Example 1: Input: 3 Output: 0 Explanation: 3! = 6, no trailing zero. Example 2: Input: 5 Output: 1 Explanation: 5! = 120, one trailing zero.&#xA;code class Solution: def trailingZeroes(self, n: int) -&amp;gt; int: res = 0 while n &amp;gt;= 5: res += n // 5 n //= 5 return res Zeros come from 10 which is 25, and 5&amp;gt;2, so we just need to count how many 5 this factorial has.</description>
    </item>
    <item>
      <title>202. Happy number</title>
      <link>http://localhost:1313/leetcode/202-happy-number/</link>
      <pubDate>Tue, 30 Mar 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/202-happy-number/</guid>
      <description>Happy Number - LeetCode&#xA;A happy number is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1. Those numbers for which this process ends in 1 are happy numbers. Example: Input: 19 Output: true Explanation: 12 + 92 = 82 82 + 22 = 68 62 + 82 = 100 12 + 02 + 02 = 1</description>
    </item>
    <item>
      <title>297. Serialize and Deserialize Binary Tree</title>
      <link>http://localhost:1313/leetcode/297-serialize-and-deserialize-binary-tree/</link>
      <pubDate>Mon, 29 Mar 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/297-serialize-and-deserialize-binary-tree/</guid>
      <description>Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment. Design an algorithm to serialize and deserialize a binary tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary tree can be serialized to a string and this string can be deserialized to the original tree structure.</description>
    </item>
    <item>
      <title>240. Search a 2D Matrix II</title>
      <link>http://localhost:1313/leetcode/240-search-2d-matrix-ii/</link>
      <pubDate>Wed, 24 Mar 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/240-search-2d-matrix-ii/</guid>
      <description>[ [1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30] ] Given target = 5, return true. Given target = 20, return false.&#xA;code class Solution: def searchMatrix(self, matrix, target): for row in matrix: for i in reversed(range(len(row))): if target == row[i]: return True if target &amp;gt; row[i]: break return False code, start from top right class Solution: def searchMatrix(self, matrix, target): row, col = 0, len(matrix[0]) - 1 while row &amp;lt; len(matrix) and col &amp;gt;= 0: if matrix[row][col] == target: return True elif matrix[row][col] &amp;lt; target: row += 1 else: col -= 1 return False code, start from left bottom class Solution: def searchMatrix(self, matrix: List[List[int]], target: int) -&amp;gt; bool: for i in reversed(range(len(matrix))): j = 0 if matrix[i][j] &amp;gt; target: continue else: while j &amp;lt; len(matrix[0]) and matrix[i][j] &amp;lt;= target: if matrix[i][j] == target: return True j += 1 return False </description>
    </item>
    <item>
      <title>162. Find peak element</title>
      <link>http://localhost:1313/leetcode/162-find-peak-element/</link>
      <pubDate>Mon, 22 Mar 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/162-find-peak-element/</guid>
      <description>A peak element is an element that is greater than its neighbors. Given an input array nums, where nums[i] ≠ nums[i+1], find a peak element and return its index. The array may contain multiple peaks, in that case return the index to any one of the peaks is fine. You may imagine that nums[-1] = nums[n] = -∞. Example 1: Input: nums = [1,2,3,1]Output: 2 Explanation: 3 is a peak element and your function should return the index number 2.</description>
    </item>
    <item>
      <title>56. Merge internals</title>
      <link>http://localhost:1313/leetcode/56-merge-intervals/</link>
      <pubDate>Mon, 22 Mar 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/56-merge-intervals/</guid>
      <description>Merge Intervals - LeetCode&#xA;Given a collection of intervals, merge all overlapping intervals. Example 1: Input: [[1,3],[2,6],[8,10],[15,18]] Output: [[1,6],[8,10],[15,18]] Explanation: Since intervals [1,3] and [2,6] overlaps, merge them into [1,6].&#xA;code class Solution { public int[][] merge(int[][] intervals) { Arrays.sort(intervals, (a,b)-&amp;gt; a[0]-b[0]); LinkedList&amp;lt;int []&amp;gt; merged = new LinkedList(); merged.offer(intervals[0]); for (int i = 1; i &amp;lt; intervals.length; ++i){ if (intervals[i][0] &amp;gt; merged.peekLast()[1]){ merged.offer(intervals[i]); }else{ merged.peekLast()[1] = Math.max(merged.peekLast()[1], intervals[i][1]); } } return merged.</description>
    </item>
    <item>
      <title>75. Sort colors</title>
      <link>http://localhost:1313/leetcode/75-sort-colors/</link>
      <pubDate>Sun, 21 Mar 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/75-sort-colors/</guid>
      <description>Given an array nums with n objects colored red, white, or blue, sort them **in-place **so that objects of the same color are adjacent, with the colors in the order red, white, and blue. We will use the integers 0, 1, and 2 to represent the color red, white, and blue, respectively.&#xA;Input: [2,0,2,1,1,0] Output: [0,0,1,1,2,2]&#xA;code, when right-=1 later, need to use i &amp;lt;= right in the while condition class Solution: def sortColors(self, nums: List[int]) -&amp;gt; None: &amp;#34;&amp;#34;&amp;#34; Do not return anything, modify nums in-place instead.</description>
    </item>
    <item>
      <title>230. Kth smallest element in a BST</title>
      <link>http://localhost:1313/leetcode/230-kth-smallest-element-in-a-bst/</link>
      <pubDate>Sat, 13 Mar 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/230-kth-smallest-element-in-a-bst/</guid>
      <description>Given a binary search tree, write a function kthSmallest to find the kth smallest element in it. Note: You may assume k is always valid, 1 ≤ k ≤ BST&amp;rsquo;s total elements. Example 1: Input: root = [3,1,4,null,2], k = 1&#xA;3&#xA;/ \&#xA;1 4&#xA;\&#xA;2&#xA;Output: 1&#xA;code Iterative class Solution: def kthSmallest(self, root, k): stack = [] while root or stack: while root: stack.append(root) root = root.</description>
    </item>
    <item>
      <title>103. Binary tree zigzag level order traversal</title>
      <link>http://localhost:1313/leetcode/103-binary-tree-zigzag-level-order-traversal/</link>
      <pubDate>Fri, 12 Mar 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/103-binary-tree-zigzag-level-order-traversal/</guid>
      <description>Given a binary tree, return the zigzag level order traversal of its nodes&amp;rsquo; values. (ie, from left to right, then right to left for the next level and alternate between). For example: Given binary tree [3,9,20,null,null,15,7],&#xA;3 / 9 20 / 15 7&#xA;return its zigzag level order traversal as:&#xA;[ [3], [20,9], [15,7] ]&#xA;code def zigzagLevelOrder(self, root): queue = collections.deque([root]) res = [] while queue: r = [] for _ in range(len(queue)): q = queue.</description>
    </item>
    <item>
      <title>94. Binary tree inorder traversal</title>
      <link>http://localhost:1313/leetcode/94-binary-tree-inorder-traversal/</link>
      <pubDate>Thu, 11 Mar 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/94-binary-tree-inorder-traversal/</guid>
      <description>Given a binary tree, return the inorder traversal of its nodes&amp;rsquo; values.&#xA;code class Solution: def inorderTraversal(self, root: TreeNode) -&amp;gt; List[int]: res = [] def inorder(node): if not node: return inorder(node.left) res.append(node.val) inorder(node.right) inorder(root) return res c iterative class Solution: def inorderTraversal(self, root: TreeNode) -&amp;gt; List[int]: res, stack = [], [] while True: while root: stack.append(root) root = root.left if not stack: return res node = stack.pop() res.append(node.val) root = node.</description>
    </item>
    <item>
      <title>328. Odd even linked list</title>
      <link>http://localhost:1313/leetcode/328-odd-even-linked-list/</link>
      <pubDate>Wed, 10 Mar 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/328-odd-even-linked-list/</guid>
      <description>Given a singly linked list, group all odd nodes together followed by the even nodes. Please note here we are talking about the node number and not the value in the nodes. You should try to do it in place. The program should run in O(1) space complexity and O(nodes) time complexity. Example 1: Input: 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5-&amp;gt;NULLOutput: 1-&amp;gt;3-&amp;gt;5-&amp;gt;2-&amp;gt;4-&amp;gt;NULL&#xA;code class Solution: def oddEvenList(self, head: ListNode) -&amp;gt; ListNode: if not head: return None flag = 0 cur = head1 = head l2 = head2 = ListNode(0) cur = cur.</description>
    </item>
    <item>
      <title>334. Increasing triplet subsequence</title>
      <link>http://localhost:1313/leetcode/334-increasing-triplet-subsequence/</link>
      <pubDate>Mon, 08 Mar 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/334-increasing-triplet-subsequence/</guid>
      <description>Given an unsorted array return whether an increasing subsequence of length 3 exists or not in the array. Formally the function should: Return true if there exists i, j, k such that arr[i] &amp;lt; arr[j] &amp;lt; arr[k] given 0 ≤ i &amp;lt; j &amp;lt; k ≤ n-1 else return false.Note: Your algorithm should run in O(n) time complexity and O(1) space complexity.&#xA;code, use dict, logic is clearer class Solution: def increasingTriplet(self, nums: List[int]) -&amp;gt; bool: temp3 = {} for v in nums: if not temp3 or v &amp;lt; temp3[0]: temp3[0] = v elif len(temp3) == 1 and v &amp;gt; temp3[0] or len(temp3) == 2 and v &amp;gt; temp3[0] and v &amp;lt; temp3[1]: temp3[1] = v elif len(temp3) == 2 and v &amp;gt; temp3[1]: return True return False c list, a bit quicker class Solution: def increasingTriplet(self, nums: List[int]) -&amp;gt; bool: seq = [] for num in nums: if not seq or num &amp;gt; seq[-1]: seq.</description>
    </item>
    <item>
      <title>49. Group anagrams</title>
      <link>http://localhost:1313/leetcode/49-group-anagrams/</link>
      <pubDate>Mon, 08 Mar 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/49-group-anagrams/</guid>
      <description>Input: [&amp;ldquo;eat&amp;rdquo;, &amp;ldquo;tea&amp;rdquo;, &amp;ldquo;tan&amp;rdquo;, &amp;ldquo;ate&amp;rdquo;, &amp;ldquo;nat&amp;rdquo;, &amp;ldquo;bat&amp;rdquo;], Output: [ [&amp;ldquo;ate&amp;rdquo;,&amp;ldquo;eat&amp;rdquo;,&amp;ldquo;tea&amp;rdquo;], [&amp;ldquo;nat&amp;rdquo;,&amp;ldquo;tan&amp;rdquo;], [&amp;ldquo;bat&amp;rdquo;] ]&#xA;code notice after sorted &amp;ldquo;eat&amp;rdquo;, it becomes [&amp;lsquo;a&amp;rsquo;,&amp;rsquo;e&amp;rsquo;,&amp;rsquo;t&amp;rsquo;] class Solution: def groupAnagrams(self, strs: List[str]) -&amp;gt; List[List[str]]: dic_ana = {} for word in strs: sword = &amp;#34;&amp;#34;.join(sorted(word)) if sword not in dic_ana: dic_ana[sword] = [word] else: dic_ana[sword].append(word) return [v for v in dic_ana.values()] </description>
    </item>
    <item>
      <title>268. Missing number</title>
      <link>http://localhost:1313/leetcode/268-missing-number/</link>
      <pubDate>Wed, 03 Mar 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/268-missing-number/</guid>
      <description>Missing Number - LeetCode&#xA;Given an array containing n distinct numbers taken from 0, 1, 2, &amp;hellip;, n, find the one that is missing from the array. Example 1: Input: [3,0,1] Output: 2&#xA;code class Solution: def missingNumber(self, nums: List[int]) -&amp;gt; int: leng = len(nums) return leng * (leng+1) // 2 - sum(nums) </description>
    </item>
    <item>
      <title>190. Reverse bits</title>
      <link>http://localhost:1313/leetcode/190-reverse-bits/</link>
      <pubDate>Mon, 01 Mar 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/190-reverse-bits/</guid>
      <description>Reverse Bits - LeetCode2w3q1&#xA;Reverse bits of a given 32 bits unsigned integer.&#xA;Example 1: Input: 00000010100101000001111010011100 Output: 00111001011110000010100101000000 Explanation: The input binary string 00000010100101000001111010011100 represents the unsigned integer 43261596, so return 964176192 which its binary representation is 00111001011110000010100101000000.&#xA;code class Solution: def reverseBits(self, n: int) -&amp;gt; int: ret, power = 0, 31 while n: ret += (n &amp;amp; 1) &amp;lt;&amp;lt; power n = n &amp;gt;&amp;gt; 1 power -= 1 return ret code class Solution: def reverseBits(self, n: int) -&amp;gt; int: a = format(n,&amp;#34;032b&amp;#34;) return int(a[::-1],2) </description>
    </item>
    <item>
      <title>461. Hamming distance</title>
      <link>http://localhost:1313/leetcode/461-hamming-distance/</link>
      <pubDate>Mon, 01 Mar 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/461-hamming-distance/</guid>
      <description>The Hamming distance between two integers is the number of positions at which the corresponding bits are different. Given two integers x and y, calculate the Hamming distance. Note: 0 ≤ x, y &amp;lt; 231. Example: Input: x = 1, y = 4 Output: 2 Explanation: 1 (0 0 0 1) 4 (0 1 0 0)&#xA;code class Solution: def hammingDistance(self, x: int, y: int) -&amp;gt; int: dis = 0 while x or y: dis += (x&amp;amp;1) ^ (y&amp;amp;1) x &amp;gt;&amp;gt;= 1 y &amp;gt;&amp;gt;= 1 return dis </description>
    </item>
    <item>
      <title>326. Power of Three</title>
      <link>http://localhost:1313/leetcode/326-power-of-three/</link>
      <pubDate>Sat, 27 Feb 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/326-power-of-three/</guid>
      <description>Power of Three - LeetCode&#xA;Given an integer, write a function to determine if it is a power of three. Example 1: Input: 27 Output: true Example 2: Input: 0 Output: false&#xA;code class Solution: def isPowerOfThree(self, n: int) -&amp;gt; bool: if n == 0: return False while n % 3 == 0: n = n / 3 if n == 1: return True return False code, 3^20 is out of the range of Integer.</description>
    </item>
    <item>
      <title>204. Count primes</title>
      <link>http://localhost:1313/leetcode/204-count-primes/</link>
      <pubDate>Fri, 26 Feb 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/204-count-primes/</guid>
      <description>Count Primes - LeetCode&#xA;Count the number of prime numbers less than a non-negative number, n. Example: Input: 10 Output: 4 Explanation: There are 4 prime numbers less than 10, they are 2, 3, 5, 7.&#xA;code, time limit exceeded class Solution: def countPrimes(self, n: int) -&amp;gt; int: if n &amp;lt; 2: return 0 all_nums = list(range(2,n)) # print(all_nums) index = 0 while index &amp;lt; len(all_nums): cur = all_nums[index] # print(&amp;#39;cur&amp;#39;) # print(cur) # for i in range(2, n//cur + 1): for i in range(cur*cur, n, cur): # print(&amp;#39;remove&amp;#39;+str(i)) try: # all_nums.</description>
    </item>
    <item>
      <title>412. Fizz buzz</title>
      <link>http://localhost:1313/leetcode/412-fizz-buzz/</link>
      <pubDate>Tue, 23 Feb 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/412-fizz-buzz/</guid>
      <description>https://leetcode.com/problems/fizz-buzz/&#xA;Write a program that outputs the string representation of numbers from 1 to n. But for multiples of three it should output “Fizz” instead of the number and for the multiples of five output “Buzz”. For numbers which are multiples of both three and five output “FizzBuzz”.&#xA;code class Solution: def fizzBuzz(self, n: int) -&amp;gt; List[str]: # list comprehension with string rule of FizzBuzz list_of_output = [ &amp;#39;Fizz&amp;#39; * (not i % 3) + &amp;#39;Buzz&amp;#39; * (not i % 5 ) or str(i) for i in range(1, n+1) ] return list_of_output code class Solution: def fizzBuzz(self, n: int) -&amp;gt; List[str]: res = [] for i in range(1, n+1): if i % 15 == 0: res.</description>
    </item>
    <item>
      <title>155. Min Stack</title>
      <link>http://localhost:1313/leetcode/155-min-stack/</link>
      <pubDate>Mon, 22 Feb 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/155-min-stack/</guid>
      <description>Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.&#xA;push(x) -- Push element x onto stack. pop() -- Removes the element on top of the stack. top() -- Get the top element. getMin() -- Retrieve the minimum element in the stack. c&#xA;code, one stack, save the min at each time at the second place, for e.g. input (1,3,-2) will become (1,1),(3,1)(-2,-2) class MinStack: def __init__(self): &amp;#34;&amp;#34;&amp;#34; initialize your data structure here.</description>
    </item>
    <item>
      <title>Hugo: How to add last update</title>
      <link>http://localhost:1313/dev/hugo-last-update/</link>
      <pubDate>Mon, 22 Feb 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/dev/hugo-last-update/</guid>
      <description>Under layouts/posts/single.html, check if the day publish is the same day we update, don&amp;rsquo;t show the last udpated.&#xA;&amp;lt;div class=&amp;#34;date&amp;#34;&amp;gt; &amp;lt;span class=&amp;#34;posted-on&amp;#34;&amp;gt; &amp;lt;i class=&amp;#34;fas fa-calendar&amp;#34;&amp;gt;&amp;lt;/i&amp;gt; &amp;lt;time datetime=&amp;#39;{{ .Date.Format &amp;#34;2006-01-02T15:04:05Z07:00&amp;#34; }}&amp;#39;&amp;gt; {{ .Date.Format (.Site.Params.dateFormat | default &amp;#34;January 2, 2006&amp;#34; ) }} &amp;lt;/time&amp;gt; &amp;lt;/span&amp;gt; {{ if ne .Date.YearDay .Lastmod.YearDay }} &amp;lt;span class=&amp;#34;post-on&amp;#34;&amp;gt; &amp;lt;i class=&amp;#34;fas fa-calendar&amp;#34;&amp;gt;&amp;lt;/i&amp;gt; &amp;lt;time datetime=&amp;#39;{{ .Date.Format &amp;#34;2006-01-02T15:04:05Z07:00&amp;#34; }}&amp;#39;&amp;gt; Last updated: {{ dateFormat ( or $.Site.Params.dateFormat &amp;#34;2006, Jan 02&amp;#34; ) $.Page.Params.LastMod }} &amp;lt;/time&amp;gt; &amp;lt;/span&amp;gt; {{ end }} &amp;lt;/div&amp;gt; </description>
    </item>
    <item>
      <title>384. Shuffle an array</title>
      <link>http://localhost:1313/leetcode/384-shuffle-an-array/</link>
      <pubDate>Sun, 21 Feb 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/384-shuffle-an-array/</guid>
      <description>Shuffle a set of numbers without duplicates. Implement the Solution class:&#xA;Solution(int[] nums) Initializes the object with the integer array nums. int[] reset() Resets the array to its original configuration and returns it. int[] shuffle() Returns a random shuffling of the array. code0 class Solution: def __init__(self, nums: List[int]): self.origin = nums[:] def reset(self) -&amp;gt; List[int]: &amp;#34;&amp;#34;&amp;#34; Resets the array to its original configuration and return it. &amp;#34;&amp;#34;&amp;#34; return self.origin def shuffle(self) -&amp;gt; List[int]: &amp;#34;&amp;#34;&amp;#34; Returns a random shuffling of the array.</description>
    </item>
    <item>
      <title>198. House robber</title>
      <link>http://localhost:1313/leetcode/198/</link>
      <pubDate>Sat, 20 Feb 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/198/</guid>
      <description>You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night. Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police.</description>
    </item>
    <item>
      <title>70. Climbing stairs</title>
      <link>http://localhost:1313/leetcode/70/</link>
      <pubDate>Thu, 18 Feb 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/70/</guid>
      <description>https://leetcode.com/problems/climbing-stairs/&#xA;You are climbing a staircase. It takes n steps to reach the top. Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top? Input: 2 Output: 2 Explanation: There are two ways to climb to the top.&#xA;1 step + 1 step 2 steps Example 2: Input: 3 Output: 3 Explanation: There are three ways to climb to the top.</description>
    </item>
    <item>
      <title>278. First bad version</title>
      <link>http://localhost:1313/leetcode/278-first-bad-version/</link>
      <pubDate>Tue, 16 Feb 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/278-first-bad-version/</guid>
      <description>Given n = 5, find the first bad version. (version = 4 is the first bad version.)&#xA;call isBadVersion(3) -&amp;gt; false&#xA;call isBadVersion(5) -&amp;gt; true&#xA;call isBadVersion(4) -&amp;gt; true&#xA;Then 4 is the first bad version.&#xA;code class Solution: def firstBadVersion(self, n): &amp;#34;&amp;#34;&amp;#34; :type n: int :rtype: int &amp;#34;&amp;#34;&amp;#34; begin, end = 1, n while begin &amp;lt; end: mid = (begin + end) // 2 if isBadVersion(mid): end = mid else: begin = mid + 1 return end c2 class Solution: def firstBadVersion(self, n): &amp;#34;&amp;#34;&amp;#34; :type n: int :rtype: int &amp;#34;&amp;#34;&amp;#34; lo, hi = 1, n while lo &amp;lt;= hi: mid = (lo + hi) // 2 if isBadVersion(mid): hi = mid-1 else: lo = mid+1 # why return lo here, since lo&amp;gt;hi now, lo&amp;#39;s left is always right, hi&amp;#39;s right is alwasy wrong return lo </description>
    </item>
    <item>
      <title>53. Maximum subarray</title>
      <link>http://localhost:1313/leetcode/53/</link>
      <pubDate>Tue, 16 Feb 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/53/</guid>
      <description>https://leetcode.com/problems/maximum-subarray/&#xA;Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum. Example: Input: [-2,1,-3,4,-1,2,1,-5,4], Output: 6 Explanation: [4,-1,2,1] has the largest sum = 6 code class Solution { public int maxSubArray(int[] nums) { // Initialize our variables using the first element. int currentSubarray = nums[0]; int maxSubarray = nums[0]; // Start with the 2nd element since we already used the first one.</description>
    </item>
    <item>
      <title>101. Symmetric tree</title>
      <link>http://localhost:1313/leetcode/101-symmetric-tree/</link>
      <pubDate>Wed, 03 Feb 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/101-symmetric-tree/</guid>
      <description>Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center). For example, this binary tree [1,2,2,3,4,4,3] is symmetric: 1 / 2 2 / \ / 3 4 4 3&#xA;But the following [1,2,2,null,3,null,3] is not: 1 / 2 2 \ 3 3&#xA;code better class Solution: def isSymmetric(self, root): def isSym(L,R): if not L and not R: return True if L and R and L.</description>
    </item>
    <item>
      <title>141. Linked list cycle(T or F)</title>
      <link>http://localhost:1313/leetcode/141-linked-list-cycle/</link>
      <pubDate>Tue, 26 Jan 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/141-linked-list-cycle/</guid>
      <description>Input: head = [3,2,0,-4], pos = 1 Output: true Explanation: There is a cycle in the linked list, where tail connects to the second node.&#xA;code class Solution: def hasCycle(self, head: ListNode) -&amp;gt; bool: quick = slow = head while quick and quick.next: quick = quick.next.next slow = slow.next if quick == slow: return True return False c java /** * Definition for singly-linked list. * class ListNode { * int val; * ListNode next; * ListNode(int x) { * val = x; * next = null; * } * } */ public class Solution { public boolean hasCycle(ListNode head) { ListNode slow = head, quick = head; while (quick !</description>
    </item>
    <item>
      <title>234. Palindrome linked list</title>
      <link>http://localhost:1313/leetcode/234-palindrome-linked-list/</link>
      <pubDate>Mon, 25 Jan 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/234-palindrome-linked-list/</guid>
      <description>Example 1: Input: 1-&amp;gt;2 Output: false Example 2: Input: 1-&amp;gt;2-&amp;gt;2-&amp;gt;1 Output: true&#xA;code, best def isPalindrome(self, head): rev = None slow = fast = head while fast and fast.next: fast = fast.next.next rev, rev.next, slow = slow, rev, slow.next if fast: slow = slow.next while rev and rev.val == slow.val: slow = slow.next rev = rev.next return not rev code, same, first by my own, reverse the left side slow link class Solution: def isPalindrome(self, head: ListNode) -&amp;gt; bool: quick = slowhead = head slowpassed = None while quick and quick.</description>
    </item>
    <item>
      <title>21. Merge two sorted lists</title>
      <link>http://localhost:1313/leetcode/21.merge-two-sorted-lists/</link>
      <pubDate>Sat, 23 Jan 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/21.merge-two-sorted-lists/</guid>
      <description>Merge two sorted linked lists and return it as a sorted list.&#xA;code better class Solution: def mergeTwoLists(self, l1: ListNode, l2: ListNode) -&amp;gt; ListNode: # Creates a placeholder for the result. dummy_head = tail = ListNode() while l1 and l2: if l1.val &amp;lt; l2.val: tail.next, l1 = l1, l1.next else: tail.next, l2 = l2, l2.next tail = tail.next # Appends the remaining nodes of L1 or L2 tail.next = l1 or l2 return dummy_head.</description>
    </item>
    <item>
      <title>206. Rotate array</title>
      <link>http://localhost:1313/leetcode/206-reverse-linked-list/</link>
      <pubDate>Thu, 21 Jan 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/206-reverse-linked-list/</guid>
      <description>Input: 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5-&amp;gt;NULL Output: 5-&amp;gt;4-&amp;gt;3-&amp;gt;2-&amp;gt;1-&amp;gt;NULL&#xA;code best def reverseList(self, head): prev = None curr = head while curr: next = curr.next curr.next = prev prev = curr curr = next return prev code own class Solution: def reverseList(self, head: ListNode) -&amp;gt; ListNode: if not head or not head.next: return head if not head.next.next: head.next.next = head res = head.next head.next = None return res first, second, third = head, head.next, head.next.next first.</description>
    </item>
    <item>
      <title>Floating typing- the proper ergonomic typing posture</title>
      <link>http://localhost:1313/posts/tip-sitting-position/</link>
      <pubDate>Thu, 21 Jan 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/tip-sitting-position/</guid>
      <description>Regarding the height of the seat and the height of the screen, I won’t talk about it. Everyone understands it and it’s easy to adjust it.&#xA;I will focus on a very critical point here, and the majority don&amp;rsquo;t know how to do it properly, which is the height position of the arm and wrist when using the keyboard and mouse.&#xA;Generally speaking, most people, including me, put their arms on the table and their wrists on the table or hand rest.</description>
    </item>
    <item>
      <title>19. Remove Nth node from end of list</title>
      <link>http://localhost:1313/leetcode/19-remove-nth-node-from-end-of-list/</link>
      <pubDate>Tue, 19 Jan 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/19-remove-nth-node-from-end-of-list/</guid>
      <description>Example: Given linked list: 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5, and n = 2. After removing the second node from the end, the linked list becomes 1-&amp;gt;2-&amp;gt;3-&amp;gt;5.&#xA;c1 dump head class Solution: def removeNthFromEnd(self, head: ListNode, n: int) -&amp;gt; ListNode: dumphead = ListNode(0, head) count = head leng = 0 while count: count = count.next leng += 1 target_before = leng - n # delete head if target_before == 0: head = head.next return head while target_before &amp;gt; 0: dumphead = dumphead.</description>
    </item>
    <item>
      <title>237. Delete a node in a linked list</title>
      <link>http://localhost:1313/leetcode/237-delete-node-in-linked-list/</link>
      <pubDate>Tue, 19 Jan 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/237-delete-node-in-linked-list/</guid>
      <description>Input: head = [4,5,1,9], node = 5 Output: [4,1,9]&#xA;c # Definition for singly-linked list. # class ListNode: # def __init__(self, x): # self.val = x # self.next = None class Solution: def deleteNode(self, node): &amp;#34;&amp;#34;&amp;#34; :type node: ListNode :rtype: void Do not return anything, modify node in-place instead. &amp;#34;&amp;#34;&amp;#34; node.val = node.next.val node.next = node.next.next </description>
    </item>
    <item>
      <title>38. count and say</title>
      <link>http://localhost:1313/leetcode/38-count-and-say/</link>
      <pubDate>Thu, 14 Jan 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/38-count-and-say/</guid>
      <description>Input: n = 4 Output: &amp;ldquo;1211&amp;rdquo; Explanation: countAndSay(1) = &amp;ldquo;1&amp;rdquo; countAndSay(2) = say &amp;ldquo;1&amp;rdquo; = one 1 = &amp;ldquo;11&amp;rdquo; countAndSay(3) = say &amp;ldquo;11&amp;rdquo; = two 1&amp;rsquo;s = &amp;ldquo;21&amp;rdquo; countAndSay(4) = say &amp;ldquo;21&amp;rdquo; = one 2 + one 1 = &amp;ldquo;12&amp;rdquo; + &amp;ldquo;11&amp;rdquo; = &amp;ldquo;1211&amp;rdquo;&#xA;code class Solution: def countAndSay(self, n: int) -&amp;gt; str: def generator(strin): res = [] last_char = strin[0] count_last_char = 1 for i in range(1, len(strin)): if strin[i] !</description>
    </item>
    <item>
      <title>01. Two sum</title>
      <link>http://localhost:1313/leetcode/1-two-sum/</link>
      <pubDate>Fri, 08 Jan 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/1-two-sum/</guid>
      <description>Given an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution, and you may not use the same element twice.&#xA;Example: Given nums = [2, 7, 11, 15], target = 9, Because nums[0] + nums[1] = 2 + 7 = 9, return [0, 1].&#xA;code class Solution: def twoSum(self, nums: List[int], target: int) -&amp;gt; List[int]: need_values = {} for i, v in enumerate(nums): need_value = target - v if need_value in need_values: return [need_values[need_value], i] else: need_values[v] = i </description>
    </item>
    <item>
      <title>350. Intersection of two arrays II</title>
      <link>http://localhost:1313/leetcode/350-intersection-of-two-arrays-ii/</link>
      <pubDate>Wed, 06 Jan 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/350-intersection-of-two-arrays-ii/</guid>
      <description>Given two arrays, write a function to compute their intersection.&#xA;Example 1: Input: nums1 = [1,2,2,1], nums2 = [2,2]Output: [2,2]&#xA;Example 2: Input: nums1 = [4,9,5], nums2 = [9,4,9,8,4]Output: [4,9]&#xA;c0 class Solution: def intersect(self, nums1: List[int], nums2: List[int]) -&amp;gt; List[int]: d1 = dict(collections.Counter(nums1)) d2 = dict(collections.Counter(nums2)) ans = [] for i in d1: if i in d2: count = min(d1[i],d2[i]) ans.extend(count*[i]) return ans code, hash table (similar to c0 without second dic), and sorted with pointer # Hash table class Solution: def intersect(self, nums1: List[int], nums2: List[int]) -&amp;gt; List[int]: # Traverse the shorter array and store the elements in the hash table # Ensure that the previous array is short if len(nums1) &amp;gt; len(nums2): self.</description>
    </item>
    <item>
      <title>66. Plus One</title>
      <link>http://localhost:1313/leetcode/66-plus-one/</link>
      <pubDate>Wed, 06 Jan 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/66-plus-one/</guid>
      <description>Given a non-empty array of digits representing a non-negative integer, plus one to the integer. The digits are stored such that the most significant digit is at the head of the list, and each element in the array contain a single digit. You may assume the integer does not contain any leading zero, except the number 0 itself.&#xA;Example 1: Input: [1,2,3] Output: [1,2,4] Explanation: The array represents the integer 123.</description>
    </item>
    <item>
      <title>217. Contains duplicate</title>
      <link>http://localhost:1313/leetcode/217-contains-duplicate/</link>
      <pubDate>Tue, 05 Jan 2021 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/217-contains-duplicate/</guid>
      <description>Input: [1,2,3,1] Output: true&#xA;Input: [1,2,3,4] Output: false&#xA;return True if contains duplicate&#xA;c0, it&amp;rsquo;s O(n) to make a set from a list. Set result is out of order! return True if len(nums) != len(set(nums)) else False c1 class Solution: def containsDuplicate(self, nums: List[int]) -&amp;gt; bool: if not len(nums): return False nums.sort() left = nums[0] for i in nums[1:]: if i == left: return True left = i return False </description>
    </item>
    <item>
      <title>Merge two sorted list</title>
      <link>http://localhost:1313/leetcode/epi-7.1-merge-two-sorted-list/</link>
      <pubDate>Mon, 28 Dec 2020 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/epi-7.1-merge-two-sorted-list/</guid>
      <description>c&#xA;def merge_two_sorted_lists(L1, L2): # Creates a placeholder for the result. dummy_head = tail = ListNode() while L1 and L2: if L1.data &amp;lt; L2.data: tail.next, L1 = L1, L1.next else: tail.next, L2 = L2, L2.next tail = tail.next # Appends the remaining nodes of L1 or L2 tail.next = L1 or L2 return dummy_head.next remember to use two pointer, one move, one for return</description>
    </item>
    <item>
      <title>Test for cyclicity</title>
      <link>http://localhost:1313/leetcode/epi-7.3-test-for-cyclicity/</link>
      <pubDate>Mon, 28 Dec 2020 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/epi-7.3-test-for-cyclicity/</guid>
      <description>takes the head of a singly linked list and returns null if there&amp;rsquo;s no cycle.&#xA;return the node at the start of the cycle if present code&#xA;code, a bit cheating, need to make sure there&amp;rsquo;s no inf value before def has_cycle(head: ListNode) -&amp;gt; Optional[ListNode]: cur = head while cur: if cur.data == float(&amp;#39;inf&amp;#39;): return cur cur.data = float(&amp;#39;inf&amp;#39;) cur = cur.next return None c2 if there&amp;rsquo;s a cycle, fast and slow will meet.</description>
    </item>
    <item>
      <title>Test for overlapping lists</title>
      <link>http://localhost:1313/leetcode/epi-7.4-test-for-overlapping-lists-no-cycle/</link>
      <pubDate>Mon, 28 Dec 2020 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/epi-7.4-test-for-overlapping-lists-no-cycle/</guid>
      <description>takes two cycle-free single linked list, determines if there exists a node that is common to both lists&#xA;c1 def overlapping_no_cycle_lists(l0, l1): def length(L): length = 0 while L: length += 1 L = L.next return length l0_len, l1_len = length(l0), length(l1) if l0_len &amp;gt; l1_len: l0, l1 = l1, l0 # l1 is the longer list # Advances the longer list to get equal length lists. for _ in range(abs(l0_len - l1_len)): l1 = l1.</description>
    </item>
    <item>
      <title>Compute the spreadsheet column encoding</title>
      <link>http://localhost:1313/leetcode/epi-6.3-compute-the-spreadsheet-column-encoding/</link>
      <pubDate>Sat, 26 Dec 2020 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/epi-6.3-compute-the-spreadsheet-column-encoding/</guid>
      <description>converts a spreadsheet column id to the corresponding integer&#xA;return 4 for D, 27 for AA,(26 *1 + 1) 702 for ZZ(26 *26 + 26)&#xA;code, same logic as answer def ss_decode_col_id(col: str) -&amp;gt; int: to_num = lambda x: ord(x) - 64 f = lambda x, y: x * 26 + y res = functools.reduce(f, map(to_num, col)) return res c ans def ss_decode_col_id(col): return functools.reduce( lambda result, c: result * 26 + ord(c) - ord(&amp;#39;A&amp;#39;) + 1, col, 0) </description>
    </item>
    <item>
      <title>replace and remove</title>
      <link>http://localhost:1313/leetcode/epi-6.4-replace-and-remove/</link>
      <pubDate>Sat, 26 Dec 2020 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/epi-6.4-replace-and-remove/</guid>
      <description>Apply to an array of characters, replace &amp;lsquo;a&amp;rsquo; by &amp;lsquo;dd&amp;rsquo;, delete each entry containing a &amp;lsquo;b&amp;rsquo;&#xA;E.g. (a,c,d,b,b,c,a) results in the array (d,d,c,d,c,d,d).&#xA;code, ans def replace_and_remove(size: int, s: List[str]) -&amp;gt; int: # Forward iteration: remove &amp;#39;b&amp;#39;s and count the number of &amp;#39;a&amp;#39;s. write_idx, a_count = 0, 0 for i in range(size): if s[i] != &amp;#39;b&amp;#39;: s[write_idx] = s[i] write_idx += 1 if s[i] == &amp;#39;a&amp;#39;: a_count += 1 # Backward iteration: replace &amp;#39;a&amp;#39;s with &amp;#39;dd&amp;#39;s starting from the end.</description>
    </item>
    <item>
      <title>Compute rows in Pascal&#39;s triangle</title>
      <link>http://localhost:1313/leetcode/epi-5.20-compute-rows-in-pascals-triangle/</link>
      <pubDate>Fri, 25 Dec 2020 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/epi-5.20-compute-rows-in-pascals-triangle/</guid>
      <description>generate_pascal_triangle&#xA;takes a nonnegative integer n and returns the first n rows of Pascal&amp;rsquo;s triangle code&#xA;own, recursive code def generate_pascal_triangle(n: int) -&amp;gt; List[List[int]]: if n == 0: return [] if n == 1: return [[1]] def getNextRow(lastRow): nextRow = [1] for i in range(len(lastRow) - 1): nextRow.append(lastRow[i] + lastRow[i+1]) nextRow.append(1) return nextRow last_tri = generate_pascal_triangle(n - 1) last_tri.append(getNextRow(last_tri[-1])) return last_tri c ans code def generate_pascal_triangle(n: int) -&amp;gt; List[List[int]]: result = [[1] * (i + 1) for i in range(n)] # print(result) all 1 in the triangle for i in range(n): for j in range(1, i): # Sets this entry to the sum of the two above adjacent entries.</description>
    </item>
    <item>
      <title>Compute rows in Pascal&#39;s triangle</title>
      <link>http://localhost:1313/leetcode/epi-6.1-interconvert-strings-and-integers/</link>
      <pubDate>Fri, 25 Dec 2020 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/epi-6.1-interconvert-strings-and-integers/</guid>
      <description>take a string representing an integer and return the corresponding integer, and vice versa, should handle negative integers.&#xA;Implement an integer to string conversion function, and a string to integer.&#xA;Cannot use library like &amp;lsquo;int&amp;rsquo;.&#xA;string.digits = &amp;lsquo;0~9&amp;rsquo;, then index, to change str to int better, res * (-1 if ... else 1) str to int code same, just shorter def string_to_int(s: str) -&amp;gt; int: return (-1 if s[0] == &amp;#39;-&amp;#39; else 1) * functools.</description>
    </item>
    <item>
      <title>Rotate a 2D array</title>
      <link>http://localhost:1313/leetcode/epi-5.19-rotate-a-2d-array/</link>
      <pubDate>Fri, 25 Dec 2020 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/epi-5.19-rotate-a-2d-array/</guid>
      <description>rotate_matrix rotate 90 degrees clockwise&#xA;c1 ans , O(1) space, for i in len(matrix)//2 is every circle level, for j in range(i, len(matrix)-1-i) e.g. n=4, outside round and inside round, so 2 rounds in total. for each round, first need 3, second need 1. change i and j, then add ~ to the first one. i j, ~j i, ~i ~j, j ~i (i,j) 1 (~j,i) 13 (~i,~j) 16 (j, ~i) 4 = (~j,i) 13 (~i,~j) 16 (j, ~i) 4 (i,j) 1 def rotate_matrix(square_matrix: List[List[int]]) -&amp;gt; None: matrix_size = len(square_matrix) - 1 for i in range(len(square_matrix) // 2): # print(i) for j in range(i, matrix_size - i): # Perform a 4-way exchange.</description>
    </item>
    <item>
      <title>Compute the spiral ordering of a 2D array</title>
      <link>http://localhost:1313/leetcode/epi-5.18-compute-the-spiral-ordering-of-a-2d-array/</link>
      <pubDate>Tue, 22 Dec 2020 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/epi-5.18-compute-the-spiral-ordering-of-a-2d-array/</guid>
      <description>matrix_in_spiral_order write a program which takes an n*n 2D array and returns the spiral ordering of the array&#xA;code my, better code def matrix_in_spiral_order(square_matrix: List[List[int]]) -&amp;gt; List[int]: res = [] def right(square_in): if not square_in: return None nonlocal res res.extend(square_in.pop(0)) return square_in def down(square_in): if not square_in: return None nonlocal res for row in square_in: res.append(row.pop(-1)) return square_in def left(square_in): if not square_in: return None nonlocal res res.extend(list(reversed(square_in.pop(-1)))) return square_in def up(square_in): if not square_in: return None nonlocal res for row in reversed(square_in): res.</description>
    </item>
    <item>
      <title>The sudoku checker problem</title>
      <link>http://localhost:1313/leetcode/epi-5.17-the-sudoku-checker-problem/</link>
      <pubDate>Sat, 19 Dec 2020 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/epi-5.17-the-sudoku-checker-problem/</guid>
      <description>is_valid_sudoku check nine row constraints, nine column constraints and nine sub-grid constraints. ensure no number in [1,9] appears more than once&#xA;A 0-value in the 2D array indicates that entry is blank, every other entry is in [1,9]&#xA;code c own w code def is_valid_sudoku(partial_assignment: List[List[int]]) -&amp;gt; bool: # TODO - you fill in here. def check_9num(list_9num): counter = collections.Counter(list_9num) for num in counter: if num != 0 and counter[num] &amp;gt; 1: return False return True for row in partial_assignment: if check_9num(row) is False: return False for i in range(9): col = list() for j in range(9): col.</description>
    </item>
    <item>
      <title>Generate nonuniform random numbers</title>
      <link>http://localhost:1313/leetcode/epi-5.16-generate-nonuniform-random-numbers/</link>
      <pubDate>Fri, 18 Dec 2020 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/epi-5.16-generate-nonuniform-random-numbers/</guid>
      <description>nonuniform_rando_number_generation (values, probabilities)&#xA;given n numbers as well as probabilities p0,p1..p(n-1), which sum up to 1. given a random number generator that produces values in [0,1) uniformly, how to generate one of the n numbers according to the specified probabilities?&#xA;3,5,7,11 and p is 9/18, 6/18, 2/18, 1/18, then in 1000 calls to your program, 3 should appear 500 etc.&#xA;c myown code def nonuniform_random_number_generation(values: List[int], probabilities: List[float]) -&amp;gt; int: # TODO - you fill in here.</description>
    </item>
    <item>
      <title>Compute a random permutation</title>
      <link>http://localhost:1313/leetcode/epi-5.14-compute-a-random-subset/</link>
      <pubDate>Thu, 17 Dec 2020 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/epi-5.14-compute-a-random-subset/</guid>
      <description>compute_random_permutation&#xA;n = 4, output 1230&#xA;create uniformly random permutations, you are given a random number generator 5.12 !(2019-07-12) sample offline data 1 , use as few calls to it as possible c, basically same question as 5.12 c&#xA;def random_sampling(k, A): for i in range(k): # Generate a random index in [i, len(A) - 1]. r = random.randint(i, len(A) - 1) A[i], A[r] = A[r], A[i] def compute_random_permutation(n): permutation = list(range(n)) random_sampling(n, permutation) return permutation </description>
    </item>
    <item>
      <title>Compute a random subset</title>
      <link>http://localhost:1313/leetcode/epi-5.15-compute-a-random-subset/</link>
      <pubDate>Thu, 17 Dec 2020 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/epi-5.15-compute-a-random-subset/</guid>
      <description>random_subset&#xA;input a positive integer n and a size k&amp;lt;=n, return a size k subset of {0,1,2&amp;hellip;n-1} code difference between this one and 5.12, is that 5.12 give A, this A = list(range(n))&#xA;c0 451 439 def random_subset(n, k): # TODO - you fill in here. A = list(range(n)) A[:] = random.sample(A, k) return A c1 own 437 386 def random_subset(n, k): A = list(range(n)) for i in range(k): r = random.</description>
    </item>
    <item>
      <title>Sample offline data</title>
      <link>http://localhost:1313/leetcode/epi-5.12-sample-offline-data/</link>
      <pubDate>Thu, 17 Dec 2020 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/epi-5.12-sample-offline-data/</guid>
      <description>random_sampling takes an array of distinct elements and a size, and returns a subset of the given size. All subsets should be equally likely. Return the result in input array itself A = 3,7,5,11 k =3, ans = 5,11,3 code&#xA;c0 def random_sampling(k, A): for i in range(k): # Generate a random index in [i, len(A) - 1]. r = random.randint(i, len(A) - 1) A[i], A[r] = A[r], A[i] c1 def random_sampling_pythonic(k, A): A[:] = random.</description>
    </item>
    <item>
      <title>Buy and sell stock once</title>
      <link>http://localhost:1313/leetcode/epi-5.6-buy-and-sell-stock-once/</link>
      <pubDate>Wed, 16 Dec 2020 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/epi-5.6-buy-and-sell-stock-once/</guid>
      <description>buy_and_sell_stock_once notice only once&#xA;the following sequence of stock price: (310, 315, 275, 295, 260, 270, 290..) the maximum profit that can be made with one buy and one sell is 30. from 260 to 290&#xA;Write a program that takes an array denoting the daily stock price, return the maximum profit that could be made by buying and then selling one share of that stock code&#xA;c1, same as c0 code def buy_and_sell_stock_once(prices: List[float]) -&amp;gt; float: max_profit = 0 buy_min = prices[0] for i in range(1, len(prices)): if prices[i] &amp;lt; buy_min: buy_min = prices[i] elif prices[i] &amp;gt; buy_min: if prices[i] - buy_min &amp;gt; max_profit: max_profit = prices[i] - buy_min return max_profit c0 c0 def buy_and_sell_stock_once(prices): # TODO - you fill in here.</description>
    </item>
    <item>
      <title>Computing an alternation</title>
      <link>http://localhost:1313/leetcode/epi-5.8-computing-an-alternation/</link>
      <pubDate>Wed, 16 Dec 2020 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/epi-5.8-computing-an-alternation/</guid>
      <description>rearrange 1&amp;lt;=2&amp;gt;=3&amp;lt;=4&amp;gt;=5&amp;hellip; takes an array A of n numbers, and rearranges A&amp;rsquo;s elements to get a new array B having the property that B[0] &amp;lt;= B[1] &amp;gt;= B[2] &amp;lt;= B[3] &amp;gt;= B[4] &amp;lt;= B[5] 19,2,45,44,23,1,9,19 2,45,19,44,1, 23, 9, 19 code&#xA;c2, best O(n) notice [2,3,2], when i =2, A[i:i+2] = 2, there&amp;rsquo;s no index out of array issue code def rearrange(A: List[int]) -&amp;gt; None: for i in range(len(A)): A[i:i+2] = sorted(A[i:i+2], reverse= i%2 == 1) c0, old, don&amp;rsquo;t need to sort, O(n) c def rearrange(A): # TODO - you fill in here.</description>
    </item>
    <item>
      <title>Permute the elements of an array</title>
      <link>http://localhost:1313/leetcode/epi-5.10-permute-the-elements-of-an-array/</link>
      <pubDate>Wed, 16 Dec 2020 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/epi-5.10-permute-the-elements-of-an-array/</guid>
      <description>apply_permutation given an array A of elements and a premutation P, apply P to A A abcd, P 2013, yields bcad 2013 means move location 0 to 2, 1 to 0, 2 to 1, 3 to 3 code&#xA;c0 simple but need a lot space, not in place! c0 def apply_permutation(perm, A): # TODO - you fill in here. B = [0] * len(A) for i in zip(A, perm): B[i[1]] = i[0] return B still copy code</description>
    </item>
    <item>
      <title>Advancing through an array</title>
      <link>http://localhost:1313/leetcode/epi-5.4-advancing-through-an-array/</link>
      <pubDate>Tue, 15 Dec 2020 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/epi-5.4-advancing-through-an-array/</guid>
      <description>can_reach_end&#xA;A=[3,3,1,0,2,0,1], represent the board game ans: take 1 step from A[0] to A[1], then 3 steps from A[1] to A[4], then 2 steps from A[4] to A[6]. Note that A[0]=3&amp;gt;=1, A[1]= 3 &amp;gt;=3, A[4]=2&amp;gt;=2. so valid.&#xA;Write a program which takes an array of n integers, where A[i] denotes the maximum you can advance from index i, and returns whether it&amp;rsquo;s possible to adavance to the last index starting from the beginning of the array.</description>
    </item>
    <item>
      <title>delete duplicate from sorted array</title>
      <link>http://localhost:1313/leetcode/epi-5.5-delete-duplicate-from-sorted-array/</link>
      <pubDate>Tue, 15 Dec 2020 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/epi-5.5-delete-duplicate-from-sorted-array/</guid>
      <description>delete_duplicates&#xA;(2,3,5,5,11,11)-&amp;gt;(2,3,5,11,0,0) takes as input a sorted array, updates it so that all duplicates have been removed and the remaining elements have been shifted left. return the number of valid elements. can not use library functions thought make a write index, to move when you write a different number&#xA;code c2, same to c0, easier to understand code def delete_duplicates(A: List[int]) -&amp;gt; int: if not A: return 0 write_index = 1 for i in range(1, len(A)): if A[i] &amp;gt; A[write_index-1]: A[write_index] = A[i] write_index += 1 return write_index c1 maybe it&amp;rsquo;s cheat code, maybe it&amp;rsquo;s cheat def delete_duplicates(A: List[int]) -&amp;gt; int: dic = collections.</description>
    </item>
    <item>
      <title>Python to exe with win10 notification</title>
      <link>http://localhost:1313/dev/tool-pytoexe/</link>
      <pubDate>Sat, 31 Oct 2020 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/dev/tool-pytoexe/</guid>
      <description>With this auto-py-to-txe, it&amp;rsquo;s easy to convert your py to a self-contained exe.&#xA;I want to add a win10 notification, at first I tried win10toast.ToastNotifier(), it works fine in py but when I convert it to exe, it&amp;rsquo;s no longer working anymore.&#xA;Then I tried plyer.notification, which works fine. Notince if you want to build a single exe file without folder, and you have resouce like pictures, you need to write a resouce_path function.</description>
    </item>
    <item>
      <title>Auto close quotes for markdown in VsCode</title>
      <link>http://localhost:1313/dev/tool-vscode-markdown-autoclosing/</link>
      <pubDate>Sat, 24 Oct 2020 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/dev/tool-vscode-markdown-autoclosing/</guid>
      <description>Sometimes I want to auto-close double quotes and ` in markdown mode.&#xA;In settings we have such settings but they are not working in plain text files like makrdown.&#xA;Find &amp;ldquo;language-configuration.json&amp;rdquo; under markdown-basic folder. My path: C:\Program Files\Microsoft VS Code\resources\app\extensions\markdown-basics\language-configuration.json&#xA;Add what you want auto close and save it.&#xA;&amp;#34;autoClosingPairs&amp;#34;: [ { &amp;#34;open&amp;#34;: &amp;#34;{&amp;#34;, &amp;#34;close&amp;#34;: &amp;#34;}&amp;#34; }, { &amp;#34;open&amp;#34;: &amp;#34;`&amp;#34;, &amp;#34;close&amp;#34;: &amp;#34;`&amp;#34; }, { &amp;#34;open&amp;#34;: &amp;#34;\&amp;#34;&amp;#34;, &amp;#34;close&amp;#34;: &amp;#34;\&amp;#34;&amp;#34; }, { &amp;#34;open&amp;#34;: &amp;#34;[&amp;#34;, &amp;#34;close&amp;#34;: &amp;#34;]&amp;#34; }, { &amp;#34;open&amp;#34;: &amp;#34;(&amp;#34;, &amp;#34;close&amp;#34;: &amp;#34;)&amp;#34; }, { &amp;#34;open&amp;#34;: &amp;#34;&amp;lt;&amp;#34;, &amp;#34;close&amp;#34;: &amp;#34;&amp;gt;&amp;#34;, &amp;#34;notIn&amp;#34;: [ &amp;#34;string&amp;#34; ] } ], BTW use Ctrl+M Ctrl+C you could generate a code block in markdown.</description>
    </item>
    <item>
      <title>JSP and Servlets</title>
      <link>http://localhost:1313/dev/java-jsp/</link>
      <pubDate>Sat, 03 Oct 2020 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/dev/java-jsp/</guid>
      <description>Based on udemy course&#xA;JSP Basic concept JSP: similar to html page, with some Java code. It&amp;rsquo;s processed on the server, results of Java code included in HTML returned to browser&#xA;jsp expression&amp;lt;%= new java.util.Date() %&amp;gt; Obj, &amp;lt;%= new String(&amp;ldquo;hello&amp;rdquo;).toUpperCase() %&amp;gt; number, &amp;lt;%= 25*4 %&amp;gt; boolean, &amp;lt;%= 5&amp;gt;6 %&amp;gt; jsp scriptlet &amp;lt;% some Java %&amp;gt; out.println() to print. Minimisze the use here. jsp declaration &amp;lt;%! variable or method declaration%&amp;gt; &amp;lt;% String lower(String data){ return data.</description>
    </item>
    <item>
      <title>Spring &amp; Hibernate project on udemy: intellij setting up</title>
      <link>http://localhost:1313/dev/spring-hibernate-udemy/</link>
      <pubDate>Mon, 21 Sep 2020 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/dev/spring-hibernate-udemy/</guid>
      <description>Udemy course link&#xA;In section 28, we start to build a real database web app. Here we use intellij with maven to set it up.&#xA;Download maven config, link Unzip and use intellij to open the inner folder, import as Maven project. Suppose you set up the database correctly, update code in TestDbServlet.java if you use version 8+: String jdbcUrl = &amp;#34;jdbc:mysql://localhost:3306/web_customer_tracker?useSSL=false&amp;amp;serverTimezone=UTC&amp;#34;; String driver = &amp;#34;com.mysql.cj.jdbc.Driver&amp;#34;; Project settings as below:</description>
    </item>
    <item>
      <title>Leetcode: LinkedList in Python</title>
      <link>http://localhost:1313/dev/lee-linkedlist/</link>
      <pubDate>Mon, 31 Aug 2020 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/dev/lee-linkedlist/</guid>
      <description>create a dummy node Merge two linked lists.&#xA;# Definition for singly-linked list. # class ListNode: # def __init__(self, x): # self.val = x # self.next = None class Solution: def mergeTwoLists(self, l1: ListNode, l2: ListNode) -&amp;gt; ListNode: pre = ListNode(0) ans = pre while(l1 != None or l2 != None): if l1 == None or (l2 != None and l2.val &amp;lt;= l1.val): pre.next = l2 l2 = l2.next pre = pre.</description>
    </item>
    <item>
      <title>Python list/dict functions for leetcode</title>
      <link>http://localhost:1313/dev/lee-py-list-dict/</link>
      <pubDate>Sat, 22 Aug 2020 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/dev/lee-py-list-dict/</guid>
      <description>List len(array) : length of array list.indexof(obj) enumerate(array) : adds counter at the beginning. for count, item in enumberate([&#39;x&#39;,&#39;y&#39;,&#39;z&#39;]) # 0x 1y 2z range(0,len(mylist)1,2) range(0,3), is 0,1,2 for i in reversed(range(len(A))) nums.append(val), nums.remove(val), nums.reverse() nums.extend(nums2) list.insert(index, obj) list.pop() default pop index is -1, remove the last one nums[:] copy the value within function: b[:]=a .copy is equals to b[:] temp = self.original[:] copy.deepcopy could copy nested list import copy , copy.</description>
    </item>
    <item>
      <title>Python String functions for leetcode</title>
      <link>http://localhost:1313/dev/lee-py-string/</link>
      <pubDate>Sat, 22 Aug 2020 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/dev/lee-py-string/</guid>
      <description> print(f&#39;best RF score: {grid.best_score_:.3f}&#39;) str.index(sub[,start[,end]]) str.strip() remove spaces at the beginning and the end strip(str-not-want) lower() print(str.upper()) print(str.lower()) print(str.capitalize()) # Only first letter big print(str.title()) # This Is A Title s.find(c), s.rfind(c) &amp;ldquo;hello&amp;rdquo;.find(&amp;ldquo;l&amp;rdquo;) -&amp;gt; 2 &amp;ldquo;hello&amp;rdquo;.rfind(&amp;ldquo;l&amp;rdquo;) -&amp;gt; 3 s.split(&#39;&#39;) a = &#39;&#39;.join(a.split()) remove blank replace(old, new[, max]) &#39;&#39;.join(str(e) for e in list) list to str s.isdigit(), s.isalpha s.isalnum() # is num or alpha if i.lstrip(&amp;rsquo;-&amp;rsquo;).isdigit(): check number&amp;lt;0 ord , chr ord(&#39;A&#39;) get 65 chr(65) get A a = (chr(ord(&#39;0&#39;) + x % 10)) x:123 get: str type &amp;lsquo;3&amp;rsquo; </description>
    </item>
    <item>
      <title>Using latex with VsCode</title>
      <link>http://localhost:1313/dev/tool-latex-vscode/</link>
      <pubDate>Sun, 16 Aug 2020 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/dev/tool-latex-vscode/</guid>
      <description>Refer&#xA;On windows:&#xA;Install texLive.&#xA;Add the path to environment variable. Install &amp;ldquo;Latex workship&amp;rdquo; on vscode.&#xA;Open your tex file, View Latex PDF File, you are ready to go.&#xA;On manjaro:&#xA;sudo pacman -S textlive-most </description>
    </item>
    <item>
      <title>Oral history of two Christians in a Chinese labour camp in the 1960s</title>
      <link>http://localhost:1313/posts/christian-1960-camps/</link>
      <pubDate>Tue, 11 Aug 2020 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/christian-1960-camps/</guid>
      <description>The Great Chinese famine from 1959 to 1961 in China killed 15 to 55 million people.&#xA;In those years, many intellectuals were sent to a re-education labour camp in Jiabiangou, Gansu province. People ate everything they could and couldn&amp;rsquo;t eat, some couldn&amp;rsquo;t even go outside to defecate, and could only pull it on their frozen bed. Tree bark was eaten up and some people ate human corpses. Some people were deliberately buried very shallow, so they were easily dug out to be eaten at night.</description>
    </item>
    <item>
      <title>Increament an arbitrary precision integer</title>
      <link>http://localhost:1313/leetcode/epi-5.2-increment-an-arbitrary-precision-integer/</link>
      <pubDate>Sun, 19 Jul 2020 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/epi-5.2-increment-an-arbitrary-precision-integer/</guid>
      <description>6.2 in EPI java, 5.2 in EPI python. Takes as input an array of digits encoding a decimal number D and updates the array to represetnt the number D+1. For eg. if the input is &amp;lt;1,2,9&amp;gt; then you should update the array to &amp;lt;1,3,0&amp;gt;.&#xA;A brute-force approach might be to convert the array to integer, add one and convert back. If integer had a limit of range this method will fail.</description>
    </item>
    <item>
      <title>The Dutch National Flag Program</title>
      <link>http://localhost:1313/leetcode/epi-5.1-dutch-flag/</link>
      <pubDate>Tue, 30 Jun 2020 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/epi-5.1-dutch-flag/</guid>
      <description>6.1 in EPI java, 5.1 in EPI python. Takes an array A and an index i into A, and rearranges the elements such that all elements less than A[i] (the &amp;ldquo;pivot&amp;rdquo;) appear first, followed by elements equal to the pivot, followed by elements greater than the pivot.&#xA;e.g.: A={0,1,2,0,2,1,1}, index=3, A[3]=0, so a valid partitioning is {0,0,1,2,2,1,1}.&#xA;The first round, we move number smaller than pivot to the left side, the second turn we do the bigger side.</description>
    </item>
    <item>
      <title>Automated Mongodb github Backups</title>
      <link>http://localhost:1313/dev/tool-autobackup/</link>
      <pubDate>Thu, 04 Jun 2020 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/dev/tool-autobackup/</guid>
      <description>refer: https://github.com/VeliovGroup/ostrio/blob/master/tutorials/linux/security/automated-backups.md&#xA;A script to automatically backup your mongodb database and related logs etc., then commit to your github daily. It also deletes your old backup that older than 7 days.&#xA;#!/bin/bash # Change Directory to repository cd /root/backup/ DATE=$(date +%Y%m%d) DATEOLD=`date -d &amp;#34;${DATE} -7 day&amp;#34; +%Y%m%d` mongodump \ -d datadb \ -u xx \ -p xx \ --gzip \ --archive=&amp;#34;/root/backup/mongodb.$DATE.gz&amp;#34; tar -zcf &amp;#34;/root/backup/syslog.$DATE.tar.gz&amp;#34; -C / var/log/syslog tar -zcf &amp;#34;/root/backup/auth.$DATE.tar.gz&amp;#34; -C / var/log/auth.</description>
    </item>
    <item>
      <title>Hugo website optimization: Table of Contents</title>
      <link>http://localhost:1313/dev/hugo-toc/</link>
      <pubDate>Fri, 22 May 2020 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/dev/hugo-toc/</guid>
      <description>This TOC plugin using bootstrap is very easy to use in Hugo.&#xA;Usage Set up Bootstrap v4. For Bootstrap v3, see the older instructions. Include the Bootstrap Table of Contents stylesheet and JavaScript file. &amp;lt;!-- add after bootstrap.min.css --&amp;gt; &amp;lt;link rel=&amp;#34;stylesheet&amp;#34; href=&amp;#34;https://cdn.rawgit.com/afeld/bootstrap-toc/v1.0.1/dist/bootstrap-toc.min.css&amp;#34; /&amp;gt; &amp;lt;!-- add after bootstrap.min.js --&amp;gt; &amp;lt;script src=&amp;#34;https://cdn.rawgit.com/afeld/bootstrap-toc/v1.0.1/dist/bootstrap-toc.min.js&amp;#34;&amp;gt;&amp;lt;/script&amp;gt; Put it simple, just edit layouts/_default/baseof.html. Add some scripts before the end of body, and add 2 links in the beginning.</description>
    </item>
    <item>
      <title>Install VMware Workstation on Manjaro</title>
      <link>http://localhost:1313/dev/tool-installvm/</link>
      <pubDate>Sun, 17 May 2020 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/dev/tool-installvm/</guid>
      <description>vmmon error After installation, you can&amp;rsquo;t open VMware directly. It will show an error:&#xA;VMWare could not find module ‘vmmon’, Please Make Sure That The Kernel Module &amp;lsquo;vmmon&amp;rsquo; Is Loaded.&#xA;manjaro wiki&#xA;The AUR package vmware-workstation will install VMWare Workstation and the dkms modules needed to run it.&#xA;It can be installed with:&#xA;pamac build vmware-workstation After installing, either reboot, or load the required modules&#xA;sudo modprobe -a vmw_vmci vmmon There are three services that can be optionally be enabled:</description>
    </item>
    <item>
      <title>Find a closest integer with the same weight</title>
      <link>http://localhost:1313/leetcode/epi-4.4-closest-int/</link>
      <pubDate>Fri, 15 May 2020 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/epi-4.4-closest-int/</guid>
      <description>EPI Python 4.4 The weight of x to be the number of bits that are set to 1 in its binary reprentations. E.g. 92 in bas-2 is $(1011100)_2$, the weight is 4.&#xA;Take a nonnegative integer x, return a number y with the same weight of x, and their difference is as small as possible.&#xA;The main idea is to swap the two rightmost consecutive bits that differ. The time complexity is O(n), where n is the width.</description>
    </item>
    <item>
      <title>Primitive Multiple</title>
      <link>http://localhost:1313/leetcode/epi-4.5-primitive-multiple/</link>
      <pubDate>Fri, 15 May 2020 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/epi-4.5-primitive-multiple/</guid>
      <description>EPI python 4.5 Use bit manipulation to multiple.&#xA;Iterate through the bits of x, adding the $2^ky$ to the result if the kth bit of x is 1.&#xA;java public static long multiply(long x, long y) { long res = 0; while (x != 0) { if ((x&amp;amp;1) != 0) { res = add(res, y); } x &amp;gt;&amp;gt;= 1; y &amp;lt;&amp;lt;= 1; } return res; } private static long add(long x, long y) { long carry; while (y !</description>
    </item>
    <item>
      <title>Reverse bits</title>
      <link>http://localhost:1313/leetcode/epi-4.3-reverse-bits/</link>
      <pubDate>Fri, 15 May 2020 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/epi-4.3-reverse-bits/</guid>
      <description>Leetcode 190 Similar question. Reverse bits of a given 32 bits unsigned integer.&#xA;Example 1: Input: 00000010100101000001111010011100&#xA;Output: 00111001011110000010100101000000&#xA;Explanation: The input binary string 00000010100101000001111010011100 represents the unsigned integer 43261596, so return 964176192 which its binary representation is 00111001011110000010100101000000.&#xA;With python, we just get all bits in an array and reverse it, then turn it back to a number.&#xA;class Solution: # @param n, an integer # @return an integer def reverseBits(self, n): s = str(bin(n)).</description>
    </item>
    <item>
      <title>Swap bits</title>
      <link>http://localhost:1313/leetcode/epi-4.2-swap-bits/</link>
      <pubDate>Sun, 10 May 2020 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/epi-4.2-swap-bits/</guid>
      <description>5.2 in EPI java, 4.2 in EPI python. Swap the ith and jth bit in a long number.&#xA;The 2^i in java means the parity(XOR) of 2 and i, we need to use Math.pow to calculate the power of number.&#xA;public static long swapBits(long x, int i, int j) { // Extract the ith and jth bit short xi = (short) ((short) (x &amp;gt;&amp;gt; i) &amp;amp; 1); short xj = (short) ((short) (x &amp;gt;&amp;gt; j) &amp;amp; 1); if (xi == xj) { return x; } // long swap = 2^i + 2^j; // long swap0 = (long) (Math.</description>
    </item>
    <item>
      <title>Hugo: Copy-code button, Math Katex, Google analytics</title>
      <link>http://localhost:1313/dev/hugo-copy-code/</link>
      <pubDate>Fri, 08 May 2020 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/dev/hugo-copy-code/</guid>
      <description>Recently I did several changes on hugo.&#xA;Code highlight There are many ways to make the syntax highlight better, for this hugo-coder theme, all we need to do is delete those pygments related config in config.toml. See the hugo doc to find more options.&#xA;Copy code button Reference I just changed the css to make the button within the code.&#xA;.copy-code-button { color: #c4c5c6; background-color: #444444; /*border: 2px solid;*/ border-width: 0 0 0 0; /*border-left-color: rgba(32, 226, 226, 0.</description>
    </item>
    <item>
      <title>Computing the parity of a word</title>
      <link>http://localhost:1313/leetcode/epi-4.1-parity/</link>
      <pubDate>Wed, 06 May 2020 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/epi-4.1-parity/</guid>
      <description>5.1 in EPI java, 4.1 in EPI python. The parity of a binary word is 1 if the number of 1s is odd; otherwise it&amp;rsquo;s 0. How to check the parity of a very large number of 64-bit words?&#xA;A straight forward(brute-force) solution is to go through the bitwised number, get the last bit every time and check weather it&amp;rsquo;s 1. The time complexity is O(n) where n is the word size.</description>
    </item>
    <item>
      <title>Amazing ultimate note tool: Dynalist</title>
      <link>http://localhost:1313/dev/tool-dynalist/</link>
      <pubDate>Mon, 04 May 2020 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/dev/tool-dynalist/</guid>
      <description>Dynalist is one of the most helpful tools for me nowadays, no matter code, work notes, daily notes such as training records, prayer list etc. All stuff can be handled within it.&#xA;I used to use OneNote when I was in University, everyone knows how powerful it is. The downside is obvious, it&amp;rsquo;s too heavy. I need a better tool to write everything down quickly and jump to everywhere with a keyboard.</description>
    </item>
    <item>
      <title>Autohotkey/Autokey scripts for Dynalist</title>
      <link>http://localhost:1313/dev/tool-autohotkey/</link>
      <pubDate>Mon, 04 May 2020 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/dev/tool-autohotkey/</guid>
      <description>Autohotkey Picture Suppose the picture link is in your clipboard, to put a picture in Dynalist(or any markdown editor) In your clipboard you have a picture link like https://i.imgur.com/XH472FR.png&#xA;Click Alt+P, you got&#xA;![](https://i.imgur.com/XH472FR.png) !p:: Send, {!}[]() Sleep, 50 Send, {Left 1} Sleep, 50 Send ^v return Code In your clipboard, you have print(&amp;lsquo;Hello&amp;rsquo;). Click win+` in dynalist next to test, you got this nice result.&#xA;#`:: Send {Enter} Send {Tab} Send, code Send +{Enter} Send, ```````````` Sleep, 50 Send, {Left 3} Send ^v return Autokey It&amp;rsquo;s similar as above, just on Linux.</description>
    </item>
    <item>
      <title>Documentaries about China</title>
      <link>http://localhost:1313/posts/tip-documentary/</link>
      <pubDate>Wed, 01 Apr 2020 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/tip-documentary/</guid>
      <description>Recommended, with English subtitle 棒！少年 Tough out&#xA;豆瓣 IMDB Youtube 废城 Ghost Town&#xA;IMDB 豆瓣 Youtube 矿民、马夫、尘肺病 Miners, Groom, Pneumoconiosis 8.7&#xA;Published in 2019, 10 years with illegal miners in China&#xA;豆瓣 IMDB Youtube 算命 Fortune Teller 9.0&#xA;Ture village life through a fortune teller&#xA;豆瓣 IMDB Youtube 高三 Senior year 8.4&#xA;The most important exam in China that can determine a lifetime&#xA;豆瓣 IMDB Youtube 书记 The Transition Period 8.</description>
    </item>
    <item>
      <title>The world is far from God, close to China</title>
      <link>http://localhost:1313/posts/opinion-china-eng/</link>
      <pubDate>Mon, 30 Mar 2020 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/opinion-china-eng/</guid>
      <description>Appreciate Peter&amp;rsquo;s help.&#xA;The ignoble are the wisest, the noble are the stupidest. These sayings are the essence of Mao Zedong&amp;rsquo;s thought, for the majority of Chinese to live by, the formation of the present China.&#xA;Basically, the evolution of the Zhuxia(Huaxia, Chinese) civilization is a deteriorating change: from the Spring and Autumn, the Warring States to the Qin and Han dynasties, and then through the Wei, Jin, Sui, Tang, Song, Yuan, Ming and Qing dynasties, we can clearly see a trend: the backbone of society such as nobles, clans, etc.</description>
    </item>
    <item>
      <title>Spring In Action 02 - Developing web app</title>
      <link>http://localhost:1313/dev/spring02-web/</link>
      <pubDate>Wed, 19 Feb 2020 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/dev/spring02-web/</guid>
      <description>This chapter focues on Spring web framework without database.&#xA;2.1 Displaying infomation 2.1.1 Establishing the domain package tacos; import lombok.Data; import lombok.RequiredArgsConstructor; @Data @RequiredArgsConstructor public class Ingredient { private final String id; private final String name; private final Type type; public static enum Type { WRAP, PROTEIN, VEGGIES, CHEESE, SAUCE } } 2.1.2 Creating a controller class Controllers are the major players in Spring’s MVC framework. Their primary job is to handle HTTP requests and either hand a request off to a view to render HTML (browser-displayed) or write data directly to the body of a response (RESTful).</description>
    </item>
    <item>
      <title>Spring In Action 03 - Data</title>
      <link>http://localhost:1313/dev/spring03-data/</link>
      <pubDate>Wed, 19 Feb 2020 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/dev/spring03-data/</guid>
      <description>JDBC at first and JPA later.&#xA;3.1 Reading and writing data with JDBC Spring JDBC support is rooted in the JdbcTemplate class. JdbcTemplate provides a means by which developers can perform SQL operations against a relational database without all the ceremony and boilerplate typically required when working with JDBC.&#xA;3.2 Persisting data with Spring Data JPA Summary Spring’s JdbcTemplate greatly simplifies working with JDBC. PreparedStatementCreator and KeyHolder can be used together when you need to know the value of a database-generated ID.</description>
    </item>
    <item>
      <title>Spring In Action 01 - Intro</title>
      <link>http://localhost:1313/dev/spring01-intro/</link>
      <pubDate>Fri, 07 Feb 2020 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/dev/spring01-intro/</guid>
      <description>Follow the book: Spring in Action fifth version. Code repo: github&#xA;1.1 What is Spring? At its core, Spring offers a container, often referred to as the Spring application context, that creates and manages application components. These components, or beans, are wired together inside the Spring application context to make a complete application, much like bricks, mortar, timber, nails, plumbing, and wiring are bound together to make a house.&#xA;The act of wiring beans together is based on a pattern known as dependency injection (DI).</description>
    </item>
    <item>
      <title>Data mining module outline</title>
      <link>http://localhost:1313/dev/warwick-909/</link>
      <pubDate>Wed, 10 Apr 2019 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/dev/warwick-909/</guid>
      <description>For Warwick University module 909, data mining.&#xA;1. intro machine learning framework define a set of functions define a fitting criteria pick the best function machine learning learn a function of: $f:x \to{y}$ y is discrete: classification y is continuous: regression roadmap supervised learning regression classification logistic regression, SVM, neural networks unsupervised learning clustering kmeans, AHC dimension reduction, PCA ensemble learning transfer learning 2. data defination collection of data objects and their attributes attribute is a property or characteristic of an object discrete/continuous nominal: values are distinct symbols ID, eye color, zip codes ordinal: impose order on values but no distance between values defined military rank, exam grade, rating interval: has a fixed size of interval between data points year, temperature ratio: same as interval,0 means does not exist weight, age data quality noise outliers missing values duplicate 3.</description>
    </item>
    <item>
      <title>Data analysis module outline</title>
      <link>http://localhost:1313/dev/warwick-910/</link>
      <pubDate>Fri, 29 Mar 2019 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/dev/warwick-910/</guid>
      <description>For Warwick University module 910, Data analysis.&#xA;2. math back ground why frequency/rank for heavy tailed? The frequency/rank plot because the CCDF is a monotonous function. Moreover, unlike the PDF function, the CCDF displays a significantly lower variability in the tail.&#xA;independence: event and random variables HH and TT not independent because the mere occurrence of one would tell us for sure that the other can’t happen. Conditional Probability Heavy-Tailed Distributions roughly non-negligible probabilities at large values far to the right.</description>
    </item>
    <item>
      <title>High-performance computing module outline</title>
      <link>http://localhost:1313/dev/warwick-402/</link>
      <pubDate>Sun, 10 Mar 2019 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/dev/warwick-402/</guid>
      <description>For Warwick University module 402, high performance computation.&#xA;1.Fundamentals 1.1 the technologies needed to support HPC computer architecture CPU, memory VLSI, transistors multicore, to ease the density(temperature etc.) GPU networking bandwidth, latency communication protocols network topology compilers identify inefficient implementations make use of the characteristics of the computer arcitecture choose a suitable compiler for a certain architecture algorithms design parallel paradigm of parallel programming workload and resource manager task scheduling and resource allocation metrcs 1.</description>
    </item>
    <item>
      <title>Natural language processing module outline</title>
      <link>http://localhost:1313/dev/warwick-918/</link>
      <pubDate>Sun, 10 Mar 2019 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/dev/warwick-918/</guid>
      <description>For Warwick University module 918, natural language processing.&#xA;Question 1: Regular expressions, linguistic preprocessing, minimum edit distance algorithm. 1 regular expression remember use \.&#xA;false positive type1: have output, shouldn&amp;rsquo;t. precision = tp/(tp+fp)&#xA;false negatives(type 2): haven&amp;rsquo;t output, but should minimise, increase recall recall = tp/(tp+fn)&#xA;F1= 2 precision* recall/(precision+recall)&#xA;2 text preprocessing vocabulary size: the number of different types of tokens in the text.&#xA;All need 3 steps tokenizing/segmentting words in running text normalizing word formats segmenting sentences in running text Issues of tokenisation What counts as a word is usually application specific.</description>
    </item>
    <item>
      <title>La Valentina</title>
      <link>http://localhost:1313/posts/share-lavalentina/</link>
      <pubDate>Wed, 02 Jan 2019 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/share-lavalentina/</guid>
      <description>Because of my passion,&#xA;they say that ill fortune is on my way.&#xA;It doesn’t matter that it might be the devil himself.&#xA;I do know how to die&#xA;Valentina, Valentina.&#xA;I throw my self in your way.&#xA;If I am going to die tomorrow,&#xA;why not, once and for all, today?&#xA;翻译一 因为我斗志昂扬，他们说我要走背运。&#xA;最好是魔鬼本人亲自来吧，那才叫无可担忧。&#xA;我知道如何奔赴死亡&#xA;华伦汀娜，华伦汀娜。&#xA;我置身魔鬼的往来路。&#xA;如果我将来终归一死，&#xA;为什么不在今天一劳永逸地奔向死亡？&#xA;翻译二来自《内在的火焰》 由于我的热情，他们说恶运正迎面而来。&#xA;就算是魔鬼本人&#xA;也没有关系。&#xA;我知道如何赴死&#xA;瓦沦汀娜，瓦沦汀娜，&#xA;我把自己投在你的脚前。&#xA;如果我明天就要赴死，&#xA;那么为什么不一劳永逸地，就在今天呢？</description>
    </item>
    <item>
      <title>Sensor network module outline</title>
      <link>http://localhost:1313/dev/warwick-912/</link>
      <pubDate>Wed, 19 Dec 2018 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/dev/warwick-912/</guid>
      <description>For Warwick University module 912, sensor network.&#xA;Link quality estimation 2 link monitor active A node monitors the links to its neighbours by sending probe packets. passive Passive link monitoring exploits existing traffic without incurring additional communication overhead. A node listens to transmitted packets (even if these packets are not addressed to it). Process called (over-hearing). can also listen to ack sent by neighbours. lack up-to-date. Data link layer 3 hidden, exposed CSMA/CA MACAW IEEE802.</description>
    </item>
    <item>
      <title>Solitary Bird</title>
      <link>http://localhost:1313/posts/share-solitery-bird/</link>
      <pubDate>Tue, 02 Jan 2018 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/share-solitery-bird/</guid>
      <description>Las condiciones del pájaro solitario son cinco:&#xA;la primera, que se va a lo más alto;&#xA;la segunda, que no sufre compañía aunque sea de su naturaleza;&#xA;la tercera, que pone el pico al aire;&#xA;la cuarta, que no tiene determinado color; la quinta, que canta suavemente.&#xA;——San Juan de La Cruz 〝Dicbos de Luz y Amor〞&#xA;孤独之鸟有五项特征:&#xA;第一，它总朝最高的目标飞翔；&#xA;第二，它不需要同伴，甚至包括与它志同道合的；&#xA;第三，它的喙总是对准天空；&#xA;第四，它没有特定的颜色；&#xA;第五，它的歌声非常温柔&#xA;——圣横•德拉克鲁兹：《知识与爱情的箴言》 (常译为 十字若望《光与爱的话语》)&#xA;The conditions of a solitary bird are five:</description>
    </item>
    <item>
      <title>Leetcode: Array questions with Python</title>
      <link>http://localhost:1313/dev/lee-array/</link>
      <pubDate>Wed, 09 Aug 2017 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/dev/lee-array/</guid>
      <description>134.Gas Station There are N gas stations along a circular route, where the amount of gas at station i is gas[i]. You have a car with an unlimited gas tank and it costs cost[i] of gas to travel from station i to its next station (i+1). You begin the journey with an empty tank at one of the gas stations. Return the starting gas station&amp;rsquo;s index if you can travel around the circuit once in the clockwise direction, otherwise return -1.</description>
    </item>
    <item>
      <title>About</title>
      <link>http://localhost:1313/about/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/about/</guid>
      <description>Just sharing some personal posts.&#xA;God bless.</description>
    </item>
    <item>
      <title>Contact</title>
      <link>http://localhost:1313/contact/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/contact/</guid>
      <description>emailto: yanchiyu@outlook.com</description>
    </item>
  </channel>
</rss>
