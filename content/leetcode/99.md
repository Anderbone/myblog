+++ 
date = "2022-04-19"
title = "99. Recover Binary Search Tree"
tags = ["binarysearchtree"]
+++
[Recover Binary Search Tree - LeetCode](https://leetcode.com/problems/recover-binary-search-tree/)

You are given the root of a binary search tree (BST), where the values of exactly two nodes of the tree were swapped by mistake. __Recover the tree without changing its structure__.
 
Example 1:
![](https://assets.leetcode.com/uploads/2020/10/28/recover1.jpg)Input: root = [1,3,null,null,2] Output: [3,1,null,null,2] Explanation: 3 cannot be a left child of 1 because 3 > 1. Swapping 1 and 3 makes the BST valid. 
Example 2:
![](https://assets.leetcode.com/uploads/2020/10/28/recover2.jpg)Input: root = [3,1,4,null,null,2] Output: [2,1,4,null,null,3] Explanation: 2 cannot be in the right subtree of 3 because 2 < 3. Swapping 2 and 3 makes the BST valid. 
 
Constraints:

	The number of nodes in the tree is in the range [2, 1000].
	-231 <= Node.val <= 231 - 1

---
- code
```py
class Solution:
    def recoverTree(self, root: Optional[TreeNode]) -> None:
        flat = []
        def inorder(node):
            if not node: return
            inorder(node.left)
            flat.append(node)
            inorder(node.right)
            
        inorder(root)
        first = second = root
        for i in range(len(flat)-1):
            if flat[i].val > flat[i+1].val:
                first = flat[i]
                break
        
        for i in range(len(flat)-1, 0, -1):
            if flat[i].val < flat[i-1].val:
                second = flat[i]
                break
        first.val, second.val = second.val, first.val
```
- code
```java
class Solution {
    private ArrayList<TreeNode> flat = new ArrayList<>();
    private void inorder(TreeNode root){
        if (root == null) return;
        inorder(root.left);
        flat.add(root);
        inorder(root.right);
    }
    public void recoverTree(TreeNode root) {
        inorder(root);
        TreeNode first = root, second = root;
        for (int i = 0; i < flat.size()-1; i++){
            if (flat.get(i).val > flat.get(i+1).val){
                first = flat.get(i);
                break;
            }
        }
        for (int i = flat.size()-1; i > 0; i--){
            if (flat.get(i).val < flat.get(i-1).val){
                second = flat.get(i);
                break;
            }
        }
        int temp = first.val;
        first.val = second.val;
        second.val = temp;
        
    }
}
```
